 <!DOCTYPE html>
		<html
			class="layout layout-holy-grail   show-table-of-contents conceptual show-breadcrumb default-focus"
			lang="en-us"
			dir="ltr"
			data-authenticated="false"
			data-auth-status-determined="false"
			data-target="docs"
			x-ms-format-detection="none"
		>
			
		
<!-- Mirrored from learn.microsoft.com/en-us/aspnet/core/mvc/controllers/routing?view=aspnetcore-9.0 by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 06 Aug 2025 14:53:03 GMT -->
<head>
			<title>Routing to controller actions in ASP.NET Core | Microsoft Learn</title>
			<meta charset="utf-8" />
			<meta name="viewport" content="width=device-width, initial-scale=1.0" />
			<meta name="color-scheme" content="light dark" />

			<meta name="description" content="Learn how ASP.NET Core MVC uses Routing Middleware to match URLs of incoming requests and map them to actions." />
			<link rel="canonical" href="routing553c.html?view=aspnetcore-9.0" /> 

			<!-- Non-customizable open graph and sharing-related metadata -->
			<meta name="twitter:card" content="summary" />
			<meta name="twitter:site" content="@MicrosoftLearn" />
			<meta property="og:type" content="website" />
			<meta property="og:image:alt" content="Routing to controller actions in ASP.NET Core | Microsoft Learn" />
			<meta property="og:image" content="https://learn.microsoft.com/dotnet/media/dotnet-logo.png" />
			<!-- Page specific open graph and sharing-related metadata -->
			<meta property="og:title" content="Routing to controller actions in ASP.NET Core" />
			<meta property="og:url" content="routing553c.html?view=aspnetcore-9.0" />
			<meta property="og:description" content="Learn how ASP.NET Core MVC uses Routing Middleware to match URLs of incoming requests and map them to actions." />
			<meta name="platform_id" content="742ebeab-97f7-2d35-74e8-9175c9e94e7f" /> <meta name="scope" content="ASP.NET Core" />
			<meta name="locale" content="en-us" />
			 <meta name="adobe-target" content="true" />
			<meta name="uhfHeaderId" content="MSDocsHeader-AspNet" />

			<meta name="page_type" content="conceptual" />

			<!--page specific meta tags-->
			

			<!-- custom meta tags -->
			
		<meta name="breadcrumb_path" content="/aspnet/core/breadcrumb/toc.json" />
	
		<meta name="feedback_system" content="OpenSource" />
	
		<meta name="feedback_product_url" content="https://github.com/dotnet/aspnetcore/blob/main/CONTRIBUTING.md" />
	
		<meta name="ms.service" content="aspnet-core" />
	
		<meta name="ms.topic" content="conceptual" />
	
		<meta name="ms.subservice" content="mvc" />
	
		<meta name="author" content="tdykstra" />
	
		<meta name="ms.author" content="tdykstra" />
	
		<meta name="ms.date" content="2022-04-08T00:00:00Z" />
	
		<meta name="uid" content="mvc/controllers/routing" />
	
		<meta name="document_id" content="8ee6ad2f-1667-8d5c-1f36-9d0511e3720f" />
	
		<meta name="document_version_independent_id" content="7838ccec-c8e8-9baa-2b3e-220b2af5fc58" />
	
		<meta name="updated_at" content="2025-05-28T13:47:00Z" />
	
		<meta name="original_content_git_url" content="https://github.com/dotnet/AspNetCore.Docs/blob/live/aspnetcore/mvc/controllers/routing.md" />
	
		<meta name="gitcommit" content="https://github.com/dotnet/AspNetCore.Docs/blob/4d023bd9ef1481cf2b7437b355227f445c4aa949/aspnetcore/mvc/controllers/routing.md" />
	
		<meta name="git_commit_id" content="4d023bd9ef1481cf2b7437b355227f445c4aa949" />
	
		<meta name="monikers" content="aspnetcore-1.0" />
	
		<meta name="monikers" content="aspnetcore-1.1" />
	
		<meta name="monikers" content="aspnetcore-2.0" />
	
		<meta name="monikers" content="aspnetcore-2.1" />
	
		<meta name="monikers" content="aspnetcore-2.2" />
	
		<meta name="monikers" content="aspnetcore-3.0" />
	
		<meta name="monikers" content="aspnetcore-3.1" />
	
		<meta name="monikers" content="aspnetcore-5.0" />
	
		<meta name="monikers" content="aspnetcore-6.0" />
	
		<meta name="monikers" content="aspnetcore-7.0" />
	
		<meta name="monikers" content="aspnetcore-8.0" />
	
		<meta name="monikers" content="aspnetcore-9.0" />
	
		<meta name="monikers" content="aspnetcore-10.0" />
	
		<meta name="default_moniker" content="aspnetcore-9.0" />
	
		<meta name="site_name" content="Docs" />
	
		<meta name="depot_name" content="MSDN.aspnet-core-conceptual" />
	
		<meta name="schema" content="Conceptual" />
	
		<meta name="toc_rel" content="../../toc.json" />
	
		<meta name="pdf_url_template" content="https://learn.microsoft.com/pdfstore/en-us/MSDN.aspnet-core-conceptual/{branchName}{pdfName}" />
	
		<meta name="feedback_help_link_type" content="" />
	
		<meta name="feedback_help_link_url" content="" />
	
		<meta name="word_count" content="14893" />
	
		<meta name="config_moniker_range" content="&gt;= aspnetcore-1.0" />
	
		<meta name="asset_id" content="mvc/controllers/routing" />
	
		<meta name="moniker_range_name" content="63df444442f95e9131e3b83a36ddb51e" />
	
		<meta name="item_type" content="Content" />
	
		<meta name="source_path" content="aspnetcore/mvc/controllers/routing.md" />
	
		<meta name="previous_tlsh_hash" content="A8019D73721CAB10FF815F069A26B6112BF4C06C7CE82F5409257950E01FAE7BCBB39EE5E67B775123350BA382E5F34E85E4DB39C2AC73520492589CD6C821958B583FBADD" />
	
		<meta name="github_feedback_content_git_url" content="https://github.com/dotnet/AspNetCore.Docs/blob/main/aspnetcore/mvc/controllers/routing.md" />
	 
		<meta name="cmProducts" content="https://microsoft-devrel.poolparty.biz/DevRelOfferingOntology/e72e5f83-fd84-4f1d-88e0-dec3350a8a10" data-source="generated" />
	
		<meta name="cmProducts" content="https://authoring-docs-microsoft.poolparty.biz/devrel/d452572f-6212-498f-9050-ca4a9e50a425" data-source="generated" />
	
		<meta name="cmProducts" content="https://authoring-docs-microsoft.poolparty.biz/devrel/97159432-14a9-4307-a469-d2f2c75f0e33" data-source="generated" />
	
		<meta name="spProducts" content="https://microsoft-devrel.poolparty.biz/DevRelOfferingOntology/81a11282-2f1c-4a63-95c5-6e6f262fea55" data-source="generated" />
	
		<meta name="spProducts" content="https://authoring-docs-microsoft.poolparty.biz/devrel/a12e40b7-59a2-4437-96e2-166ce622b864" data-source="generated" />
	
		<meta name="spProducts" content="https://authoring-docs-microsoft.poolparty.biz/devrel/50565c62-5f6b-4687-be38-323113c72c2e" data-source="generated" />
	

			<!-- assets and js globals -->
			
			<link rel="stylesheet" href="https://learn.microsoft.com/static/assets/0.4.03137.7032-e8b681c0/styles/site-ltr.css" />
			<link rel="preconnect" href="http://mscom.demdex.net/" crossorigin />
						<link rel="dns-prefetch" href="http://target.microsoft.com/" />
						<link rel="dns-prefetch" href="http://microsoftmscompoc.tt.omtrdc.net/" />
						<link
							rel="preload"
							as="script"
							href="https://learn.microsoft.com/static/third-party/adobe-target/at-js/2.9.0/at.js"
							integrity="sha384-1/viVM50hgc33O2gOgkWz3EjiD/Fy/ld1dKYXJRUyjNYVEjSUGcSN+iPiQF7e4cu"
							crossorigin="anonymous"
							id="adobe-target-script"
							type="application/javascript"
						/>
			<script src="https://wcpstatic.microsoft.com/mscc/lib/v2/wcp-consent.js"></script>
			<script src="https://js.monitor.azure.com/scripts/c/ms.jsll-4.min.js"></script>
			<script src="https://learn.microsoft.com/_themes/docs.theme/master/en-us/_themes/global/deprecation.js"></script>

			<!-- msdocs global object -->
			<script id="msdocs-script">
		var msDocs = {
  "environment": {
    "accessLevel": "online",
    "azurePortalHostname": "portal.azure.com",
    "reviewFeatures": false,
    "supportLevel": "production",
    "systemContent": true,
    "siteName": "learn",
    "legacyHosting": false
  },
  "data": {
    "contentLocale": "en-us",
    "contentDir": "ltr",
    "userLocale": "en-us",
    "userDir": "ltr",
    "pageTemplate": "Conceptual",
    "brand": "",
    "context": {},
    "standardFeedback": false,
    "showFeedbackReport": false,
    "feedbackHelpLinkType": "",
    "feedbackHelpLinkUrl": "",
    "feedbackSystem": "OpenSource",
    "feedbackGitHubRepo": "dotnet/AspNetCore.Docs",
    "feedbackProductUrl": "https://github.com/dotnet/aspnetcore/blob/main/CONTRIBUTING.md",
    "extendBreadcrumb": false,
    "isEditDisplayable": true,
    "isPrivateUnauthorized": false,
    "hideViewSource": false,
    "isPermissioned": false,
    "hasRecommendations": true,
    "contributors": [
      {
        "name": "tdykstra",
        "url": "https://github.com/tdykstra"
      },
      {
        "name": "guardrex",
        "url": "https://github.com/guardrex"
      },
      {
        "name": "benhopkinstech",
        "url": "https://github.com/benhopkinstech"
      },
      {
        "name": "Rick-Anderson",
        "url": "https://github.com/Rick-Anderson"
      },
      {
        "name": "garyng",
        "url": "https://github.com/garyng"
      },
      {
        "name": "w-syss",
        "url": "https://github.com/w-syss"
      },
      {
        "name": "serpent5",
        "url": "https://github.com/serpent5"
      },
      {
        "name": "rekker22",
        "url": "https://github.com/rekker22"
      },
      {
        "name": "scottaddie",
        "url": "https://github.com/scottaddie"
      },
      {
        "name": "ericmutta",
        "url": "https://github.com/ericmutta"
      },
      {
        "name": "JeroenOortwijn",
        "url": "https://github.com/JeroenOortwijn"
      },
      {
        "name": "PeymanMahdavi",
        "url": "https://github.com/PeymanMahdavi"
      },
      {
        "name": "brgrz",
        "url": "https://github.com/brgrz"
      },
      {
        "name": "rynowak",
        "url": "https://github.com/rynowak"
      },
      {
        "name": "gurry",
        "url": "https://github.com/gurry"
      },
      {
        "name": "miloszkukla",
        "url": "https://github.com/miloszkukla"
      },
      {
        "name": "JamesNK",
        "url": "https://github.com/JamesNK"
      },
      {
        "name": "v-maudel",
        "url": "https://github.com/v-maudel"
      },
      {
        "name": "pkellner",
        "url": "https://github.com/pkellner"
      },
      {
        "name": "MaxHorstmann",
        "url": "https://github.com/MaxHorstmann"
      },
      {
        "name": "bmermet",
        "url": "https://github.com/bmermet"
      },
      {
        "name": "ec-milan",
        "url": "https://github.com/ec-milan"
      },
      {
        "name": "v-anpasi",
        "url": "https://github.com/v-anpasi"
      },
      {
        "name": "jierong",
        "url": "https://github.com/jierong"
      },
      {
        "name": "Eilon",
        "url": "https://github.com/Eilon"
      },
      {
        "name": "danroth27",
        "url": "https://github.com/danroth27"
      }
    ],
    "openSourceFeedbackIssueUrl": "https://github.com/dotnet/aspnetcore.docs/issues/new?template=customer-feedback.yml",
    "openSourceFeedbackIssueTitle": "",
    "openSourceFeedbackIssueLabels": "Source - Docs.ms,:watch: Not Triaged"
  },
  "functions": {}
};;
	</script>

			<!-- base scripts, msdocs global should be before this -->
			<script src="https://learn.microsoft.com/static/assets/0.4.03137.7032-e8b681c0/scripts/en-us/index-docs.js"></script>
			

			<!-- json-ld -->
			
		</head>
	
			<body
				id="body"
				data-bi-name="body"
				class="layout-body "
				lang="en-us"
				dir="ltr"
			>
				<header class="layout-body-header">
		<div class="header-holder has-default-focus">
			
		<a
			href="#main"
			
			style="z-index: 1070"
			class="outline-color-text visually-hidden-until-focused position-fixed inner-focus focus-visible top-0 left-0 right-0 padding-xs text-align-center background-color-body"
			
		>
			Skip to main content
		</a>
	
		<a
			href="#"
			data-skip-to-ask-learn
			style="z-index: 1070"
			class="outline-color-text visually-hidden-until-focused position-fixed inner-focus focus-visible top-0 left-0 right-0 padding-xs text-align-center background-color-body"
			hidden
		>
			Skip to Ask Learn chat experience
		</a>
	

			<div hidden id="cookie-consent-holder" data-test-id="cookie-consent-container"></div>
			<!-- Unsupported browser warning -->
			<div
				id="unsupported-browser"
				style="background-color: white; color: black; padding: 16px; border-bottom: 1px solid grey;"
				hidden
			>
				<div style="max-width: 800px; margin: 0 auto;">
					<p style="font-size: 24px">This browser is no longer supported.</p>
					<p style="font-size: 16px; margin-top: 16px;">
						Upgrade to Microsoft Edge to take advantage of the latest features, security updates, and technical support.
					</p>
					<div style="margin-top: 12px;">
						<a
							href="https://go.microsoft.com/fwlink/p/?LinkID=2092881"
							style="background-color: #0078d4; border: 1px solid #0078d4; color: white; padding: 6px 12px; border-radius: 2px; display: inline-block;"
						>
							Download Microsoft Edge
						</a>
						<a
							href="https://learn.microsoft.com/en-us/lifecycle/faq/internet-explorer-microsoft-edge"
							style="background-color: white; padding: 6px 12px; border: 1px solid #505050; color: #171717; border-radius: 2px; display: inline-block;"
						>
							More info about Internet Explorer and Microsoft Edge
						</a>
					</div>
				</div>
			</div>
			<!-- site header -->
			<header
				id="ms--site-header"
				data-test-id="site-header-wrapper"
				role="banner"
				itemscope="itemscope"
				itemtype="http://schema.org/Organization"
			>
				<div
					id="ms--mobile-nav"
					class="site-header display-none-tablet padding-inline-none gap-none"
					data-bi-name="mobile-header"
					data-test-id="mobile-header"
				></div>
				<div
					id="ms--primary-nav"
					class="site-header display-none display-flex-tablet"
					data-bi-name="L1-header"
					data-test-id="primary-header"
				></div>
				<div
					id="ms--secondary-nav"
					class="site-header display-none display-flex-tablet"
					data-bi-name="L2-header"
					data-test-id="secondary-header"
				></div>
			</header>
			
		<!-- banner -->
		<div data-banner>
			<div id="disclaimer-holder"></div>
			
		</div>
		<!-- banner end -->
	
		</div>
	</header>
				 <section
					id="layout-body-menu"
					class="layout-body-menu display-flex"
					data-bi-name="menu"
			  >
					<div
		id="left-container"
		class="left-container display-none display-block-tablet padding-inline-sm padding-bottom-sm width-full"
	>
		<nav
			id="affixed-left-container"
			class="margin-top-sm-tablet position-sticky display-flex flex-direction-column"
			aria-label="Primary"
		></nav>
	</div>
			  </section>

				<main
					id="main"
					role="main"
					class="layout-body-main "
					data-bi-name="content"
					lang="en-us"
					dir="ltr"
				>
					
			<div
		id="ms--content-header"
		class="content-header default-focus border-bottom-none"
		data-bi-name="content-header"
	>
		<div class="content-header-controls margin-xxs margin-inline-sm-tablet">
			<button
				type="button"
				class="contents-button button button-sm margin-right-xxs"
				data-bi-name="contents-expand"
				aria-haspopup="true"
				data-contents-button
			>
				<span class="icon" aria-hidden="true"><span class="docon docon-menu"></span></span>
				<span class="contents-expand-title"> Table of contents </span>
			</button>
			<button
				type="button"
				class="ap-collapse-behavior ap-expanded button button-sm"
				data-bi-name="ap-collapse"
				aria-controls="action-panel"
			>
				<span class="icon" aria-hidden="true"><span class="docon docon-exit-mode"></span></span>
				<span>Exit editor mode</span>
			</button>
		</div>
	</div>
			<div data-main-column class="padding-sm padding-top-none padding-top-sm-tablet">
				<div>
					
		<div id="article-header" class="background-color-body margin-bottom-xs display-none-print">
			<div class="display-flex align-items-center justify-content-space-between">
				
		<details
			id="article-header-breadcrumbs-overflow-popover"
			class="popover"
			data-for="article-header-breadcrumbs"
		>
			<summary
				class="button button-clear button-primary button-sm inner-focus"
				aria-label="All breadcrumbs"
			>
				<span class="icon">
					<span class="docon docon-more"></span>
				</span>
			</summary>
			<div id="article-header-breadcrumbs-overflow" class="popover-content padding-none"></div>
		</details>

		<bread-crumbs
			id="article-header-breadcrumbs"
			data-test-id="article-header-breadcrumbs"
			class="overflow-hidden flex-grow-1 margin-right-sm margin-right-md-tablet margin-right-lg-desktop margin-left-negative-xxs padding-left-xxs"
		></bread-crumbs>
	 
		<div
			id="article-header-page-actions"
			class="opacity-none margin-left-auto display-flex flex-wrap-no-wrap align-items-stretch"
		>
			
		<button
			class="button button-sm border-none inner-focus display-none-tablet flex-shrink-0 "
			data-bi-name="ask-learn-assistant-entry"
			data-test-id="ask-learn-assistant-modal-entry-mobile"
			data-ask-learn-modal-entry
			type="button"
			style="min-width: max-content;"
			aria-expanded="false"
			aria-label="Ask Learn"
			hidden
		>
			<span class="icon font-size-lg" aria-hidden="true">
				<span class="docon docon-chat-sparkle-fill gradient-ask-learn-logo"></span>
			</span>
		</button>
		<button
			class="button button-sm display-none display-inline-flex-tablet display-none-desktop flex-shrink-0 margin-right-xxs border-color-ask-learn "
			data-bi-name="ask-learn-assistant-entry"
			data-test-id="ask-learn-assistant-modal-entry-tablet"
			data-ask-learn-modal-entry
			type="button"
			style="min-width: max-content;"
			aria-expanded="false"
			hidden
		>
			<span class="icon font-size-lg" aria-hidden="true">
				<span class="docon docon-chat-sparkle-fill gradient-ask-learn-logo"></span>
			</span>
			<span>Ask Learn</span>
		</button>
		<button
			class="button button-sm display-none flex-shrink-0 display-inline-flex-desktop margin-right-xxs	border-color-ask-learn "
			data-bi-name="ask-learn-assistant-entry"
			data-test-id="ask-learn-assistant-flyout-entry"
			data-ask-learn-flyout-entry
			data-flyout-button="toggle"
			type="button"
			style="min-width: max-content;"
			aria-expanded="false"
			aria-controls="ask-learn-flyout"
			hidden
		>
			<span class="icon font-size-lg" aria-hidden="true">
				<span class="docon docon-chat-sparkle-fill gradient-ask-learn-logo"></span>
			</span>
			<span>Ask Learn</span>
		</button>
	 
		<button
			type="button"
			id="ms--focus-mode-button"
			data-focus-mode
			data-bi-name="focus-mode-entry"
			class="button button-sm flex-shrink-0 margin-right-xxs display-none display-inline-flex-desktop"
		>
			<span class="icon font-size-lg" aria-hidden="true">
				<span class="docon docon-glasses"></span>
			</span>
			<span>Focus mode</span>
		</button>
	 

			<details class="popover popover-right" id="article-header-page-actions-overflow">
				<summary
					class="justify-content-flex-start button button-clear button-sm button-primary inner-focus"
					aria-label="More actions"
					title="More actions"
				>
					<span class="icon" aria-hidden="true">
						<span class="docon docon-more-vertical"></span>
					</span>
				</summary>
				<div class="popover-content">
					
		<button
			data-page-action-item="overflow-mobile"
			type="button"
			class="button-block button-sm has-inner-focus button button-clear display-none-tablet justify-content-flex-start text-align-left"
			data-bi-name="contents-expand"
			data-contents-button
			data-popover-close
		>
			<span class="icon">
				<span class="docon docon-editor-list-bullet" aria-hidden="true"></span>
			</span>
			<span class="contents-expand-title">Table of contents</span>
		</button>
	 
		<a
			id="lang-link-overflow"
			class="button-sm has-inner-focus button button-clear button-block justify-content-flex-start text-align-left"
			data-bi-name="language-toggle"
			data-page-action-item="overflow-all"
			data-check-hidden="true"
			data-read-in-link
			href="#"
			hidden
		>
			<span class="icon" aria-hidden="true" data-read-in-link-icon>
				<span class="docon docon-locale-globe"></span>
			</span>
			<span data-read-in-link-text>Read in English</span>
		</a>
	 
		<button
			type="button"
			class="collection button button-clear button-sm button-block justify-content-flex-start text-align-left inner-focus"
			data-list-type="collection"
			data-bi-name="collection"
			data-page-action-item="overflow-all"
			data-check-hidden="true"
			data-popover-close
		>
			<span class="icon" aria-hidden="true">
				<span class="docon docon-circle-addition"></span>
			</span>
			<span class="collection-status">Add</span>
		</button>
	
					
		<button
			type="button"
			class="collection button button-block button-clear button-sm justify-content-flex-start text-align-left inner-focus"
			data-list-type="plan"
			data-bi-name="plan"
			data-page-action-item="overflow-all"
			data-check-hidden="true"
			data-popover-close
			hidden
		>
			<span class="icon" aria-hidden="true">
				<span class="docon docon-circle-addition"></span>
			</span>
			<span class="plan-status">Add to plan</span>
		</button>
	  
		<a
			data-contenteditbtn
			class="button button-clear button-block button-sm inner-focus justify-content-flex-start text-align-left text-decoration-none"
			data-bi-name="edit"
			
			href="https://github.com/dotnet/AspNetCore.Docs/blob/main/aspnetcore/mvc/controllers/routing.md"
			data-original_content_git_url="https://github.com/dotnet/AspNetCore.Docs/blob/live/aspnetcore/mvc/controllers/routing.md"
			data-original_content_git_url_template="{repo}/blob/{branch}/aspnetcore/mvc/controllers/routing.md"
			data-pr_repo=""
			data-pr_branch=""
		>
			<span class="icon" aria-hidden="true">
				<span class="docon docon-edit-outline"></span>
			</span>
			<span>Edit</span>
		</a>
	
					
		<hr class="margin-block-xxs" />
		<h4 class="font-size-sm padding-left-xxs">Share via</h4>
		
					<a
						class="button button-clear button-sm inner-focus button-block justify-content-flex-start text-align-left text-decoration-none share-facebook"
						data-bi-name="facebook"
						data-page-action-item="overflow-all"
						href="#"
					>
						<span class="icon color-primary" aria-hidden="true">
							<span class="docon docon-facebook-share"></span>
						</span>
						<span>Facebook</span>
					</a>

					<a
						href="#"
						class="button button-clear button-sm inner-focus button-block justify-content-flex-start text-align-left text-decoration-none share-twitter"
						data-bi-name="twitter"
						data-page-action-item="overflow-all"
					>
						<span class="icon color-text" aria-hidden="true">
							<span class="docon docon-xlogo-share"></span>
						</span>
						<span>x.com</span>
					</a>

					<a
						href="#"
						class="button button-clear button-sm inner-focus button-block justify-content-flex-start text-align-left text-decoration-none share-linkedin"
						data-bi-name="linkedin"
						data-page-action-item="overflow-all"
					>
						<span class="icon color-primary" aria-hidden="true">
							<span class="docon docon-linked-in-logo"></span>
						</span>
						<span>LinkedIn</span>
					</a>
					<a
						href="#"
						class="button button-clear button-sm inner-focus button-block justify-content-flex-start text-align-left text-decoration-none share-email"
						data-bi-name="email"
						data-page-action-item="overflow-all"
					>
						<span class="icon color-primary" aria-hidden="true">
							<span class="docon docon-mail-message"></span>
						</span>
						<span>Email</span>
					</a>
			  
	 
		<hr class="margin-block-xxs" />
		<button
			class="button button-block button-clear button-sm justify-content-flex-start text-align-left inner-focus"
			type="button"
			data-bi-name="print"
			data-page-action-item="overflow-all"
			data-popover-close
			data-print-page
			data-check-hidden="true"
		>
			<span class="icon color-primary" aria-hidden="true">
				<span class="docon docon-print"></span>
			</span>
			<span>Print</span>
		</button>
	
				</div>
			</details>
		</div>
	
			</div>
		</div>
	
					<!-- azure disclaimer -->
					
					<!-- privateUnauthorizedTemplate is hidden by default -->
					
		<div unauthorized-private-section data-bi-name="permission-content-unauthorized-private" hidden>
			<hr class="hr margin-top-xs margin-bottom-sm" />
			<div class="notification notification-info">
				<div class="notification-content">
					<p class="margin-top-none notification-title">
						<span class="icon">
							<span class="docon docon-exclamation-circle-solid" aria-hidden="true"></span>
						</span>
						<span>Note</span>
					</p>
					<p class="margin-top-none authentication-determined not-authenticated">
						Access to this page requires authorization. You can try <a class="docs-sign-in" href="#" data-bi-name="permission-content-sign-in">signing in</a> or <a  class="docs-change-directory" data-bi-name="permisson-content-change-directory">changing directories</a>.
					</p>
					<p class="margin-top-none authentication-determined authenticated">
						Access to this page requires authorization. You can try <a class="docs-change-directory" data-bi-name="permisson-content-change-directory">changing directories</a>.
					</p>
				</div>
			</div>
		</div>
	
					<div class="content"><h1 id="routing-to-controller-actions-in-aspnet-core">Routing to controller actions in ASP.NET Core</h1></div>
					
		<div
			id="article-metadata"
			class="page-metadata-container display-flex gap-xxs justify-content-space-between align-items-center flex-wrap-wrap"
		>
			
		<div class="margin-block-xxs">
			<ul class="metadata page-metadata" data-bi-name="page info" lang="en-us" dir="ltr">
				  <li class="visibility-hidden-visual-diff">
			<local-time
				format="twoDigitNumeric"
				datetime="2024-06-17T18:38:00.000Z"
				data-article-date-source="calculated"
				class="is-invisible"
			>
				2024-06-17
			</local-time>
		</li>  
			</ul>
		</div>
	 
				<div
					id="user-feedback"
					class="margin-block-xxs display-none display-none-print"
					hidden
					data-hide-on-archived
				>
					
		<button
			id="user-feedback-button"
			data-test-id="conceptual-feedback-button"
			class="button button-sm button-clear button-primary display-none"
			type="button"
			data-bi-name="user-feedback-button"
			data-user-feedback-button
			hidden
		>
			<span class="icon" aria-hidden="true">
				<span class="docon docon-like"></span>
			</span>
			<span>Feedback</span>
		</button>
	
				</div>
		  
		</div>
	 
		<nav
			id="center-doc-outline"
			class="doc-outline is-hidden-desktop display-none-print margin-bottom-sm"
			data-bi-name="intopic toc"
			aria-label="In this article"
		>
			<h2 id="ms--in-this-article" class="title is-6 margin-block-xs">
				In this article
			</h2>
		</nav>
	
					<div class="content"><p>By <a href="https://github.com/rynowak" data-linktype="external">Ryan Nowak</a>, <a href="https://twitter.com/serpent5" data-linktype="external">Kirk Larkin</a>, and <a href="https://twitter.com/RickAndMSFT" data-linktype="external">Rick Anderson</a></p>
<div data-moniker="aspnetcore-1.0 aspnetcore-1.1 aspnetcore-2.0 aspnetcore-2.1 aspnetcore-2.2 aspnetcore-3.0 aspnetcore-3.1 aspnetcore-5.0 aspnetcore-6.0 aspnetcore-7.0 aspnetcore-8.0">
<div class="NOTE">
<p>Note</p>
<p>This isn't the latest version of this article. For the current release, see the <a href="https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/routing?view=aspnetcore-9.0&amp;preserve-view=true" data-linktype="relative-path">.NET 9 version of this article</a>.</p>
</div>
</div>
<div data-moniker="aspnetcore-2.0 aspnetcore-3.0 aspnetcore-3.1 aspnetcore-5.0 aspnetcore-7.0">
<div class="WARNING">
<p>Warning</p>
<p>This version of ASP.NET Core is no longer supported. For more information, see the <a href="https://dotnet.microsoft.com/platform/support/policy/dotnet-core" data-linktype="external">.NET and .NET Core Support Policy</a>. For the current release, see the <a href="https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/routing?view=aspnetcore-9.0&amp;preserve-view=true" data-linktype="relative-path">.NET 9 version of this article</a>.</p>
</div>
</div>
<div data-moniker="aspnetcore-10.0">
<div class="IMPORTANT">
<p>Important</p>
<p>This information relates to a pre-release product that may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.</p>
<p>For the current release, see the <a href="https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/routing?view=aspnetcore-9.0&amp;preserve-view=true" data-linktype="relative-path">.NET 9 version of this article</a>.</p>
</div>
</div>
<!--
Include either this file or 'not-latest-version-without-not-supported-content.md' at the top 
of articles.

'not-latest-version.md' (this file): Includes not-supported content.
'not-latest-version-without-not-supported-content.md': Doesn't include not-supported content.

Use this file in articles that target >=7.0. For articles that target >=8.0 prior to 9.0
reaching EOL, 'not-latest-version-without-not-supported-content.md' must be used to avoid
a zone/file moniker range mismatch error.

When a new version is released, it might be necessary to temporarily comment out the current 
version moniker range section until the new moniker is created.

Markdown to include this file:

[!INCLUDE[](~/includes/not-latest-version.md)]
-->
<div data-moniker="aspnetcore-10.0 aspnetcore-6.0 aspnetcore-7.0 aspnetcore-8.0 aspnetcore-9.0">
<p>ASP.NET Core controllers use the Routing <a href="../../fundamentals/middleware/index553c.html?view=aspnetcore-9.0" data-linktype="relative-path">middleware</a> to match the URLs of incoming requests and map them to <a href="#action" data-linktype="self-bookmark">actions</a>.  Route templates:</p>
<ul>
<li>Are defined at startup in <code>Program.cs</code> or in attributes.</li>
<li>Describe how URL paths are matched to <a href="#action" data-linktype="self-bookmark">actions</a>.</li>
<li>Are used to generate URLs for links. The generated links are typically returned in responses.</li>
</ul>
<p>Actions are either <a href="#cr6" data-linktype="self-bookmark">conventionally-routed</a> or <a href="#ar6" data-linktype="self-bookmark">attribute-routed</a>. Placing a route on the controller or <a href="#action" data-linktype="self-bookmark">action</a> makes it attribute-routed. See <a href="#routing-mixed-ref-label" data-linktype="self-bookmark">Mixed routing</a> for more information.</p>
<p>This document:</p>
<ul>
<li>Explains the interactions between MVC and routing:
<ul>
<li>How typical MVC apps make use of routing features.</li>
<li>Covers both:
<ul>
<li><a href="#cr6" data-linktype="self-bookmark">Conventional routing</a> typically used with controllers and views.</li>
<li><em>Attribute routing</em> used with REST APIs. If you're primarily interested in routing for REST APIs, jump to the <a href="#ar6" data-linktype="self-bookmark">Attribute routing for REST APIs</a> section.</li>
</ul>
</li>
<li>See <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-9.0" data-linktype="relative-path">Routing</a> for advanced routing details.</li>
</ul>
</li>
<li>Refers to the default routing system called endpoint routing. It's possible to use controllers with the previous version of routing for compatibility purposes. See the <a href="https://learn.microsoft.com/en-us/aspnet/core/migration/22-to-30?view=aspnetcore-9.0" data-linktype="relative-path">2.2-3.0 migration guide</a> for instructions.</li>
</ul>
<p><a name="cr6"></a></p>
<h2 id="set-up-conventional-route">Set up conventional route</h2>
<p>The ASP.NET Core MVC template generates <a href="#crd6" data-linktype="self-bookmark">conventional routing</a> code similar to the following:</p>
<pre><code class="lang-csharp" highlight-lines="20-22">var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllersWithViews();

var app = builder.Build();

if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Home/Error");
    app.UseHsts();
}

app.UseHttpsRedirection();
app.UseStaticFiles();

app.UseRouting();

app.UseAuthorization();

app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");

app.Run();
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapcontrollerroute" class="no-loc" data-linktype="absolute-path">MapControllerRoute</a> is used to create a single route. The single route is named <code>default</code> route. Most apps with controllers and views use a route template similar to the <code>default</code> route. REST APIs should use <a href="#ar6" data-linktype="self-bookmark">attribute routing</a>.</p>
<pre><code class="lang-csharp">app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");
</code></pre>
<p>The route template <code>"{controller=Home}/{action=Index}/{id?}"</code>:</p>
<ul>
<li><p>Matches a URL path like <code>/Products/Details/5</code></p>
</li>
<li><p>Extracts the route values <code>{ controller = Products, action = Details, id = 5 }</code> by tokenizing the path. The extraction of route values results in a match if the app has a controller named <code>ProductsController</code> and a <code>Details</code> action:</p>
<pre><code class="lang-csharp">public class ProductsController : Controller
{
    public IActionResult Details(int id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
</code></pre><p><a href="https://github.com/Rick-Anderson/RouteInfo/blob/master/Microsoft.Docs.Samples.RouteInfo/ControllerContextExtensions.cs" data-linktype="external">MyDisplayRouteInfo</a> is provided by the <a href="https://www.nuget.org/packages/Rick.Docs.Samples.RouteInfo" data-linktype="external">Rick.Docs.Samples.RouteInfo</a> NuGet package and displays route information.</p>
</li>
<li><p><code>/Products/Details/5</code> model binds the value of <code>id = 5</code> to set the <code>id</code> parameter to <code>5</code>. See <a href="../models/model-binding553c.html?view=aspnetcore-9.0" data-linktype="relative-path">Model Binding</a> for more details.</p>
</li>
<li><p><code>{controller=Home}</code> defines <code>Home</code> as the default <code>controller</code>.</p>
</li>
<li><p><code>{action=Index}</code> defines <code>Index</code> as the default <code>action</code>.</p>
</li>
<li><p>The <code>?</code> character in <code>{id?}</code> defines <code>id</code> as optional.</p>
<ul>
<li>Default and optional route parameters don't need to be present in the URL path for a match. See <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-9.0#route-template-reference" data-linktype="relative-path">Route Template Reference</a> for a detailed description of route template syntax.</li>
</ul>
</li>
<li><p>Matches the URL path <code>/</code>.</p>
</li>
<li><p>Produces the route values <code>{ controller = Home, action = Index }</code>.</p>
</li>
</ul>
<p>The values for <code>controller</code> and <code>action</code> make use of the default values. <code>id</code> doesn't produce a value since there's no corresponding segment in the URL path. <code>/</code> only matches if there exists a <code>HomeController</code> and <code>Index</code> action:</p>
<pre><code class="lang-csharp">public class HomeController : Controller
{
    public IActionResult Index() { ... }
}
</code></pre>
<p>Using the preceding controller definition and route template, the <code>HomeController.Index</code> action is run for the following URL paths:</p>
<ul>
<li><code>/Home/Index/17</code></li>
<li><code>/Home/Index</code></li>
<li><code>/Home</code></li>
<li><code>/</code></li>
</ul>
<p>The URL path <code>/</code> uses the route template default <code>Home</code> controllers and <code>Index</code> action. The URL path <code>/Home</code> uses the route template default <code>Index</code> action.</p>
<p>The convenience method <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapdefaultcontrollerroute" class="no-loc" data-linktype="absolute-path">MapDefaultControllerRoute</a>:</p>
<pre><code class="lang-csharp">app.MapDefaultControllerRoute();
</code></pre>
<p>Replaces:</p>
<pre><code class="lang-csharp">app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");
</code></pre>
<div class="IMPORTANT">
<p>Important</p>
<p>Routing is configured using the <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.endpointroutingapplicationbuilderextensions.userouting" class="no-loc" data-linktype="absolute-path">UseRouting</a> and <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.endpointroutingapplicationbuilderextensions.useendpoints" class="no-loc" data-linktype="absolute-path">UseEndpoints</a> middleware. To use controllers:</p>
<ul>
<li>Call <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapcontrollers" class="no-loc" data-linktype="absolute-path">MapControllers</a> to map <a href="#ar6" data-linktype="self-bookmark">attribute routed</a> controllers.</li>
<li>Call <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapcontrollerroute" class="no-loc" data-linktype="absolute-path">MapControllerRoute</a> or <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapareacontrollerroute" class="no-loc" data-linktype="absolute-path">MapAreaControllerRoute</a>, to map both <a href="#cr6" data-linktype="self-bookmark">conventionally routed</a> controllers and <a href="#ar6" data-linktype="self-bookmark">attribute routed</a> controllers.</li>
</ul>
<p>Apps typically don't need to call <code>UseRouting</code> or <code>UseEndpoints</code>. <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.webapplicationbuilder" class="no-loc" data-linktype="absolute-path">WebApplicationBuilder</a> configures a middleware pipeline that wraps middleware added in <code>Program.cs</code> with <code>UseRouting</code> and <code>UseEndpoints</code>. For more information, see <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-9.0" data-linktype="relative-path">Routing in ASP.NET Core</a>.</p>
</div>
<p><a name="routing-conventional-ref-label"></a>
<a name="crd6"></a></p>
<h2 id="conventional-routing">Conventional routing</h2>
<p>Conventional routing is used with controllers and views. The <code>default</code> route:</p>
<pre><code class="lang-csharp">app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");
</code></pre>
<p>The preceding is an example of a <em>conventional route</em>. It's called <em>conventional routing</em> because it establishes a <em>convention</em> for URL paths:</p>
<ul>
<li>The first path segment, <code>{controller=Home}</code>, maps to the controller name.</li>
<li>The second segment, <code>{action=Index}</code>, maps to the <a href="#action" data-linktype="self-bookmark">action</a> name.</li>
<li>The third segment, <code>{id?}</code> is used for an optional <code>id</code>. The <code>?</code> in <code>{id?}</code> makes it optional. <code>id</code> is used to map to a model entity.</li>
</ul>
<p>Using this <code>default</code> route, the URL path:</p>
<ul>
<li><code>/Products/List</code> maps to the <code>ProductsController.List</code> action.</li>
<li><code>/Blog/Article/17</code> maps to <code>BlogController.Article</code> and typically model binds the <code>id</code> parameter to 17.</li>
</ul>
<p>This mapping:</p>
<ul>
<li>Is based on the controller and <a href="#action" data-linktype="self-bookmark">action</a> names <strong>only</strong>.</li>
<li>Isn't based on namespaces, source file locations, or method parameters.</li>
</ul>
<p>Using conventional routing with the default route allows creating the app without having to come up with a new URL pattern for each action. For an app with <a href="https://wikipedia.org/wiki/Create,_read,_update_and_delete" data-linktype="external">CRUD</a> style actions, having consistency for the URLs across controllers:</p>
<ul>
<li>Helps simplify the code.</li>
<li>Makes the UI more predictable.</li>
</ul>
<div class="WARNING">
<p>Warning</p>
<p>The <code>id</code> in the preceding code is defined as optional by the route template. Actions can execute without the optional ID provided as part of the URL. Generally, when <code>id</code> is omitted from the URL:</p>
<ul>
<li><code>id</code> is set to <code>0</code> by model binding.</li>
<li>No entity is found in the database matching <code>id == 0</code>.</li>
</ul>
<p><a href="#ar6" data-linktype="self-bookmark">Attribute routing</a> provides fine-grained control to make the ID required for some actions and not for others. By convention, the documentation includes optional parameters like <code>id</code> when they're likely to appear in correct usage.</p>
</div>
<p>Most apps should choose a basic and descriptive routing scheme so that URLs are readable and meaningful. The default conventional route <code>{controller=Home}/{action=Index}/{id?}</code>:</p>
<ul>
<li>Supports a basic and descriptive routing scheme.</li>
<li>Is a useful starting point for UI-based apps.</li>
<li>Is the only route template needed for many web UI apps. For larger web UI apps, another route using <a href="#areas" data-linktype="self-bookmark">Areas</a> is frequently all that's needed.</li>
</ul>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapcontrollerroute" class="no-loc" data-linktype="absolute-path">MapControllerRoute</a> and <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.mvcarearoutebuilderextensions.maparearoute" class="no-loc" data-linktype="absolute-path">MapAreaRoute</a> :</p>
<ul>
<li>Automatically assign an <strong>order</strong> value to their endpoints based on the order they are invoked.</li>
</ul>
<p>Endpoint routing in ASP.NET Core:</p>
<ul>
<li>Doesn't have a concept of routes.</li>
<li>Doesn't provide ordering guarantees for the execution of extensibility,  all endpoints are processed at once.</li>
</ul>
<p>Enable <a href="../../fundamentals/logging/index553c.html?view=aspnetcore-9.0" data-linktype="relative-path">Logging</a> to see how the built-in routing implementations, such as <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.route" class="no-loc" data-linktype="absolute-path">Route</a>, match requests.</p>
<p><a href="#ar6" data-linktype="self-bookmark">Attribute routing</a> is explained later in this document.</p>
<p><a name="mr6"></a></p>
<h3 id="multiple-conventional-routes">Multiple conventional routes</h3>
<p>Multiple <a href="#cr6" data-linktype="self-bookmark">conventional routes</a> can be configured by adding more calls to <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapcontrollerroute" class="no-loc" data-linktype="absolute-path">MapControllerRoute</a> and <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapareacontrollerroute" class="no-loc" data-linktype="absolute-path">MapAreaControllerRoute</a>. Doing so allows defining multiple conventions, or to adding conventional routes that are dedicated to a specific <a href="#action" data-linktype="self-bookmark">action</a>, such as:</p>
<pre><code class="lang-csharp">app.MapControllerRoute(name: "blog",
                pattern: "blog/{*article}",
                defaults: new { controller = "Blog", action = "Article" });
app.MapControllerRoute(name: "default",
               pattern: "{controller=Home}/{action=Index}/{id?}");

</code></pre>
<p><a name="dcr"></a></p>
<p>The <code>blog</code> route in the preceding code is a <strong>dedicated conventional route</strong>. It's called a dedicated conventional route because:</p>
<ul>
<li>It uses <a href="#cr6" data-linktype="self-bookmark">conventional routing</a>.</li>
<li>It's dedicated to a specific <a href="#action" data-linktype="self-bookmark">action</a>.</li>
</ul>
<p>Because <code>controller</code> and <code>action</code> don't appear in the route template <code>"blog/{*article}"</code> as parameters:</p>
<ul>
<li>They can only have the default values <code>{ controller = "Blog", action = "Article" }</code>.</li>
<li>This route always maps to the action <code>BlogController.Article</code>.</li>
</ul>
<p><code>/Blog</code>, <code>/Blog/Article</code>, and <code>/Blog/{any-string}</code> are the only URL paths that match the blog route.</p>
<p>The preceding example:</p>
<ul>
<li><code>blog</code> route has a higher priority for matches than the <code>default</code> route because it is added first.</li>
<li>Is an example of <a href="https://developer.mozilla.org/docs/Glossary/Slug" data-linktype="external">Slug</a> style routing where it's typical to have an article name as part of the URL.</li>
</ul>
<div class="WARNING">
<p>Warning</p>
<p>In ASP.NET Core, routing doesn't:</p>
<ul>
<li>Define a concept called a <em>route</em>. <code>UseRouting</code> adds route matching to the middleware pipeline. The <code>UseRouting</code> middleware looks at the set of endpoints defined in the app, and selects the best endpoint match based on the request.</li>
<li>Provide guarantees about the execution order of extensibility like <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouteconstraint" class="no-loc" data-linktype="absolute-path">IRouteConstraint</a> or <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.actionconstraints.iactionconstraint" class="no-loc" data-linktype="absolute-path">IActionConstraint</a>.</li>
</ul>
<p>See <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-9.0" data-linktype="relative-path">Routing</a> for reference material on routing.</p>
</div>
<p><a name="cro6"></a></p>
<h3 id="conventional-routing-order">Conventional routing order</h3>
<p>Conventional routing only matches a combination of action and controller that are defined by the app. This is intended to simplify cases where conventional routes overlap.
Adding routes using <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapcontrollerroute" class="no-loc" data-linktype="absolute-path">MapControllerRoute</a>, <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapdefaultcontrollerroute" class="no-loc" data-linktype="absolute-path">MapDefaultControllerRoute</a>, and <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapareacontrollerroute" class="no-loc" data-linktype="absolute-path">MapAreaControllerRoute</a> automatically assign an order value to their endpoints based on the order they are invoked. Matches from a route that appears earlier have a higher priority. Conventional routing is order-dependent. In general, routes with areas should be placed earlier as they're more specific than routes without an area. <a href="#dcr" data-linktype="self-bookmark">Dedicated conventional routes</a> with catch-all route parameters like <code>{*article}</code> can make a route too <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-9.0#greedy" data-linktype="relative-path">greedy</a>, meaning that it matches URLs that you intended to be matched by other routes. Put the greedy routes later in the route table to prevent greedy matches.</p>
<div data-moniker="aspnetcore-3.0 aspnetcore-3.1">
<div class="WARNING">
<p>Warning</p>
<p>A <strong>catch-all</strong> parameter may match routes incorrectly due to a <a href="https://github.com/dotnet/aspnetcore/issues/18677" data-linktype="external">bug</a> in routing. Apps impacted by this bug have the following characteristics:</p>
<ul>
<li>A catch-all route, for example, <code>{**slug}"</code></li>
<li>The catch-all route fails to match requests it should match.</li>
<li>Removing other routes makes catch-all route start working.</li>
</ul>
<p>See GitHub bugs <a href="https://github.com/dotnet/aspnetcore/issues/18677" data-linktype="external">18677</a> and <a href="https://github.com/dotnet/aspnetcore/issues/16579" data-linktype="external">16579</a> for example cases that hit this bug.</p>
<p>An opt-in fix for this bug is contained in <a href="https://dotnet.microsoft.com/download/dotnet-core/3.1" data-linktype="external">.NET Core 3.1.301 or later SDK</a>. The following code sets an internal switch that fixes this bug:</p>
<pre><code class="lang-csharp">public static void Main(string[] args)
{
   AppContext.SetSwitch("Microsoft.AspNetCore.Routing.UseCorrectCatchAllBehavior", 
                         true);
   CreateHostBuilder(args).Build().Run();
}
// Remaining code removed for brevity.
</code></pre>
</div>
</div>
<p><a name="best"></a></p>
<h3 id="resolving-ambiguous-actions">Resolving ambiguous actions</h3>
<p>When two endpoints match through routing, routing must do one of the following:</p>
<ul>
<li>Choose the best candidate.</li>
<li>Throw an exception.</li>
</ul>
<p>For example:</p>
<pre><code class="lang-csharp">public class Products33Controller : Controller
{
    public IActionResult Edit(int id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }

    [HttpPost]
    public IActionResult Edit(int id, Product product)
    {
        return ControllerContext.MyDisplayRouteInfo(id, product.name);
    }
}
</code></pre>
<p>The preceding controller defines two actions that match:</p>
<ul>
<li>The URL path <code>/Products33/Edit/17</code></li>
<li>Route data <code>{ controller = Products33, action = Edit, id = 17 }</code>.</li>
</ul>
<p>This is a typical pattern for MVC controllers:</p>
<ul>
<li><code>Edit(int)</code> displays a form to edit a product.</li>
<li><code>Edit(int, Product)</code> processes  the posted form.</li>
</ul>
<p>To resolve the correct route:</p>
<ul>
<li><code>Edit(int, Product)</code> is selected when the request is an HTTP <code>POST</code>.</li>
<li><code>Edit(int)</code> is selected when the <a href="#verb" data-linktype="self-bookmark">HTTP verb</a> is anything else. <code>Edit(int)</code> is generally called via <code>GET</code>.</li>
</ul>
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.httppostattribute" class="no-loc" data-linktype="absolute-path">HttpPostAttribute</a>, <code>[HttpPost]</code>, is provided to routing so that it can choose based on the HTTP method of the request. The <code>HttpPostAttribute</code> makes <code>Edit(int, Product)</code> a better match than <code>Edit(int)</code>.</p>
<p>It's important to understand the role of attributes like <code>HttpPostAttribute</code>. Similar attributes are defined for other <a href="#verb" data-linktype="self-bookmark">HTTP verbs</a>. In <a href="#cr6" data-linktype="self-bookmark">conventional routing</a>, it's common for actions to use the same action name when they're part of a show form, submit form workflow. For example, see <a href="https://learn.microsoft.com/en-us/aspnet/core/tutorials/first-mvc-app/controller-methods-views?view=aspnetcore-9.0#get-post" data-linktype="relative-path">Examine the two Edit action methods</a>.</p>
<p>If routing can't choose a best candidate, an <a href="https://learn.microsoft.com/en-us/dotnet/api/system.reflection.ambiguousmatchexception" class="no-loc" data-linktype="absolute-path">AmbiguousMatchException</a> is thrown, listing the multiple matched endpoints.</p>
<p><a name="routing-route-name-ref-label"></a></p>
<h3 id="conventional-route-names">Conventional route names</h3>
<p>The strings  <code>"blog"</code> and <code>"default"</code> in the following examples are conventional route names:</p>
<pre><code class="lang-csharp">app.MapControllerRoute(name: "blog",
                pattern: "blog/{*article}",
                defaults: new { controller = "Blog", action = "Article" });
app.MapControllerRoute(name: "default",
               pattern: "{controller=Home}/{action=Index}/{id?}");

</code></pre>
<p>The route names give the route a logical name. The named route can be used for URL generation. Using a named route simplifies URL creation when the ordering of routes could make URL generation complicated. Route names must be unique application wide.</p>
<p>Route names:</p>
<ul>
<li>Have no impact on URL matching or handling of requests.</li>
<li>Are used only for URL generation.</li>
</ul>
<p>The route name concept is represented in routing as <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.iendpointnamemetadata" data-linktype="absolute-path">IEndpointNameMetadata</a>. The terms <strong>route name</strong> and <strong>endpoint name</strong>:</p>
<ul>
<li>Are interchangeable.</li>
<li>Which one is used in documentation and code depends on the API being described.</li>
</ul>
<p><a name="attribute-routing-ref-label"></a>
<a name="ar6"></a></p>
<h2 id="attribute-routing-for-rest-apis">Attribute routing for REST APIs</h2>
<p>REST APIs should use attribute routing to model the app's functionality as a set of resources where operations are represented by <a href="#verb" data-linktype="self-bookmark">HTTP verbs</a>.</p>
<p>Attribute routing uses a set of attributes to map actions directly to route templates. The following code is typical for a REST API and is used in the next sample:</p>
<pre><code class="lang-csharp">var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllers();

var app = builder.Build();

app.UseHttpsRedirection();

app.UseAuthorization();

app.MapControllers();

app.Run();
</code></pre>
<p>In the preceding code, <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapcontrollers" class="no-loc" data-linktype="absolute-path">MapControllers</a> is called to map attribute routed controllers.</p>
<p>In the following example:</p>
<ul>
<li><code>HomeController</code> matches a set of URLs similar to what the default conventional route <code>{controller=Home}/{action=Index}/{id?}</code> matches.</li>
</ul>
<pre><code class="lang-csharp">public class HomeController : Controller
{
    [Route("")]
    [Route("Home")]
    [Route("Home/Index")]
    [Route("Home/Index/{id?}")]
    public IActionResult Index(int? id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }

    [Route("Home/About")]
    [Route("Home/About/{id?}")]
    public IActionResult About(int? id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
</code></pre>
<p>The <code>HomeController.Index</code> action is run for any of the URL paths <code>/</code>, <code>/Home</code>, <code>/Home/Index</code>, or <code>/Home/Index/3</code>.</p>
<p>This example highlights a key programming difference between attribute routing and <a href="#cr6" data-linktype="self-bookmark">conventional routing</a>. Attribute routing requires more input to specify a route. The conventional default route handles routes more succinctly. However, attribute routing allows and requires precise control of which route templates apply to each <a href="#action" data-linktype="self-bookmark">action</a>.</p>
<p>With attribute routing, the controller and action names play no part in which action is matched, unless <a href="#routing-token-replacement-templates-ref-label" data-linktype="self-bookmark">token replacement</a> is used. The following example matches the same URLs as the previous example:</p>
<pre><code class="lang-csharp">public class MyDemoController : Controller
{
    [Route("")]
    [Route("Home")]
    [Route("Home/Index")]
    [Route("Home/Index/{id?}")]
    public IActionResult MyIndex(int? id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }

    [Route("Home/About")]
    [Route("Home/About/{id?}")]
    public IActionResult MyAbout(int? id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
</code></pre>
<p>The following code uses token replacement for <code>action</code> and <code>controller</code>:</p>
<pre><code class="lang-csharp">public class HomeController : Controller
{
    [Route("")]
    [Route("Home")]
    [Route("[controller]/[action]")]
    public IActionResult Index()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }

    [Route("[controller]/[action]")]
    public IActionResult About()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }
}
</code></pre>
<p>The following code applies <code>[Route("[controller]/[action]")]</code> to the controller:</p>
<pre><code class="lang-csharp">[Route("[controller]/[action]")]
public class HomeController : Controller
{
    [Route("~/")]
    [Route("/Home")]
    [Route("~/Home/Index")]
    public IActionResult Index()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }

    public IActionResult About()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }
}
</code></pre>
<p>In the preceding code, the <code>Index</code> method templates must prepend <code>/</code> or <code>~/</code> to the route templates. Route templates applied to an action that begin with <code>/</code> or <code>~/</code> don't get combined with route templates applied to the controller.</p>
<p>See <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-9.0#rtp" data-linktype="relative-path">Route template precedence</a> for information on route template selection.</p>
<h2 id="reserved-routing-names">Reserved routing names</h2>
<p>The following keywords are reserved route parameter names when using Controllers or Razor Pages:</p>
<ul>
<li><code>action</code></li>
<li><code>area</code></li>
<li><code>controller</code></li>
<li><code>handler</code></li>
<li><code>page</code></li>
</ul>
<p>Using <code>page</code> as a route parameter with attribute routing is a common error. Doing that results in inconsistent and confusing behavior with URL generation.</p>
<pre><code class="lang-csharp">public class MyDemo2Controller : Controller
{
    [Route("/articles/{page}")]
    public IActionResult ListArticles(int page)
    {
        return ControllerContext.MyDisplayRouteInfo(page);
    }
}
</code></pre>
<p>The special parameter names are used by the URL generation to determine if a URL generation operation refers to a Razor Page or to a Controller.</p>
<p>The following keywords are reserved in the context of a Razor view or a Razor Page:</p>
<ul>
<li><code>page</code></li>
<li><code>using</code></li>
<li><code>namespace</code></li>
<li><code>inject</code></li>
<li><code>section</code></li>
<li><code>inherits</code></li>
<li><code>model</code></li>
<li><code>addTagHelper</code></li>
<li><code>removeTagHelper</code></li>
</ul>
<p>These keywords shouldn't be used for link generations, model bound parameters, or top level properties.</p>
<p><a name="verb6"></a></p>
<h2 id="http-verb-templates">HTTP verb templates</h2>
<p>ASP.NET Core has the following HTTP verb templates:</p>
<ul>
<li><a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.httpgetattribute" data-linktype="absolute-path">[HttpGet]</a></li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.httppostattribute" data-linktype="absolute-path">[HttpPost]</a></li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.httpputattribute" data-linktype="absolute-path">[HttpPut]</a></li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.httpdeleteattribute" data-linktype="absolute-path">[HttpDelete]</a></li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.httpheadattribute" data-linktype="absolute-path">[HttpHead]</a></li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.httppatchattribute" data-linktype="absolute-path">[HttpPatch]</a></li>
</ul>
<p><a name="rt6"></a></p>
<h3 id="route-templates">Route templates</h3>
<p>ASP.NET Core has the following route templates:</p>
<ul>
<li>All the <a href="#verb6" data-linktype="self-bookmark">HTTP verb templates</a> are route templates.</li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.routeattribute" data-linktype="absolute-path">[Route]</a></li>
</ul>
<p><a name="arx"></a></p>
<h3 id="attribute-routing-with-http-verb-attributes">Attribute routing with Http verb attributes</h3>
<p>Consider the following controller:</p>
<pre><code class="lang-csharp">[Route("api/[controller]")]
[ApiController]
public class Test2Controller : ControllerBase
{
    [HttpGet]   // GET /api/test2
    public IActionResult ListProducts()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }

    [HttpGet("{id}")]   // GET /api/test2/xyz
    public IActionResult GetProduct(string id)
    {
       return ControllerContext.MyDisplayRouteInfo(id);
    }

    [HttpGet("int/{id:int}")] // GET /api/test2/int/3
    public IActionResult GetIntProduct(int id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }

    [HttpGet("int2/{id}")]  // GET /api/test2/int2/3
    public IActionResult GetInt2Product(int id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
</code></pre>
<p>In the preceding code:</p>
<ul>
<li>Each action contains the <code>[HttpGet]</code> attribute, which constrains matching to HTTP GET requests only.</li>
<li>The <code>GetProduct</code> action includes the <code>"{id}"</code> template, therefore <code>id</code> is appended to the <code>"api/[controller]"</code> template on the controller. The methods template is <code>"api/[controller]/{id}"</code>. Therefore this action only matches GET requests for the form <code>/api/test2/xyz</code>,<code>/api/test2/123</code>,<code>/api/test2/{any string}</code>, etc.<pre><code class="lang-csharp">[HttpGet("{id}")]   // GET /api/test2/xyz
public IActionResult GetProduct(string id)
{
   return ControllerContext.MyDisplayRouteInfo(id);
}
</code></pre></li>
<li>The <code>GetIntProduct</code> action contains the <code>"int/{id:int}"</code> template. The <code>:int</code> portion of the template constrains the <code>id</code> route values to strings that can be converted to an integer. A GET request to <code>/api/test2/int/abc</code>:
<ul>
<li>Doesn't match this action.</li>
<li>Returns a <a href="https://developer.mozilla.org/docs/Web/HTTP/Status/404" data-linktype="external">404 Not Found</a> error.<pre><code class="lang-csharp">[HttpGet("int/{id:int}")] // GET /api/test2/int/3
public IActionResult GetIntProduct(int id)
{
    return ControllerContext.MyDisplayRouteInfo(id);
}
</code></pre></li>
</ul>
</li>
<li>The <code>GetInt2Product</code> action contains <code>{id}</code> in the template, but doesn't constrain <code>id</code> to values that can be converted to an integer. A GET request to <code>/api/test2/int2/abc</code>:
<ul>
<li>Matches this route.</li>
<li>Model binding fails to convert <code>abc</code> to an integer. The <code>id</code> parameter of the method is integer.</li>
<li>Returns a <a href="https://developer.mozilla.org/docs/Web/HTTP/Status/400" data-linktype="external">400 Bad Request</a> because model binding failed to convert <code>abc</code> to an integer.<pre><code class="lang-csharp">[HttpGet("int2/{id}")]  // GET /api/test2/int2/3
public IActionResult GetInt2Product(int id)
{
    return ControllerContext.MyDisplayRouteInfo(id);
}
</code></pre></li>
</ul>
</li>
</ul>
<p>Attribute routing can use <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.routing.httpmethodattribute" class="no-loc" data-linktype="absolute-path">HttpMethodAttribute</a> attributes such as <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.httppostattribute" class="no-loc" data-linktype="absolute-path">HttpPostAttribute</a>, <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.httpputattribute" class="no-loc" data-linktype="absolute-path">HttpPutAttribute</a>, and <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.httpdeleteattribute" class="no-loc" data-linktype="absolute-path">HttpDeleteAttribute</a>. All of the <a href="#verb6" data-linktype="self-bookmark">HTTP verb</a> attributes accept a route template. The following example shows two actions that match the same route template:</p>
<pre><code class="lang-csharp">[ApiController]
public class MyProductsController : ControllerBase
{
    [HttpGet("/products3")]
    public IActionResult ListProducts()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }

    [HttpPost("/products3")]
    public IActionResult CreateProduct(MyProduct myProduct)
    {
        return ControllerContext.MyDisplayRouteInfo(myProduct.Name);
    }
}
</code></pre>
<p>Using the URL path <code>/products3</code>:</p>
<ul>
<li>The <code>MyProductsController.ListProducts</code> action runs when the <a href="#verb6" data-linktype="self-bookmark">HTTP verb</a> is <code>GET</code>.</li>
<li>The <code>MyProductsController.CreateProduct</code> action runs when the <a href="#verb6" data-linktype="self-bookmark">HTTP verb</a> is <code>POST</code>.</li>
</ul>
<p>When building a REST API, it's rare that you'll need to use <code>[Route(...)]</code> on an action method because the action accepts all HTTP methods. It's better to use the more specific <a href="#verb6" data-linktype="self-bookmark">HTTP verb attribute</a> to be precise about what your API supports. Clients of REST APIs are expected to know what paths and HTTP verbs map to specific logical operations.</p>
<p>REST APIs should use attribute routing to model the app's functionality as a set of resources where operations are represented by HTTP verbs. This means that many operations, for example, GET and POST on the same logical resource use the same URL. Attribute routing provides a level of control that's needed to carefully design an API's public endpoint layout.</p>
<p>Since an attribute route applies to a specific action, it's easy to make parameters required as part of the route template definition. In the following example, <code>id</code> is required as part of the URL path:</p>
<pre><code class="lang-csharp">[ApiController]
public class Products2ApiController : ControllerBase
{
    [HttpGet("/products2/{id}", Name = "Products_List")]
    public IActionResult GetProduct(int id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
</code></pre>
<p>The <code>Products2ApiController.GetProduct(int)</code> action:</p>
<ul>
<li>Is run with URL path like <code>/products2/3</code></li>
<li>Isn't run with the URL path <code>/products2</code>.</li>
</ul>
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.consumesattribute" data-linktype="absolute-path">[Consumes]</a> attribute allows an action to limit the supported request content types. For more information, see <a href="https://learn.microsoft.com/en-us/aspnet/core/web-api/?view=aspnetcore-9.0#consumes" data-linktype="relative-path">Define supported request content types with the Consumes attribute</a>.</p>
<p>See <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-9.0" data-linktype="relative-path">Routing</a> for a full description of route templates and related options.</p>
<p>For more information on <code>[ApiController]</code>, see <a href="https://learn.microsoft.com/en-us/aspnet/core/web-api/?view=aspnetcore-9.0##apicontroller-attribute" data-linktype="relative-path">ApiController attribute</a>.</p>
<h2 id="route-name">Route name</h2>
<p>The following code  defines a route name of <code>Products_List</code>:</p>
<pre><code class="lang-csharp">[ApiController]
public class Products2ApiController : ControllerBase
{
    [HttpGet("/products2/{id}", Name = "Products_List")]
    public IActionResult GetProduct(int id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
</code></pre>
<p>Route names can be used to generate a URL based on a specific route. Route names:</p>
<ul>
<li>Have no impact on the URL matching behavior of routing.</li>
<li>Are only used for URL generation.</li>
</ul>
<p>Route names must be unique application-wide.</p>
<p>Contrast the preceding code with the conventional default route, which defines the <code>id</code> parameter as optional (<code>{id?}</code>). The ability to precisely specify APIs has advantages, such as  allowing <code>/products</code> and <code>/products/5</code> to be dispatched to different actions.</p>
<p><a name="routing-combining-ref-label"></a></p>
<h2 id="combining-attribute-routes">Combining attribute routes</h2>
<p>To make attribute routing less repetitive, route attributes on the controller are combined with route attributes on the individual actions. Any route templates defined on the controller are prepended to route templates on the actions. Placing a route attribute on the controller makes <strong>all</strong> actions in the controller use attribute routing.</p>
<pre><code class="lang-csharp">[ApiController]
[Route("products")]
public class ProductsApiController : ControllerBase
{
    [HttpGet]
    public IActionResult ListProducts()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }

    [HttpGet("{id}")]
    public IActionResult GetProduct(int id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
</code></pre>
<p>In the preceding example:</p>
<ul>
<li>The URL path <code>/products</code> can match <code>ProductsApi.ListProducts</code></li>
<li>The URL path <code>/products/5</code> can match <code>ProductsApi.GetProduct(int)</code>.</li>
</ul>
<p>Both of these actions only match HTTP <code>GET</code> because they're marked with the <code>[HttpGet]</code> attribute.</p>
<p>Route templates applied to an action that begin with <code>/</code> or <code>~/</code> don't get combined with route templates applied to the controller. The following example matches a set of URL paths similar to the default route.</p>
<pre><code class="lang-csharp">[Route("Home")]
public class HomeController : Controller
{
    [Route("")]
    [Route("Index")]
    [Route("/")]
    public IActionResult Index()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }

    [Route("About")]
    public IActionResult About()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }
}
</code></pre>
<p>The following table explains the <code>[Route]</code> attributes in the preceding code:</p>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Combines with <code>[Route("Home")]</code></th>
<th>Defines route template</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[Route("")]</code></td>
<td>Yes</td>
<td><code>"Home"</code></td>
</tr>
<tr>
<td><code>[Route("Index")]</code></td>
<td>Yes</td>
<td><code>"Home/Index"</code></td>
</tr>
<tr>
<td><code>[Route("/")]</code></td>
<td><strong>No</strong></td>
<td><code>""</code></td>
</tr>
<tr>
<td><code>[Route("About")]</code></td>
<td>Yes</td>
<td><code>"Home/About"</code></td>
</tr>
</tbody>
</table>
<p><a name="routing-ordering-ref-label"></a>
<a name="oar"></a></p>
<h3 id="attribute-route-order">Attribute route order</h3>
<p>Routing builds a tree and matches all endpoints simultaneously:</p>
<ul>
<li>The route entries behave as if placed in an ideal ordering.</li>
<li>The most specific routes have a chance to execute before the more general routes.</li>
</ul>
<p>For example, an attribute route like <code>blog/search/{topic}</code> is more specific than an attribute route like <code>blog/{*article}</code>. The <code>blog/search/{topic}</code> route has higher priority, by default, because it's more specific. Using <a href="#cr6" data-linktype="self-bookmark">conventional routing</a>, the developer is responsible for placing routes in the desired order.</p>
<p>Attribute routes can configure an order using the <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.routeattribute.order#microsoft-aspnetcore-mvc-routeattribute-order" class="no-loc" data-linktype="absolute-path">Order</a> property. All of the framework provided <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.routeattribute" data-linktype="absolute-path">route attributes</a> include <code>Order</code> . Routes are processed according to an ascending sort of the <code>Order</code> property. The default order is <code>0</code>. Setting a route using <code>Order = -1</code> runs before routes that don't set an order. Setting a route using <code>Order = 1</code> runs after default route ordering.</p>
<p><strong>Avoid</strong> depending on <code>Order</code>. If an app's URL-space requires explicit order values to route correctly, then it's likely confusing to clients as well. In general, attribute routing selects the correct route with URL matching. If the default order used for URL generation isn't working, using a route name as an override is usually simpler than applying the <code>Order</code> property.</p>
<p>Consider the following two controllers which both define the route matching <code>/home</code>:</p>
<pre><code class="lang-csharp">public class HomeController : Controller
{
    [Route("")]
    [Route("Home")]
    [Route("Home/Index")]
    [Route("Home/Index/{id?}")]
    public IActionResult Index(int? id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }

    [Route("Home/About")]
    [Route("Home/About/{id?}")]
    public IActionResult About(int? id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
</code></pre><pre><code class="lang-csharp">public class MyDemoController : Controller
{
    [Route("")]
    [Route("Home")]
    [Route("Home/Index")]
    [Route("Home/Index/{id?}")]
    public IActionResult MyIndex(int? id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }

    [Route("Home/About")]
    [Route("Home/About/{id?}")]
    public IActionResult MyAbout(int? id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
</code></pre>
<p>Requesting <code>/home</code> with the preceding code throws an exception similar to the following:</p>
<pre><code class="lang-text">AmbiguousMatchException: The request matched multiple endpoints. Matches:

 WebMvcRouting.Controllers.HomeController.Index
 WebMvcRouting.Controllers.MyDemoController.MyIndex
</code></pre>
<p>Adding <code>Order</code> to one of the route attributes resolves the ambiguity:</p>
<pre><code class="lang-csharp">[Route("")]
[Route("Home", Order = 2)]
[Route("Home/MyIndex")]
public IActionResult MyIndex()
{
    return ControllerContext.MyDisplayRouteInfo();
}
</code></pre>
<p>With the preceding code, <code>/home</code> runs the <code>HomeController.Index</code> endpoint. To get to the <code>MyDemoController.MyIndex</code>, request <code>/home/MyIndex</code>. <strong>Note</strong>:</p>
<ul>
<li>The preceding code is an example or poor routing design. It was used to illustrate the <code>Order</code> property.</li>
<li>The <code>Order</code> property only resolves the ambiguity, that template cannot be matched. It would be better to remove the <code>[Route("Home")]</code> template.</li>
</ul>
<p>See <a href="https://learn.microsoft.com/en-us/aspnet/core/razor-pages/razor-pages-conventions?view=aspnetcore-9.0#route-order" data-linktype="relative-path">Razor Pages route and app conventions: Route order</a> for information on route order with Razor Pages.</p>
<p>In some cases, an HTTP 500 error is returned with ambiguous routes. Use <a href="../../fundamentals/logging/index553c.html?view=aspnetcore-9.0" data-linktype="relative-path">logging</a> to see which endpoints caused the <code>AmbiguousMatchException</code>.</p>
<p><a name="routing-token-replacement-templates-ref-label"></a></p>
<h2 id="token-replacement-in-route-templates-controller-action-area">Token replacement in route templates [controller], [action], [area]</h2>
<p>For convenience, attribute routes support <em>token replacement</em> by enclosing a token in square-brackets (<code>[</code>, <code>]</code>). The tokens <code>[action]</code>, <code>[area]</code>, and <code>[controller]</code> are replaced with the values of the action name, area name, and controller name from the action where the route is defined:</p>
<pre><code class="lang-csharp">[Route("[controller]/[action]")]
public class Products0Controller : Controller
{
    [HttpGet]
    public IActionResult List()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }


    [HttpGet("{id}")]
    public IActionResult Edit(int id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
</code></pre>
<p>In the preceding code:</p>
<pre><code class="lang-csharp">[HttpGet]
public IActionResult List()
{
    return ControllerContext.MyDisplayRouteInfo();
}
</code></pre>
<ul>
<li>Matches <code>/Products0/List</code></li>
</ul>
<pre><code class="lang-csharp">[HttpGet("{id}")]
public IActionResult Edit(int id)
{
    return ControllerContext.MyDisplayRouteInfo(id);
}
</code></pre>
<ul>
<li>Matches <code>/Products0/Edit/{id}</code></li>
</ul>
<p>Token replacement occurs as the last step of building the attribute routes. The preceding example behaves the same as the following code:</p>
<pre><code class="lang-csharp">public class Products20Controller : Controller
{
    [HttpGet("[controller]/[action]")]  // Matches '/Products20/List'
    public IActionResult List()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }

    [HttpGet("[controller]/[action]/{id}")]   // Matches '/Products20/Edit/{id}'
    public IActionResult Edit(int id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
</code></pre><p>If you are reading this in a language other than English, let us know in this <a href="https://github.com/dotnet/AspNetCore.Docs/issues/16455" data-linktype="external">GitHub discussion issue</a> if you'd like to see the code comments in your native language.</p>
<p>Attribute routes can also be combined with inheritance. This is powerful combined with token replacement. Token replacement also applies to route names defined by attribute routes.
<code>[Route("[controller]/[action]", Name="[controller]_[action]")]</code>generates a unique route name for each action:</p>
<pre><code class="lang-csharp">[ApiController]
[Route("api/[controller]/[action]", Name = "[controller]_[action]")]
public abstract class MyBase2Controller : ControllerBase
{
}

public class Products11Controller : MyBase2Controller
{
    [HttpGet]                      // /api/products11/list
    public IActionResult List()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }

    [HttpGet("{id}")]             //    /api/products11/edit/3
    public IActionResult Edit(int id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
</code></pre>
<p>To match the literal token replacement delimiter <code>[</code> or  <code>]</code>, escape it by repeating the character (<code>[[</code> or <code>]]</code>).</p>
<p><a name="routing-token-replacement-transformers-ref-label"></a></p>
<h3 id="use-a-parameter-transformer-to-customize-token-replacement">Use a parameter transformer to customize token replacement</h3>
<p>Token replacement can be customized using a parameter transformer. A parameter transformer implements <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.ioutboundparametertransformer" class="no-loc" data-linktype="absolute-path">IOutboundParameterTransformer</a> and transforms the value of parameters. For example, a custom <code>SlugifyParameterTransformer</code> parameter transformer changes the <code>SubscriptionManagement</code> route value to <code>subscription-management</code>:</p>
<pre><code class="lang-csharp">using System.Text.RegularExpressions;

public class SlugifyParameterTransformer : IOutboundParameterTransformer
{
    public string? TransformOutbound(object? value)
    {
        if (value == null) { return null; }

        return Regex.Replace(value.ToString()!,
                             "([a-z])([A-Z])",
                             "$1-$2",
                             RegexOptions.CultureInvariant,
                             TimeSpan.FromMilliseconds(100)).ToLowerInvariant();
    }
}
</code></pre>
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.applicationmodels.routetokentransformerconvention" class="no-loc" data-linktype="absolute-path">RouteTokenTransformerConvention</a> is an application model convention that:</p>
<ul>
<li>Applies a parameter transformer to all attribute routes in an application.</li>
<li>Customizes the attribute route token values as they are replaced.</li>
</ul>
<pre><code class="lang-csharp">public class SubscriptionManagementController : Controller
{
    [HttpGet("[controller]/[action]")]
    public IActionResult ListAll()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }
}
</code></pre>
<p>The preceding <code>ListAll</code> method matches <code>/subscription-management/list-all</code>.</p>
<p>The <code>RouteTokenTransformerConvention</code> is registered as an option:</p>
<pre><code class="lang-csharp">using Microsoft.AspNetCore.Mvc.ApplicationModels;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllersWithViews(options =&gt;
{
    options.Conventions.Add(new RouteTokenTransformerConvention(
                                 new SlugifyParameterTransformer()));
});

var app = builder.Build();

if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Home/Error");
    app.UseHsts();
}

app.UseHttpsRedirection();
app.UseStaticFiles();

app.UseRouting();

app.UseAuthorization();

app.MapControllerRoute(name: "default",
               pattern: "{controller=Home}/{action=Index}/{id?}");

app.Run();
</code></pre>
<p>See <a href="https://developer.mozilla.org/docs/Glossary/Slug" data-linktype="external">MDN web docs on Slug</a> for the definition of Slug.</p>
<div class="WARNING">
<p>Warning</p>
<p>When using <a href="https://learn.microsoft.com/en-us/dotnet/api/system.text.regularexpressions" class="no-loc" data-linktype="absolute-path">System.Text.RegularExpressions</a> to process untrusted input, pass a timeout. A malicious user can provide input to <code>RegularExpressions</code> causing a <a href="https://www.cisa.gov/news-events/news/understanding-denial-service-attacks" data-linktype="external">Denial-of-Service attack</a>. ASP.NET Core framework APIs that use <code>RegularExpressions</code> pass a timeout.</p>
</div>
<p><a name="routing-multiple-routes-ref-label"></a></p>
<h3 id="multiple-attribute-routes">Multiple attribute routes</h3>
<p>Attribute routing supports defining multiple routes that reach the same action. The most common usage of this is to mimic the behavior of the default conventional route as shown in the following example:</p>
<pre><code class="lang-csharp">[Route("[controller]")]
public class Products13Controller : Controller
{
    [Route("")]     // Matches 'Products13'
    [Route("Index")] // Matches 'Products13/Index'
    public IActionResult Index()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }
</code></pre>
<p>Putting multiple route attributes on the controller means that each one combines with each of the route attributes on the action methods:</p>
<pre><code class="lang-csharp">[Route("Store")]
[Route("[controller]")]
public class Products6Controller : Controller
{
    [HttpPost("Buy")]       // Matches 'Products6/Buy' and 'Store/Buy'
    [HttpPost("Checkout")]  // Matches 'Products6/Checkout' and 'Store/Checkout'
    public IActionResult Buy()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }
}
</code></pre>
<p>All the <a href="#verb6" data-linktype="self-bookmark">HTTP verb</a> route constraints implement <code>IActionConstraint</code>.</p>
<p>When multiple route attributes that implement <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.actionconstraints.iactionconstraint" class="no-loc" data-linktype="absolute-path">IActionConstraint</a> are placed on an action:</p>
<ul>
<li>Each action constraint combines with the route template applied to the controller.</li>
</ul>
<pre><code class="lang-csharp">[Route("api/[controller]")]
public class Products7Controller : ControllerBase
{
    [HttpPut("Buy")]        // Matches PUT 'api/Products7/Buy'
    [HttpPost("Checkout")]  // Matches POST 'api/Products7/Checkout'
    public IActionResult Buy()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }
}
</code></pre>
<p>Using multiple routes on actions might seem useful and powerful, it's better to keep your app's URL space basic and well defined. Use multiple routes on actions <strong>only</strong> where needed, for example, to support existing clients.</p>
<p><a name="routing-attr-options"></a></p>
<h3 id="specifying-attribute-route-optional-parameters-default-values-and-constraints">Specifying attribute route optional parameters, default values, and constraints</h3>
<p>Attribute routes support the same inline syntax as conventional routes to specify optional parameters, default values, and constraints.</p>
<pre><code class="lang-csharp" highlight-lines="3">public class Products14Controller : Controller
{
    [HttpPost("product14/{id:int}")]
    public IActionResult ShowProduct(int id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
</code></pre>
<p>In the preceding code, <code>[HttpPost("product14/{id:int}")]</code> applies a route constraint. The <code>Products14Controller.ShowProduct</code> action is matched only by URL paths like <code>/product14/3</code>. The route template portion <code>{id:int}</code> constrains that segment to only integers.</p>
<p>See <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-9.0#route-template-reference" data-linktype="relative-path">Route Template Reference</a> for a detailed description of route template syntax.</p>
<p><a name="routing-cust-rt-attr-irt-ref-label"></a></p>
<h3 id="custom-route-attributes-using-iroutetemplateprovider">Custom route attributes using IRouteTemplateProvider</h3>
<p>All of the <a href="#rt6" data-linktype="self-bookmark">route attributes</a> implement <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.routing.iroutetemplateprovider" class="no-loc" data-linktype="absolute-path">IRouteTemplateProvider</a>. The ASP.NET Core runtime:</p>
<ul>
<li>Looks for attributes on controller classes and action methods when the app starts.</li>
<li>Uses the attributes that implement <code>IRouteTemplateProvider</code> to build the initial set of routes.</li>
</ul>
<p>Implement <code>IRouteTemplateProvider</code> to define custom route attributes. Each <code>IRouteTemplateProvider</code> allows you to define a single route with a custom route template, order, and name:</p>
<pre><code class="lang-csharp" highlight-lines="1-10">public class MyApiControllerAttribute : Attribute, IRouteTemplateProvider
{
    public string Template =&gt; "api/[controller]";
    public int? Order =&gt; 2;
    public string Name { get; set; } = string.Empty;
}

[MyApiController]
[ApiController]
public class MyTestApiController : ControllerBase
{
    // GET /api/MyTestApi
    [HttpGet]
    public IActionResult Get()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }
}
</code></pre>
<p>The preceding <code>Get</code> method returns <code>Order = 2, Template = api/MyTestApi</code>.</p>
<p><a name="routing-app-model-ref-label"></a></p>
<h3 id="use-application-model-to-customize-attribute-routes">Use application model to customize attribute routes</h3>
<p>The application model:</p>
<ul>
<li>Is an object model created at startup in <code>Program.cs</code>.</li>
<li>Contains all of the metadata used by ASP.NET Core to route and execute the actions in an app.</li>
</ul>
<p>The application model includes all of the data gathered from route attributes. The data from route attributes is provided by the <code>IRouteTemplateProvider</code> implementation. Conventions:</p>
<ul>
<li>Can be written to modify the application model to customize how routing behaves.</li>
<li>Are read at app startup.</li>
</ul>
<p>This section shows a basic example of customizing routing using application model. The following code makes routes roughly line up with the folder structure of the project.</p>
<pre><code class="lang-csharp">public class NamespaceRoutingConvention : Attribute, IControllerModelConvention
{
    private readonly string _baseNamespace;

    public NamespaceRoutingConvention(string baseNamespace)
    {
        _baseNamespace = baseNamespace;
    }

    public void Apply(ControllerModel controller)
    {
        var hasRouteAttributes = controller.Selectors.Any(selector =&gt;
                                                selector.AttributeRouteModel != null);
        if (hasRouteAttributes)
        {
            return;
        }

        var namespc = controller.ControllerType.Namespace;
        if (namespc == null)
            return;
        var template = new StringBuilder();
        template.Append(namespc, _baseNamespace.Length + 1,
                        namespc.Length - _baseNamespace.Length - 1);
        template.Replace('.', '/');
        template.Append("/[controller]/[action]/{id?}");

        foreach (var selector in controller.Selectors)
        {
            selector.AttributeRouteModel = new AttributeRouteModel()
            {
                Template = template.ToString()
            };
        }
    }
}
</code></pre>
<p>The following code prevents the <code>namespace</code> convention from being applied to controllers that are attribute routed:</p>
<pre><code class="lang-csharp">public void Apply(ControllerModel controller)
{
    var hasRouteAttributes = controller.Selectors.Any(selector =&gt;
                                            selector.AttributeRouteModel != null);
    if (hasRouteAttributes)
    {
        return;
    }
</code></pre>
<p>For example, the following controller doesn't use <code>NamespaceRoutingConvention</code>:</p>
<pre><code class="lang-csharp" highlight-lines="1">[Route("[controller]/[action]/{id?}")]
public class ManagersController : Controller
{
    // /managers/index
    public IActionResult Index()
    {
        var template = ControllerContext.ActionDescriptor.AttributeRouteInfo?.Template;
        return Content($"Index- template:{template}");
    }

    public IActionResult List(int? id)
    {
        var path = Request.Path.Value;
        return Content($"List- Path:{path}");
    }
}
</code></pre>
<p>The <code>NamespaceRoutingConvention.Apply</code> method:</p>
<ul>
<li>Does nothing if the controller is attribute routed.</li>
<li>Sets the controllers template based on the <code>namespace</code>, with the base <code>namespace</code> removed.</li>
</ul>
<p>The <code>NamespaceRoutingConvention</code> can be applied in <code>Program.cs</code>:</p>
<pre><code class="lang-csharp">using My.Application.Controllers;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllersWithViews(options =&gt;
{
    options.Conventions.Add(
     new NamespaceRoutingConvention(typeof(HomeController).Namespace!));
});

var app = builder.Build();
</code></pre>
<p>For example, consider the following controller:</p>
<pre><code class="lang-csharp">using Microsoft.AspNetCore.Mvc;

namespace My.Application.Admin.Controllers
{
    public class UsersController : Controller
    {
        // GET /admin/controllers/users/index
        public IActionResult Index()
        {
            var fullname = typeof(UsersController).FullName;
            var template = 
                ControllerContext.ActionDescriptor.AttributeRouteInfo?.Template;
            var path = Request.Path.Value;

            return Content($"Path: {path} fullname: {fullname}  template:{template}");
        }

        public IActionResult List(int? id)
        {
            var path = Request.Path.Value;
            return Content($"Path: {path} ID:{id}");
        }
    }
}
</code></pre>
<p>In the preceding code:</p>
<ul>
<li>The base <code>namespace</code> is <code>My.Application</code>.</li>
<li>The full name of the preceding controller is <code>My.Application.Admin.Controllers.UsersController</code>.</li>
<li>The <code>NamespaceRoutingConvention</code> sets the controllers template to <code>Admin/Controllers/Users/[action]/{id?</code>.</li>
</ul>
<p>The <code>NamespaceRoutingConvention</code> can also be applied as an attribute on a controller:</p>
<pre><code class="lang-csharp" highlight-lines="1">[NamespaceRoutingConvention("My.Application")]
public class TestController : Controller
{
    // /admin/controllers/test/index
    public IActionResult Index()
    {
        var template = ControllerContext.ActionDescriptor.AttributeRouteInfo?.Template;
        var actionname = ControllerContext.ActionDescriptor.ActionName;
        return Content($"Action- {actionname} template:{template}");
    }

    public IActionResult List(int? id)
    {
        var path = Request.Path.Value;
        return Content($"List- Path:{path}");
    }
}
</code></pre>
<p><a name="routing-mixed-ref-label"></a></p>
<h2 id="mixed-routing-attribute-routing-vs-conventional-routing">Mixed routing: Attribute routing vs conventional routing</h2>
<p>ASP.NET Core apps can mix the use of conventional routing and attribute routing. It's typical to use conventional routes for controllers serving HTML pages for browsers, and attribute routing for controllers serving REST APIs.</p>
<p>Actions are either conventionally routed or attribute routed. Placing a route on the controller or the action makes it attribute routed. Actions that define attribute routes cannot be reached through the conventional routes and vice-versa. <em><strong>Any</strong></em> route attribute on the controller makes <em><strong>all</strong></em> actions in the controller attribute routed.</p>
<p>Attribute routing and conventional routing use the same routing engine.</p>
<h2 id="routing-with-special-characters">Routing with special characters</h2>
<p>Routing with special characters can lead to unexpected results. For example, consider a controller with the following action method:</p>
<pre><code class="lang-csharp">[HttpGet("{id?}/name")]
public async Task&lt;ActionResult&lt;string&gt;&gt; GetName(string id)
{
    var todoItem = await _context.TodoItems.FindAsync(id);

    if (todoItem == null || todoItem.Name == null)
    {
        return NotFound();
    }

    return todoItem.Name;
}
</code></pre>
<p>When <code>string id</code> contains the following encoded values, unexpected results might occur:</p>
<table>
<thead>
<tr>
<th>ASCII</th>
<th>Encoded</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/</code></td>
<td><code>%2F</code></td>
</tr>
<tr>
<td><code> </code></td>
<td><code>+</code></td>
</tr>
</tbody>
</table>
<p>Route parameters are not always URL decoded. This problem may be addressed in the future. For more information, see <a href="https://github.com/dotnet/aspnetcore/issues/11544" data-linktype="external">this GitHub issue</a>;</p>
<p><a name="routing-url-gen-ref-label"></a>
<a name="ambient"></a></p>
<h2 id="url-generation-and-ambient-values">URL Generation and ambient values</h2>
<p>Apps can use routing URL generation features to generate URL links to actions. Generating URLs eliminates <a href="https://wikipedia.org/wiki/Hard_coding" data-linktype="external">hard-coding</a> URLs, making code more robust and maintainable. This section focuses on the URL generation features provided by MVC and only cover basics of how URL generation works. See <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-9.0" data-linktype="relative-path">Routing</a> for a detailed description of URL generation.</p>
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.iurlhelper" class="no-loc" data-linktype="absolute-path">IUrlHelper</a> interface is the underlying element of infrastructure between MVC and routing for URL generation. An instance of <code>IUrlHelper</code> is available through the <code>Url</code> property in controllers, views, and view components.</p>
<p>In the following example, the <code>IUrlHelper</code> interface is used through the <code>Controller.Url</code> property to generate a URL to another action.</p>
<pre><code class="lang-csharp">public class UrlGenerationController : Controller
{
    public IActionResult Source()
    {
        // Generates /UrlGeneration/Destination
        var url = Url.Action("Destination");
        return ControllerContext.MyDisplayRouteInfo("", $" URL = {url}");
    }

    public IActionResult Destination()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }
}
</code></pre>
<p>If the app is using the default conventional route, the value of the <code>url</code> variable is the URL path string <code>/UrlGeneration/Destination</code>. This URL path is created by routing by combining:</p>
<ul>
<li>The route values from the current request, which are called <strong>ambient values</strong>.</li>
<li>The values passed to <code>Url.Action</code> and substituting those values into the route template:</li>
</ul>
<pre><code class="lang-text">ambient values: { controller = "UrlGeneration", action = "Source" }
values passed to Url.Action: { controller = "UrlGeneration", action = "Destination" }
route template: {controller}/{action}/{id?}

result: /UrlGeneration/Destination
</code></pre>
<p>Each route parameter in the route template has its value substituted by matching names with the values and ambient values. A route parameter that doesn't have a value can:</p>
<ul>
<li>Use a default value if it has one.</li>
<li>Be skipped if it's optional. For example, the <code>id</code> from the  route template <code>{controller}/{action}/{id?}</code>.</li>
</ul>
<p>URL generation fails if any required route parameter doesn't have a corresponding value. If URL generation fails for a route, the next route is tried until all routes have been tried or a match is found.</p>
<p>The preceding example of <code>Url.Action</code> assumes <a href="#cr6" data-linktype="self-bookmark">conventional routing</a>. URL generation works similarly with <a href="#ar6" data-linktype="self-bookmark">attribute routing</a>, though the concepts are different. With conventional routing:</p>
<ul>
<li>The route values are used to expand a template.</li>
<li>The route values for <code>controller</code> and <code>action</code> usually appear in that template. This works because the URLs matched by routing adhere to a convention.</li>
</ul>
<p>The following example uses attribute routing:</p>
<pre><code class="lang-csharp">public class UrlGenerationAttrController : Controller
{
    [HttpGet("custom")]
    public IActionResult Source()
    {
        var url = Url.Action("Destination");
        return ControllerContext.MyDisplayRouteInfo("", $" URL = {url}");
    }

    [HttpGet("custom/url/to/destination")]
    public IActionResult Destination()
    {
       return ControllerContext.MyDisplayRouteInfo();
    }
}
</code></pre>
<p>The <code>Source</code> action in the preceding code generates <code>custom/url/to/destination</code>.</p>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.linkgenerator" class="no-loc" data-linktype="absolute-path">LinkGenerator</a> was added in ASP.NET Core 3.0 as an alternative to <code>IUrlHelper</code>. <code>LinkGenerator</code> offers similar but more flexible functionality. Each method on <code>IUrlHelper</code> has a corresponding family of methods on <code>LinkGenerator</code> as well.</p>
<h3 id="generating-urls-by-action-name">Generating URLs by action name</h3>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.iurlhelper.action" data-linktype="absolute-path">Url.Action</a>, <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.controllerlinkgeneratorextensions.getpathbyaction" data-linktype="absolute-path">LinkGenerator.GetPathByAction</a>, and all related overloads all are designed to generate the target endpoint by specifying a controller name and action name.</p>
<p>When using <code>Url.Action</code>, the current route values for <code>controller</code> and <code>action</code> are provided by the runtime:</p>
<ul>
<li>The value of <code>controller</code> and <code>action</code> are part of both <a href="#ambient" data-linktype="self-bookmark">ambient values</a> and values. The method <code>Url.Action</code> always uses the current values of <code>action</code> and <code>controller</code> and generates a URL path that routes to the current action.</li>
</ul>
<p>Routing attempts to use the values in ambient values to fill in information that wasn't provided when generating a URL. Consider a route like <code>{a}/{b}/{c}/{d}</code> with ambient values <code>{ a = Alice, b = Bob, c = Carol, d = David }</code>:</p>
<ul>
<li>Routing has enough information to generate a URL without any additional values.</li>
<li>Routing has enough information because all route parameters have a value.</li>
</ul>
<p>If the value <code>{ d = Donovan }</code> is added:</p>
<ul>
<li>The value <code>{ d = David }</code> is ignored.</li>
<li>The generated URL path is <code>Alice/Bob/Carol/Donovan</code>.</li>
</ul>
<p><strong>Warning</strong>: URL paths are hierarchical. In the preceding example, if the value <code>{ c = Cheryl }</code> is added:</p>
<ul>
<li>Both of the values <code>{ c = Carol, d = David }</code> are ignored.</li>
<li>There is no longer a value for <code>d</code> and URL generation fails.</li>
<li>The desired values of <code>c</code> and <code>d</code> must be specified to generate a URL.</li>
</ul>
<p>You might expect to hit this problem with the default route <code>{controller}/{action}/{id?}</code>. This problem is rare in practice because <code>Url.Action</code> always explicitly specifies a <code>controller</code> and <code>action</code> value.</p>
<p>Several overloads of <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.iurlhelper.action" data-linktype="absolute-path">Url.Action</a> take a route values object to provide values for route parameters other than <code>controller</code> and <code>action</code>. The route values object is frequently used with <code>id</code>. For example, <code>Url.Action("Buy", "Products", new { id = 17 })</code>. The route values object:</p>
<ul>
<li>By convention is usually an object of anonymous type.</li>
<li>Can be an <code>IDictionary&lt;&gt;</code> or a <a href="https://wikipedia.org/wiki/Plain_old_CLR_object" data-linktype="external">POCO</a>).</li>
</ul>
<p>Any additional route values that don't match route parameters are put in the query string.</p>
<pre><code class="lang-csharp">public IActionResult Index()
{
    var url = Url.Action("Buy", "Products", new { id = 17, color = "red" });
    return Content(url!);
}
</code></pre>
<p>The preceding code generates <code>/Products/Buy/17?color=red</code>.</p>
<p>The following code generates an absolute URL:</p>
<pre><code class="lang-csharp">public IActionResult Index2()
{
    var url = Url.Action("Buy", "Products", new { id = 17 }, protocol: Request.Scheme);
    // Returns https://localhost:5001/Products/Buy/17
    return Content(url!);
}
</code></pre>
<p>To create an absolute URL, use one of the following:</p>
<ul>
<li>An overload that accepts a <code>protocol</code>. For example, the preceding code.</li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.controllerlinkgeneratorextensions.geturibyaction" data-linktype="absolute-path">LinkGenerator.GetUriByAction</a>, which generates absolute URIs by default.</li>
</ul>
<p><a name="routing-gen-urls-route-ref-label"></a></p>
<h3 id="generate-urls-by-route">Generate URLs by route</h3>
<p>The preceding code demonstrated generating a URL by passing in the controller and action name. <code>IUrlHelper</code> also provides the <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.iurlhelper.routeurl" data-linktype="absolute-path">Url.RouteUrl</a> family of methods. These methods are similar to <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.iurlhelper.action" data-linktype="absolute-path">Url.Action</a>, but they don't copy the current values of <code>action</code> and <code>controller</code> to the route values. The most common usage of <code>Url.RouteUrl</code>:</p>
<ul>
<li>Specifies a route name to generate the URL.</li>
<li>Generally doesn't specify a controller or action name.</li>
</ul>
<pre><code class="lang-csharp">public class UrlGeneration2Controller : Controller
{
    [HttpGet("")]
    public IActionResult Source()
    {
        var url = Url.RouteUrl("Destination_Route");
        return ControllerContext.MyDisplayRouteInfo("", $" URL = {url}");
    }

    [HttpGet("custom/url/to/destination2", Name = "Destination_Route")]
    public IActionResult Destination()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }
</code></pre>
<p>The following Razor file generates an HTML link to the <code>Destination_Route</code>:</p>
<pre><code class="lang-cshtml">&lt;h1&gt;Test Links&lt;/h1&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;a href="@Url.RouteUrl("Destination_Route")"&gt;Test Destination_Route&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p><a name="routing-gen-urls-html-ref-label"></a></p>
<h3 id="generate-urls-in-html-and-razor">Generate URLs in HTML and Razor</h3>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.rendering.ihtmlhelper" class="no-loc" data-linktype="absolute-path">IHtmlHelper</a> provides the <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.viewfeatures.htmlhelper" class="no-loc" data-linktype="absolute-path">HtmlHelper</a> methods <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.rendering.ihtmlhelper.beginform" data-linktype="absolute-path">Html.BeginForm</a> and <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.rendering.ihtmlhelper.actionlink" data-linktype="absolute-path">Html.ActionLink</a> to generate <code>&lt;form&gt;</code> and <code>&lt;a&gt;</code> elements respectively. These methods use the <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.iurlhelper.action" data-linktype="absolute-path">Url.Action</a> method to generate a URL and they accept similar arguments. The <code>Url.RouteUrl</code> companions for <code>HtmlHelper</code> are <code>Html.BeginRouteForm</code> and <code>Html.RouteLink</code> which have similar functionality.</p>
<p>TagHelpers generate URLs through the <code>form</code> TagHelper and the <code>&lt;a&gt;</code> TagHelper. Both of these use <code>IUrlHelper</code> for their implementation. See <a href="https://learn.microsoft.com/en-us/aspnet/core/mvc/views/working-with-forms?view=aspnetcore-9.0" data-linktype="relative-path">Tag Helpers in forms</a> for more information.</p>
<p>Inside views, the <code>IUrlHelper</code> is available through the <code>Url</code> property for any ad-hoc URL generation not covered by the above.</p>
<p><a name="routing-gen-urls-action-ref-label"></a></p>
<h3 id="url-generation-in-action-results">URL generation in Action Results</h3>
<p>The preceding examples showed using <code>IUrlHelper</code> in a controller. The most common usage in a controller is to generate a URL as part of an action result.</p>
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase" class="no-loc" data-linktype="absolute-path">ControllerBase</a> and <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controller" class="no-loc" data-linktype="absolute-path">Controller</a> base classes provide convenience methods for action results that reference another action. One typical usage is to redirect after accepting user input:</p>
<pre><code class="lang-csharp">[HttpPost]
[ValidateAntiForgeryToken]
public IActionResult Edit(int id, Customer customer)
{
    if (ModelState.IsValid)
    {
        // Update DB with new details.
        ViewData["Message"] = $"Successful edit of customer {id}";
        return RedirectToAction("Index");
    }
    return View(customer);
}
</code></pre>
<p>The action results factory methods such as <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase.redirecttoaction" class="no-loc" data-linktype="absolute-path">RedirectToAction</a> and <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase.createdataction" class="no-loc" data-linktype="absolute-path">CreatedAtAction</a> follow a similar pattern to the methods on <code>IUrlHelper</code>.</p>
<p><a name="routing-dedicated-ref-label"></a></p>
<h3 id="special-case-for-dedicated-conventional-routes">Special case for dedicated conventional routes</h3>
<p><a href="#cr6" data-linktype="self-bookmark">Conventional routing</a> can use a special kind of route definition called a <a href="#dcr" data-linktype="self-bookmark">dedicated conventional route</a>. In the following example, the route named <code>blog</code> is a dedicated conventional route:</p>
<pre><code class="lang-csharp">app.MapControllerRoute(name: "blog",
                pattern: "blog/{*article}",
                defaults: new { controller = "Blog", action = "Article" });
app.MapControllerRoute(name: "default",
               pattern: "{controller=Home}/{action=Index}/{id?}");

</code></pre>
<p>Using the preceding route definitions, <code>Url.Action("Index", "Home")</code> generates the URL path <code>/</code> using the <code>default</code> route, but why? You might guess the route values <code>{ controller = Home, action = Index }</code> would be enough to generate a URL using <code>blog</code>, and the result would be <code>/blog?action=Index&amp;controller=Home</code>.</p>
<p><a href="#dcr" data-linktype="self-bookmark">Dedicated conventional routes</a> rely on a special behavior of default values that don't have a corresponding route parameter that prevents the route from being too <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-9.0#greedy" data-linktype="relative-path">greedy</a> with URL generation. In this case the default values are <code>{ controller = Blog, action = Article }</code>, and neither <code>controller</code> nor <code>action</code> appears as a route parameter. When routing performs URL generation, the values provided must match the default values. URL generation using <code>blog</code> fails because the values <code>{ controller = Home, action = Index }</code> don't match <code>{ controller = Blog, action = Article }</code>. Routing then falls back to try <code>default</code>, which succeeds.</p>
<p><a name="routing-areas-ref-label"></a></p>
<h2 id="areas">Areas</h2>
<p><a href="https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/areas?view=aspnetcore-9.0" data-linktype="relative-path">Areas</a> are an MVC feature used to organize related functionality into a group as a separate:</p>
<ul>
<li>Routing namespace for controller actions.</li>
<li>Folder structure for views.</li>
</ul>
<p>Using areas allows an app to have multiple controllers with the same name, as long as they have different areas. Using areas creates a hierarchy for the purpose of routing by adding another route parameter, <code>area</code> to <code>controller</code> and <code>action</code>. This section discusses how routing interacts with areas. See <a href="https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/areas?view=aspnetcore-9.0" data-linktype="relative-path">Areas</a> for details about how areas are used with views.</p>
<p>The following example configures MVC to use the default conventional route and an <code>area</code> route for an <code>area</code> named <code>Blog</code>:</p>
<pre><code class="lang-csharp">var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllersWithViews();

var app = builder.Build();

if (!app.Environment.IsDevelopment())
{    
    app.UseExceptionHandler("/Home/Error");
    app.UseHsts();
}

app.UseHttpsRedirection();
app.UseStaticFiles();

app.UseRouting();

app.UseAuthorization();

app.MapAreaControllerRoute("blog_route", "Blog",
        "Manage/{controller}/{action}/{id?}");
app.MapControllerRoute("default_route", "{controller}/{action}/{id?}");

app.Run();
</code></pre>
<p>In the preceding code, <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapareacontrollerroute" class="no-loc" data-linktype="absolute-path">MapAreaControllerRoute</a> is called to create the <code>"blog_route"</code>. The second parameter, <code>"Blog"</code>, is the area name.</p>
<p>When matching a URL path like <code>/Manage/Users/AddUser</code>, the <code>"blog_route"</code> route generates the route values <code>{ area = Blog, controller = Users, action = AddUser }</code>. The <code>area</code> route value is produced by a default value for <code>area</code>. The route created by <code>MapAreaControllerRoute</code> is equivalent to the following:</p>
<pre><code class="lang-csharp">app.MapControllerRoute("blog_route", "Manage/{controller}/{action}/{id?}",
        defaults: new { area = "Blog" }, constraints: new { area = "Blog" });
app.MapControllerRoute("default_route", "{controller}/{action}/{id?}");
</code></pre>
<p><code>MapAreaControllerRoute</code> creates a route using both a default value and constraint for <code>area</code> using the provided area name, in this case <code>Blog</code>. The default value ensures that the route always produces <code>{ area = Blog, ... }</code>, the constraint requires the value <code>{ area = Blog, ... }</code> for URL generation.</p>
<p>Conventional routing is order-dependent. In general, routes with areas should be placed earlier as they're more specific than routes without an area.</p>
<p>Using the preceding example, the route values <code>{ area = Blog, controller = Users, action = AddUser }</code> match the following action:</p>
<pre><code class="lang-csharp">using Microsoft.AspNetCore.Mvc;

namespace MyApp.Namespace1
{
    [Area("Blog")]
    public class UsersController : Controller
    {
        // GET /manage/users/adduser
        public IActionResult AddUser()
        {
            var area = ControllerContext.ActionDescriptor.RouteValues["area"];
            var actionName = ControllerContext.ActionDescriptor.ActionName;
            var controllerName = ControllerContext.ActionDescriptor.ControllerName;

            return Content($"area name:{area}" +
                $" controller:{controllerName}  action name: {actionName}");
        }        
    }
}
</code></pre>
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.areaattribute" data-linktype="absolute-path">[Area]</a> attribute is what denotes a controller as part of an area. This controller is in the <code>Blog</code> area. Controllers without an <code>[Area]</code> attribute are not members of any area, and do <strong>not</strong> match when the <code>area</code> route value is provided by routing. In the following example, only the first controller listed can match the route values <code>{ area = Blog, controller = Users, action = AddUser }</code>.</p>
<pre><code class="lang-csharp">using Microsoft.AspNetCore.Mvc;

namespace MyApp.Namespace1
{
    [Area("Blog")]
    public class UsersController : Controller
    {
        // GET /manage/users/adduser
        public IActionResult AddUser()
        {
            var area = ControllerContext.ActionDescriptor.RouteValues["area"];
            var actionName = ControllerContext.ActionDescriptor.ActionName;
            var controllerName = ControllerContext.ActionDescriptor.ControllerName;

            return Content($"area name:{area}" +
                $" controller:{controllerName}  action name: {actionName}");
        }        
    }
}
</code></pre><pre><code class="lang-csharp">using Microsoft.AspNetCore.Mvc;

namespace MyApp.Namespace2
{
    // Matches { area = Zebra, controller = Users, action = AddUser }
    [Area("Zebra")]
    public class UsersController : Controller
    {
        // GET /zebra/users/adduser
        public IActionResult AddUser()
        {
            var area = ControllerContext.ActionDescriptor.RouteValues["area"];
            var actionName = ControllerContext.ActionDescriptor.ActionName;
            var controllerName = ControllerContext.ActionDescriptor.ControllerName;

            return Content($"area name:{area}" +
                $" controller:{controllerName}  action name: {actionName}");
        }        
    }
}
</code></pre><pre><code class="lang-csharp">using Microsoft.AspNetCore.Mvc;

namespace MyApp.Namespace3
{
    // Matches { area = string.Empty, controller = Users, action = AddUser }
    // Matches { area = null, controller = Users, action = AddUser }
    // Matches { controller = Users, action = AddUser }
    public class UsersController : Controller
    {
        // GET /users/adduser
        public IActionResult AddUser()
        {
            var area = ControllerContext.ActionDescriptor.RouteValues["area"];
            var actionName = ControllerContext.ActionDescriptor.ActionName;
            var controllerName = ControllerContext.ActionDescriptor.ControllerName;

            return Content($"area name:{area}" +
                $" controller:{controllerName}  action name: {actionName}");
        }
    }
}
</code></pre>
<p>The namespace of each controller is shown here for completeness. If the preceding controllers used the same namespace, a compiler error would be generated. Class namespaces have no effect on MVC's routing.</p>
<p>The first two controllers are members of areas, and only match when their respective area name is provided by the <code>area</code> route value. The third controller isn't a member of any area, and can only match when no value for <code>area</code> is provided by routing.</p>
<p><a name="aa"></a></p>
<p>In terms of matching <em>no value</em>, the absence of the <code>area</code> value is the same as if the value for <code>area</code> were null or the empty string.</p>
<p>When executing an action inside an area, the route value for <code>area</code> is available as an <a href="#ambient" data-linktype="self-bookmark">ambient value</a> for routing to use for URL generation. This means that by default areas act <em>sticky</em> for URL generation as demonstrated by the following sample.</p>
<pre><code class="lang-csharp">app.MapAreaControllerRoute(name: "duck_route",
                                     areaName: "Duck",
                                     pattern: "Manage/{controller}/{action}/{id?}");
app.MapControllerRoute(name: "default",
                             pattern: "Manage/{controller=Home}/{action=Index}/{id?}");
</code></pre><pre><code class="lang-csharp">using Microsoft.AspNetCore.Mvc;

namespace MyApp.Namespace4
{
    [Area("Duck")]
    public class UsersController : Controller
    {
        // GET /Manage/users/GenerateURLInArea
        public IActionResult GenerateURLInArea()
        {
            // Uses the 'ambient' value of area.
            var url = Url.Action("Index", "Home");
            // Returns /Manage/Home/Index
            return Content(url);
        }

        // GET /Manage/users/GenerateURLOutsideOfArea
        public IActionResult GenerateURLOutsideOfArea()
        {
            // Uses the empty value for area.
            var url = Url.Action("Index", "Home", new { area = "" });
            // Returns /Manage
            return Content(url);
        }
    }
}
</code></pre>
<p>The following code generates a URL to <code>/Zebra/Users/AddUser</code>:</p>
<pre><code class="lang-csharp">public class HomeController : Controller
{
    public IActionResult About()
    {
        var url = Url.Action("AddUser", "Users", new { Area = "Zebra" });
        return Content($"URL: {url}");
    }
</code></pre>
<p><a name="action"></a></p>
<h2 id="action-definition">Action definition</h2>
<p>Public methods on a controller, except those with the <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.nonactionattribute" data-linktype="absolute-path">NonAction</a> attribute, are actions.</p>
<h2 id="sample-code">Sample code</h2>
<ul>
<li><a href="https://github.com/Rick-Anderson/RouteInfo/blob/master/Microsoft.Docs.Samples.RouteInfo/ControllerContextExtensions.cs" data-linktype="external">MyDisplayRouteInfo</a> is provided by the <a href="https://www.nuget.org/packages/Rick.Docs.Samples.RouteInfo" data-linktype="external">Rick.Docs.Samples.RouteInfo</a> NuGet package and displays route information.</li>
<li><a href="https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/mvc/controllers/routing/samples/3.x" data-linktype="external">View or download sample code</a> (<a href="../../overview553c.html?view=aspnetcore-9.0#how-to-download-a-sample" data-linktype="relative-path">how to download</a>)</li>
</ul>
<h2 id="debug-diagnostics">Debug diagnostics</h2>
<p>For detailed routing diagnostic output, set <code>Logging:LogLevel:Microsoft</code> to <code>Debug</code>. In the development environment, set the log level in <code>appsettings.Development.json</code>:</p>
<pre><code class="lang-json">{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Debug",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  }
}
</code></pre>
</div>
<div data-moniker="aspnetcore-1.0 aspnetcore-1.1 aspnetcore-2.0 aspnetcore-2.1 aspnetcore-2.2 aspnetcore-3.0 aspnetcore-3.1 aspnetcore-5.0">
<p>ASP.NET Core controllers use the Routing <a href="../../fundamentals/middleware/index553c.html?view=aspnetcore-9.0" data-linktype="relative-path">middleware</a> to match the URLs of incoming requests and map them to <a href="#action" data-linktype="self-bookmark">actions</a>.  Route templates:</p>
<ul>
<li>Are defined in startup code or attributes.</li>
<li>Describe how URL paths are matched to <a href="#action" data-linktype="self-bookmark">actions</a>.</li>
<li>Are used to generate URLs for links. The generated links are typically returned in responses.</li>
</ul>
<p>Actions are either <a href="#cr" data-linktype="self-bookmark">conventionally-routed</a> or <a href="#ar" data-linktype="self-bookmark">attribute-routed</a>. Placing a route on the controller or <a href="#action" data-linktype="self-bookmark">action</a> makes it attribute-routed. See <a href="#routing-mixed-ref-label" data-linktype="self-bookmark">Mixed routing</a> for more information.</p>
<p>This document:</p>
<ul>
<li>Explains the interactions between MVC and routing:
<ul>
<li>How typical MVC apps make use of routing features.</li>
<li>Covers both:
<ul>
<li><a href="#cr" data-linktype="self-bookmark">Conventional routing</a> typically used with controllers and views.</li>
<li><em>Attribute routing</em> used with REST APIs. If you're primarily interested in routing for REST APIs, jump to the <a href="#ar" data-linktype="self-bookmark">Attribute routing for REST APIs</a> section.</li>
</ul>
</li>
<li>See <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-9.0" data-linktype="relative-path">Routing</a> for advanced routing details.</li>
</ul>
</li>
<li>Refers to the default routing system added in ASP.NET Core 3.0, called endpoint routing. It's possible to use controllers with the previous version of routing for compatibility purposes. See the <a href="https://learn.microsoft.com/en-us/aspnet/core/migration/22-to-30?view=aspnetcore-9.0" data-linktype="relative-path">2.2-3.0 migration guide</a> for instructions. Refer to the <a href="https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/routing?view=aspnetcore-2.2" data-linktype="relative-path">2.2 version of this document</a> for reference material on the legacy routing system.</li>
</ul>
<p><a name="cr"></a></p>
<h2 id="set-up-conventional-route-1">Set up conventional route</h2>
<p><code>Startup.Configure</code> typically has code similar to the following when using <a href="#crd" data-linktype="self-bookmark">conventional routing</a>:</p>
<pre><code class="lang-csharp">app.UseEndpoints(endpoints =&gt;
{
    endpoints.MapControllerRoute(
        name: "default",
        pattern: "{controller=Home}/{action=Index}/{id?}");
});
</code></pre>
<p>Inside the call to <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.endpointroutingapplicationbuilderextensions.useendpoints" class="no-loc" data-linktype="absolute-path">UseEndpoints</a>, <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapcontrollerroute" class="no-loc" data-linktype="absolute-path">MapControllerRoute</a> is used to create a single route. The single route is named <code>default</code> route. Most apps with controllers and views use a route template similar to the <code>default</code> route. REST APIs should use <a href="#ar" data-linktype="self-bookmark">attribute routing</a>.</p>
<p>The route template <code>"{controller=Home}/{action=Index}/{id?}"</code>:</p>
<ul>
<li><p>Matches a URL path like <code>/Products/Details/5</code></p>
</li>
<li><p>Extracts the route values <code>{ controller = Products, action = Details, id = 5 }</code> by tokenizing the path. The extraction of route values results in a match if the app has a controller named <code>ProductsController</code> and a <code>Details</code> action:</p>
<pre><code class="lang-csharp">public class ProductsController : Controller
{
    public IActionResult Details(int id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
</code></pre><p><a href="https://github.com/Rick-Anderson/RouteInfo/blob/master/Microsoft.Docs.Samples.RouteInfo/ControllerContextExtensions.cs" data-linktype="external">MyDisplayRouteInfo</a> is provided by the <a href="https://www.nuget.org/packages/Rick.Docs.Samples.RouteInfo" data-linktype="external">Rick.Docs.Samples.RouteInfo</a> NuGet package and displays route information.</p>
</li>
<li><p><code>/Products/Details/5</code> model binds the value of <code>id = 5</code> to set the <code>id</code> parameter to <code>5</code>. See <a href="../models/model-binding553c.html?view=aspnetcore-9.0" data-linktype="relative-path">Model Binding</a> for more details.</p>
</li>
<li><p><code>{controller=Home}</code> defines <code>Home</code> as the default <code>controller</code>.</p>
</li>
<li><p><code>{action=Index}</code> defines <code>Index</code> as the default <code>action</code>.</p>
</li>
<li><p>The <code>?</code> character in <code>{id?}</code> defines <code>id</code> as optional.</p>
</li>
<li><p>Default and optional route parameters don't need to be present in the URL path for a match. See <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-9.0#route-template-reference" data-linktype="relative-path">Route Template Reference</a> for a detailed description of route template syntax.</p>
</li>
<li><p>Matches the URL path <code>/</code>.</p>
</li>
<li><p>Produces the route values <code>{ controller = Home, action = Index }</code>.</p>
</li>
</ul>
<p>The values for <code>controller</code> and <code>action</code> make use of the default values. <code>id</code> doesn't produce a value since there's no corresponding segment in the URL path. <code>/</code> only matches if there exists a <code>HomeController</code> and <code>Index</code> action:</p>
<pre><code class="lang-csharp">public class HomeController : Controller
{
  public IActionResult Index() { ... }
}
</code></pre>
<p>Using the preceding controller definition and route template, the <code>HomeController.Index</code> action is run for the following URL paths:</p>
<ul>
<li><code>/Home/Index/17</code></li>
<li><code>/Home/Index</code></li>
<li><code>/Home</code></li>
<li><code>/</code></li>
</ul>
<p>The URL path <code>/</code> uses the route template default <code>Home</code> controllers and <code>Index</code> action. The URL path <code>/Home</code> uses the route template default <code>Index</code> action.</p>
<p>The convenience method <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapdefaultcontrollerroute" class="no-loc" data-linktype="absolute-path">MapDefaultControllerRoute</a>:</p>
<pre><code class="lang-csharp">endpoints.MapDefaultControllerRoute();
</code></pre>
<p>Replaces:</p>
<pre><code class="lang-csharp">endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
</code></pre>
<div class="IMPORTANT">
<p>Important</p>
<p>Routing is configured using the <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.endpointroutingapplicationbuilderextensions.userouting" class="no-loc" data-linktype="absolute-path">UseRouting</a>, <code>MapControllerRoute</code>, and <code>MapAreaControllerRoute</code> middleware . To use controllers:</p>
<ul>
<li>Call <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapcontrollers" class="no-loc" data-linktype="absolute-path">MapControllers</a> inside <code>UseEndpoints</code> to map <a href="#ar" data-linktype="self-bookmark">attribute routed</a> controllers.</li>
<li>Call <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapcontrollerroute" class="no-loc" data-linktype="absolute-path">MapControllerRoute</a> or <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapareacontrollerroute" class="no-loc" data-linktype="absolute-path">MapAreaControllerRoute</a>, to map both <a href="#cr" data-linktype="self-bookmark">conventionally routed</a> controllers and <a href="#ar" data-linktype="self-bookmark">attribute routed</a> controllers.</li>
</ul>
</div>
<p><a name="routing-conventional-ref-label"></a>
<a name="crd"></a></p>
<h2 id="conventional-routing-1">Conventional routing</h2>
<p>Conventional routing is used with controllers and views. The <code>default</code> route:</p>
<pre><code class="lang-csharp">endpoints.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");
</code></pre>
<p>The preceding is an example of a <em>conventional route</em>. It's called <em>conventional routing</em> because it establishes a <em>convention</em> for URL paths:</p>
<ul>
<li>The first path segment, <code>{controller=Home}</code>, maps to the controller name.</li>
<li>The second segment, <code>{action=Index}</code>, maps to the <a href="#action" data-linktype="self-bookmark">action</a> name.</li>
<li>The third segment, <code>{id?}</code> is used for an optional <code>id</code>. The <code>?</code> in <code>{id?}</code> makes it optional. <code>id</code> is used to map to a model entity.</li>
</ul>
<p>Using this <code>default</code> route, the URL path:</p>
<ul>
<li><code>/Products/List</code> maps to the <code>ProductsController.List</code> action.</li>
<li><code>/Blog/Article/17</code> maps to <code>BlogController.Article</code> and typically model binds the <code>id</code> parameter to 17.</li>
</ul>
<p>This mapping:</p>
<ul>
<li>Is based on the controller and <a href="#action" data-linktype="self-bookmark">action</a> names <strong>only</strong>.</li>
<li>Isn't based on namespaces, source file locations, or method parameters.</li>
</ul>
<p>Using conventional routing with the default route allows creating the app without having to come up with a new URL pattern for each action. For an app with <a href="https://wikipedia.org/wiki/Create,_read,_update_and_delete" data-linktype="external">CRUD</a> style actions, having consistency for the URLs across controllers:</p>
<ul>
<li>Helps simplify the code.</li>
<li>Makes the UI more predictable.</li>
</ul>
<div class="WARNING">
<p>Warning</p>
<p>The <code>id</code> in the preceding code is defined as optional by the route template. Actions can execute without the optional ID provided as part of the URL. Generally, when <code>id</code> is omitted from the URL:</p>
<ul>
<li><code>id</code> is set to <code>0</code> by model binding.</li>
<li>No entity is found in the database matching <code>id == 0</code>.</li>
</ul>
<p><a href="#ar" data-linktype="self-bookmark">Attribute routing</a> provides fine-grained control to make the ID required for some actions and not for others. By convention, the documentation includes optional parameters like <code>id</code> when they're likely to appear in correct usage.</p>
</div>
<p>Most apps should choose a basic and descriptive routing scheme so that URLs are readable and meaningful. The default conventional route <code>{controller=Home}/{action=Index}/{id?}</code>:</p>
<ul>
<li>Supports a basic and descriptive routing scheme.</li>
<li>Is a useful starting point for UI-based apps.</li>
<li>Is the only route template needed for many web UI apps. For larger web UI apps, another route using <a href="#areas" data-linktype="self-bookmark">Areas</a> is frequently all that's needed.</li>
</ul>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapcontrollerroute" class="no-loc" data-linktype="absolute-path">MapControllerRoute</a> and <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.mvcarearoutebuilderextensions.maparearoute" class="no-loc" data-linktype="absolute-path">MapAreaRoute</a> :</p>
<ul>
<li>Automatically assign an <strong>order</strong> value to their endpoints based on the order they are invoked.</li>
</ul>
<p>Endpoint routing in ASP.NET Core 3.0 or later:</p>
<ul>
<li>Doesn't have a concept of routes.</li>
<li>Doesn't provide ordering guarantees for the execution of extensibility,  all endpoints are processed at once.</li>
</ul>
<p>Enable <a href="../../fundamentals/logging/index553c.html?view=aspnetcore-9.0" data-linktype="relative-path">Logging</a> to see how the built-in routing implementations, such as <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.route" class="no-loc" data-linktype="absolute-path">Route</a>, match requests.</p>
<p><a href="#ar" data-linktype="self-bookmark">Attribute routing</a> is explained later in this document.</p>
<p><a name="mr"></a></p>
<h3 id="multiple-conventional-routes-1">Multiple conventional routes</h3>
<p>Multiple <a href="#cr" data-linktype="self-bookmark">conventional routes</a> can be added inside <code>UseEndpoints</code> by adding more calls to <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapcontrollerroute" class="no-loc" data-linktype="absolute-path">MapControllerRoute</a> and <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapareacontrollerroute" class="no-loc" data-linktype="absolute-path">MapAreaControllerRoute</a>. Doing so allows defining multiple conventions, or to adding conventional routes that are dedicated to a specific <a href="#action" data-linktype="self-bookmark">action</a>, such as:</p>
<pre><code class="lang-csharp">app.UseEndpoints(endpoints =&gt;
{
    endpoints.MapControllerRoute(name: "blog",
                pattern: "blog/{*article}",
                defaults: new { controller = "Blog", action = "Article" });
    endpoints.MapControllerRoute(name: "default",
                pattern: "{controller=Home}/{action=Index}/{id?}");
});
</code></pre>
<p><a name="dcr"></a></p>
<p>The <code>blog</code> route in the preceding code is a <strong>dedicated conventional route</strong>. It's called a dedicated conventional route because:</p>
<ul>
<li>It uses <a href="#cr" data-linktype="self-bookmark">conventional routing</a>.</li>
<li>It's dedicated to a specific <a href="#action" data-linktype="self-bookmark">action</a>.</li>
</ul>
<p>Because <code>controller</code> and <code>action</code> don't appear in the route template <code>"blog/{*article}"</code> as parameters:</p>
<ul>
<li>They can only have the default values <code>{ controller = "Blog", action = "Article" }</code>.</li>
<li>This route always maps to the action <code>BlogController.Article</code>.</li>
</ul>
<p><code>/Blog</code>, <code>/Blog/Article</code>, and <code>/Blog/{any-string}</code> are the only URL paths that match the blog route.</p>
<p>The preceding example:</p>
<ul>
<li><code>blog</code> route has a higher priority for matches than the <code>default</code> route because it is added first.</li>
<li>Is an example of <a href="https://developer.mozilla.org/docs/Glossary/Slug" data-linktype="external">Slug</a> style routing where it's typical to have an article name as part of the URL.</li>
</ul>
<div class="WARNING">
<p>Warning</p>
<p>In ASP.NET Core 3.0 or later, routing doesn't:</p>
<ul>
<li>Define a concept called a <em>route</em>. <code>UseRouting</code> adds route matching to the middleware pipeline. The <code>UseRouting</code> middleware looks at the set of endpoints defined in the app, and selects the best endpoint match based on the request.</li>
<li>Provide guarantees about the execution order of extensibility like <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouteconstraint" class="no-loc" data-linktype="absolute-path">IRouteConstraint</a> or <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.actionconstraints.iactionconstraint" class="no-loc" data-linktype="absolute-path">IActionConstraint</a>.</li>
</ul>
<p>See <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-9.0" data-linktype="relative-path">Routing</a> for reference material on routing.</p>
</div>
<p><a name="cro"></a></p>
<h3 id="conventional-routing-order-1">Conventional routing order</h3>
<p>Conventional routing only matches a combination of action and controller that are defined by the app. This is intended to simplify cases where conventional routes overlap.
Adding routes using <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapcontrollerroute" class="no-loc" data-linktype="absolute-path">MapControllerRoute</a>, <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapdefaultcontrollerroute" class="no-loc" data-linktype="absolute-path">MapDefaultControllerRoute</a>, and <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapareacontrollerroute" class="no-loc" data-linktype="absolute-path">MapAreaControllerRoute</a> automatically assign an order value to their endpoints based on the order they are invoked. Matches from a route that appears earlier have a higher priority. Conventional routing is order-dependent. In general, routes with areas should be placed earlier as they're more specific than routes without an area. <a href="#dcr" data-linktype="self-bookmark">Dedicated conventional routes</a> with catch-all route parameters like <code>{*article}</code> can make a route too <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-9.0#greedy" data-linktype="relative-path">greedy</a>, meaning that it matches URLs that you intended to be matched by other routes. Put the greedy routes later in the route table to prevent greedy matches.</p>
<div data-moniker="aspnetcore-3.0 aspnetcore-3.1">
<div class="WARNING">
<p>Warning</p>
<p>A <strong>catch-all</strong> parameter may match routes incorrectly due to a <a href="https://github.com/dotnet/aspnetcore/issues/18677" data-linktype="external">bug</a> in routing. Apps impacted by this bug have the following characteristics:</p>
<ul>
<li>A catch-all route, for example, <code>{**slug}"</code></li>
<li>The catch-all route fails to match requests it should match.</li>
<li>Removing other routes makes catch-all route start working.</li>
</ul>
<p>See GitHub bugs <a href="https://github.com/dotnet/aspnetcore/issues/18677" data-linktype="external">18677</a> and <a href="https://github.com/dotnet/aspnetcore/issues/16579" data-linktype="external">16579</a> for example cases that hit this bug.</p>
<p>An opt-in fix for this bug is contained in <a href="https://dotnet.microsoft.com/download/dotnet-core/3.1" data-linktype="external">.NET Core 3.1.301 or later SDK</a>. The following code sets an internal switch that fixes this bug:</p>
<pre><code class="lang-csharp">public static void Main(string[] args)
{
   AppContext.SetSwitch("Microsoft.AspNetCore.Routing.UseCorrectCatchAllBehavior", 
                         true);
   CreateHostBuilder(args).Build().Run();
}
// Remaining code removed for brevity.
</code></pre>
</div>
</div>
<p><a name="best"></a></p>
<h3 id="resolving-ambiguous-actions-1">Resolving ambiguous actions</h3>
<p>When two endpoints match through routing, routing must do one of the following:</p>
<ul>
<li>Choose the best candidate.</li>
<li>Throw an exception.</li>
</ul>
<p>For example:</p>
<pre><code class="lang-csharp">    public class Products33Controller : Controller
    {
        public IActionResult Edit(int id)
        {
            return ControllerContext.MyDisplayRouteInfo(id);
        }

        [HttpPost]
        public IActionResult Edit(int id, Product product)
        {
            return ControllerContext.MyDisplayRouteInfo(id, product.name);
        }
    }
}

</code></pre>
<p>The preceding controller defines two actions that match:</p>
<ul>
<li>The URL path <code>/Products33/Edit/17</code></li>
<li>Route data <code>{ controller = Products33, action = Edit, id = 17 }</code>.</li>
</ul>
<p>This is a typical pattern for MVC controllers:</p>
<ul>
<li><code>Edit(int)</code> displays a form to edit a product.</li>
<li><code>Edit(int, Product)</code> processes  the posted form.</li>
</ul>
<p>To resolve the correct route:</p>
<ul>
<li><code>Edit(int, Product)</code> is selected when the request is an HTTP <code>POST</code>.</li>
<li><code>Edit(int)</code> is selected when the <a href="#verb" data-linktype="self-bookmark">HTTP verb</a> is anything else. <code>Edit(int)</code> is generally called via <code>GET</code>.</li>
</ul>
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.httppostattribute" class="no-loc" data-linktype="absolute-path">HttpPostAttribute</a>, <code>[HttpPost]</code>, is provided to routing so that it can choose based on the HTTP method of the request. The <code>HttpPostAttribute</code> makes <code>Edit(int, Product)</code> a better match than <code>Edit(int)</code>.</p>
<p>It's important to understand the role of attributes like <code>HttpPostAttribute</code>. Similar attributes are defined for other <a href="#verb" data-linktype="self-bookmark">HTTP verbs</a>. In <a href="#cr" data-linktype="self-bookmark">conventional routing</a>, it's common for actions to use the same action name when they're part of a show form, submit form workflow. For example, see <a href="https://learn.microsoft.com/en-us/aspnet/core/tutorials/first-mvc-app/controller-methods-views?view=aspnetcore-9.0#get-post" data-linktype="relative-path">Examine the two Edit action methods</a>.</p>
<p>If routing can't choose a best candidate, an <a href="https://learn.microsoft.com/en-us/dotnet/api/system.reflection.ambiguousmatchexception" class="no-loc" data-linktype="absolute-path">AmbiguousMatchException</a> is thrown, listing the multiple matched endpoints.</p>
<p><a name="routing-route-name-ref-label"></a></p>
<h3 id="conventional-route-names-1">Conventional route names</h3>
<p>The strings  <code>"blog"</code> and <code>"default"</code> in the following examples are conventional route names:</p>
<pre><code class="lang-csharp">app.UseEndpoints(endpoints =&gt;
{
    endpoints.MapControllerRoute(name: "blog",
                pattern: "blog/{*article}",
                defaults: new { controller = "Blog", action = "Article" });
    endpoints.MapControllerRoute(name: "default",
                pattern: "{controller=Home}/{action=Index}/{id?}");
});
</code></pre>
<p>The route names give the route a logical name. The named route can be used for URL generation. Using a named route simplifies URL creation when the ordering of routes could make URL generation complicated. Route names must be unique application wide.</p>
<p>Route names:</p>
<ul>
<li>Have no impact on URL matching or handling of requests.</li>
<li>Are used only for URL generation.</li>
</ul>
<p>The route name concept is represented in routing as <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.iendpointnamemetadata" data-linktype="absolute-path">IEndpointNameMetadata</a>. The terms <strong>route name</strong> and <strong>endpoint name</strong>:</p>
<ul>
<li>Are interchangeable.</li>
<li>Which one is used in documentation and code depends on the API being described.</li>
</ul>
<p><a name="attribute-routing-ref-label"></a>
<a name="ar"></a></p>
<h2 id="attribute-routing-for-rest-apis-1">Attribute routing for REST APIs</h2>
<p>REST APIs should use attribute routing to model the app's functionality as a set of resources where operations are represented by <a href="#verb" data-linktype="self-bookmark">HTTP verbs</a>.</p>
<p>Attribute routing uses a set of attributes to map actions directly to route templates. The following <code>StartUp.Configure</code> code is typical for a REST API and is used in the next sample:</p>
<pre><code class="lang-csharp">public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}

public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }

    app.UseHttpsRedirection();

    app.UseRouting();

    app.UseAuthorization();

    app.UseEndpoints(endpoints =&gt;
    {
        endpoints.MapControllers();
    });
}
</code></pre>
<p>In the preceding code, <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapcontrollers" class="no-loc" data-linktype="absolute-path">MapControllers</a> is called inside <code>UseEndpoints</code> to map attribute routed controllers.</p>
<p>In the following example:</p>
<ul>
<li><code>HomeController</code> matches a set of URLs similar to what the default conventional route <code>{controller=Home}/{action=Index}/{id?}</code> matches.</li>
</ul>
<pre><code class="lang-csharp">public class HomeController : Controller
{
    [Route("")]
    [Route("Home")]
    [Route("Home/Index")]
    [Route("Home/Index/{id?}")]
    public IActionResult Index(int? id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }

    [Route("Home/About")]
    [Route("Home/About/{id?}")]
    public IActionResult About(int? id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
</code></pre>
<p>The <code>HomeController.Index</code> action is run for any of the URL paths <code>/</code>, <code>/Home</code>, <code>/Home/Index</code>, or <code>/Home/Index/3</code>.</p>
<p>This example highlights a key programming difference between attribute routing and <a href="#cr" data-linktype="self-bookmark">conventional routing</a>. Attribute routing requires more input to specify a route. The conventional default route handles routes more succinctly. However, attribute routing allows and requires precise control of which route templates apply to each <a href="#action" data-linktype="self-bookmark">action</a>.</p>
<p>With attribute routing, the controller and action names play no part in which action is matched, unless <a href="#routing-token-replacement-templates-ref-label" data-linktype="self-bookmark">token replacement</a> is used. The following example matches the same URLs as the previous example:</p>
<pre><code class="lang-csharp">public class MyDemoController : Controller
{
    [Route("")]
    [Route("Home")]
    [Route("Home/Index")]
    [Route("Home/Index/{id?}")]
    public IActionResult MyIndex(int? id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }

    [Route("Home/About")]
    [Route("Home/About/{id?}")]
    public IActionResult MyAbout(int? id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
</code></pre>
<p>The following code uses token replacement for <code>action</code> and <code>controller</code>:</p>
<pre><code class="lang-csharp">public class HomeController : Controller
{
    [Route("")]
    [Route("Home")]
    [Route("[controller]/[action]")]
    public IActionResult Index()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }

    [Route("[controller]/[action]")]
    public IActionResult About()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }
}
</code></pre>
<p>The following code applies <code>[Route("[controller]/[action]")]</code> to the controller:</p>
<pre><code class="lang-csharp">[Route("[controller]/[action]")]
public class HomeController : Controller
{
    [Route("~/")]
    [Route("/Home")]
    [Route("~/Home/Index")]
    public IActionResult Index()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }

    public IActionResult About()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }
}
</code></pre>
<p>In the preceding code, the <code>Index</code> method templates must prepend <code>/</code> or <code>~/</code> to the route templates. Route templates applied to an action that begin with <code>/</code> or <code>~/</code> don't get combined with route templates applied to the controller.</p>
<p>See <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-9.0#rtp" data-linktype="relative-path">Route template precedence</a> for information on route template selection.</p>
<h2 id="reserved-routing-names-1">Reserved routing names</h2>
<p>The following keywords are reserved route parameter names when using Controllers or Razor Pages:</p>
<ul>
<li><code>action</code></li>
<li><code>area</code></li>
<li><code>controller</code></li>
<li><code>handler</code></li>
<li><code>page</code></li>
</ul>
<p>Using <code>page</code> as a route parameter with attribute routing is a common error. Doing that results in inconsistent and confusing behavior with URL generation.</p>
<pre><code class="lang-csharp">public class MyDemo2Controller : Controller
{
    [Route("/articles/{page}")]
    public IActionResult ListArticles(int page)
    {
        return ControllerContext.MyDisplayRouteInfo(page);
    }
}
</code></pre>
<p>The special parameter names are used by the URL generation to determine if a URL generation operation refers to a Razor Page or to a Controller.</p>
<p>The following keywords are reserved in the context of a Razor view or a Razor Page:</p>
<ul>
<li><code>page</code></li>
<li><code>using</code></li>
<li><code>namespace</code></li>
<li><code>inject</code></li>
<li><code>section</code></li>
<li><code>inherits</code></li>
<li><code>model</code></li>
<li><code>addTagHelper</code></li>
<li><code>removeTagHelper</code></li>
</ul>
<p>These keywords shouldn't be used for link generations, model bound parameters, or top level properties.</p>
<p><a name="verb"></a></p>
<h2 id="http-verb-templates-1">HTTP verb templates</h2>
<p>ASP.NET Core has the following HTTP verb templates:</p>
<ul>
<li><a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.httpgetattribute" data-linktype="absolute-path">[HttpGet]</a></li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.httppostattribute" data-linktype="absolute-path">[HttpPost]</a></li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.httpputattribute" data-linktype="absolute-path">[HttpPut]</a></li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.httpdeleteattribute" data-linktype="absolute-path">[HttpDelete]</a></li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.httpheadattribute" data-linktype="absolute-path">[HttpHead]</a></li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.httppatchattribute" data-linktype="absolute-path">[HttpPatch]</a></li>
</ul>
<p><a name="rt"></a></p>
<h3 id="route-templates-1">Route templates</h3>
<p>ASP.NET Core has the following route templates:</p>
<ul>
<li>All the <a href="#verb" data-linktype="self-bookmark">HTTP verb templates</a> are route templates.</li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.routeattribute" data-linktype="absolute-path">[Route]</a></li>
</ul>
<p><a name="arx"></a></p>
<h3 id="attribute-routing-with-http-verb-attributes-1">Attribute routing with Http verb attributes</h3>
<p>Consider the following controller:</p>
<pre><code class="lang-csharp">[Route("api/[controller]")]
[ApiController]
public class Test2Controller : ControllerBase
{
    [HttpGet]   // GET /api/test2
    public IActionResult ListProducts()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }

    [HttpGet("{id}")]   // GET /api/test2/xyz
    public IActionResult GetProduct(string id)
    {
       return ControllerContext.MyDisplayRouteInfo(id);
    }

    [HttpGet("int/{id:int}")] // GET /api/test2/int/3
    public IActionResult GetIntProduct(int id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }

    [HttpGet("int2/{id}")]  // GET /api/test2/int2/3
    public IActionResult GetInt2Product(int id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
</code></pre>
<p>In the preceding code:</p>
<ul>
<li>Each action contains the <code>[HttpGet]</code> attribute, which constrains matching to HTTP GET requests only.</li>
<li>The <code>GetProduct</code> action includes the <code>"{id}"</code> template, therefore <code>id</code> is appended to the <code>"api/[controller]"</code> template on the controller. The methods template is <code>"api/[controller]/{id}"</code>. Therefore this action only matches GET requests for the form <code>/api/test2/xyz</code>,<code>/api/test2/123</code>,<code>/api/test2/{any string}</code>, etc.<pre><code class="lang-csharp">[HttpGet("{id}")]   // GET /api/test2/xyz
public IActionResult GetProduct(string id)
{
   return ControllerContext.MyDisplayRouteInfo(id);
}
</code></pre></li>
<li>The <code>GetIntProduct</code> action contains the <code>"int/{id:int}"</code> template. The <code>:int</code> portion of the template constrains the <code>id</code> route values to strings that can be converted to an integer. A GET request to <code>/api/test2/int/abc</code>:
<ul>
<li>Doesn't match this action.</li>
<li>Returns a <a href="https://developer.mozilla.org/docs/Web/HTTP/Status/404" data-linktype="external">404 Not Found</a> error.<pre><code class="lang-csharp">[HttpGet("int/{id:int}")] // GET /api/test2/int/3
public IActionResult GetIntProduct(int id)
{
    return ControllerContext.MyDisplayRouteInfo(id);
}
</code></pre></li>
</ul>
</li>
<li>The <code>GetInt2Product</code> action contains <code>{id}</code> in the template, but doesn't constrain <code>id</code> to values that can be converted to an integer. A GET request to <code>/api/test2/int2/abc</code>:
<ul>
<li>Matches this route.</li>
<li>Model binding fails to convert <code>abc</code> to an integer. The <code>id</code> parameter of the method is integer.</li>
<li>Returns a <a href="https://developer.mozilla.org/docs/Web/HTTP/Status/400" data-linktype="external">400 Bad Request</a> because model binding failed to convert <code>abc</code> to an integer.<pre><code class="lang-csharp">[HttpGet("int2/{id}")]  // GET /api/test2/int2/3
public IActionResult GetInt2Product(int id)
{
    return ControllerContext.MyDisplayRouteInfo(id);
}
</code></pre></li>
</ul>
</li>
</ul>
<p>Attribute routing can use <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.routing.httpmethodattribute" class="no-loc" data-linktype="absolute-path">HttpMethodAttribute</a> attributes such as <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.httppostattribute" class="no-loc" data-linktype="absolute-path">HttpPostAttribute</a>, <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.httpputattribute" class="no-loc" data-linktype="absolute-path">HttpPutAttribute</a>, and <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.httpdeleteattribute" class="no-loc" data-linktype="absolute-path">HttpDeleteAttribute</a>. All of the <a href="#verb" data-linktype="self-bookmark">HTTP verb</a> attributes accept a route template. The following example shows two actions that match the same route template:</p>
<pre><code class="lang-csharp">[ApiController]
public class MyProductsController : ControllerBase
{
    [HttpGet("/products3")]
    public IActionResult ListProducts()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }

    [HttpPost("/products3")]
    public IActionResult CreateProduct(MyProduct myProduct)
    {
        return ControllerContext.MyDisplayRouteInfo(myProduct.Name);
    }
}
</code></pre>
<p>Using the URL path <code>/products3</code>:</p>
<ul>
<li>The <code>MyProductsController.ListProducts</code> action runs when the <a href="#verb" data-linktype="self-bookmark">HTTP verb</a> is <code>GET</code>.</li>
<li>The <code>MyProductsController.CreateProduct</code> action runs when the <a href="#verb" data-linktype="self-bookmark">HTTP verb</a> is <code>POST</code>.</li>
</ul>
<p>When building a REST API, it's rare that you'll need to use <code>[Route(...)]</code> on an action method because the action accepts all HTTP methods. It's better to use the more specific <a href="#verb" data-linktype="self-bookmark">HTTP verb attribute</a> to be precise about what your API supports. Clients of REST APIs are expected to know what paths and HTTP verbs map to specific logical operations.</p>
<p>REST APIs should use attribute routing to model the app's functionality as a set of resources where operations are represented by HTTP verbs. This means that many operations, for example, GET and POST on the same logical resource use the same URL. Attribute routing provides a level of control that's needed to carefully design an API's public endpoint layout.</p>
<p>Since an attribute route applies to a specific action, it's easy to make parameters required as part of the route template definition. In the following example, <code>id</code> is required as part of the URL path:</p>
<pre><code class="lang-csharp">[ApiController]
public class Products2ApiController : ControllerBase
{
    [HttpGet("/products2/{id}", Name = "Products_List")]
    public IActionResult GetProduct(int id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
</code></pre>
<p>The <code>Products2ApiController.GetProduct(int)</code> action:</p>
<ul>
<li>Is run with URL path like <code>/products2/3</code></li>
<li>Isn't run with the URL path <code>/products2</code>.</li>
</ul>
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.consumesattribute" data-linktype="absolute-path">[Consumes]</a> attribute allows an action to limit the supported request content types. For more information, see <a href="https://learn.microsoft.com/en-us/aspnet/core/web-api/?view=aspnetcore-9.0#consumes" data-linktype="relative-path">Define supported request content types with the Consumes attribute</a>.</p>
<p>See <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-9.0" data-linktype="relative-path">Routing</a> for a full description of route templates and related options.</p>
<p>For more information on <code>[ApiController]</code>, see <a href="https://learn.microsoft.com/en-us/aspnet/core/web-api/?view=aspnetcore-9.0##apicontroller-attribute" data-linktype="relative-path">ApiController attribute</a>.</p>
<h2 id="route-name-1">Route name</h2>
<p>The following code  defines a route name of <code>Products_List</code>:</p>
<pre><code class="lang-csharp">[ApiController]
public class Products2ApiController : ControllerBase
{
    [HttpGet("/products2/{id}", Name = "Products_List")]
    public IActionResult GetProduct(int id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
</code></pre>
<p>Route names can be used to generate a URL based on a specific route. Route names:</p>
<ul>
<li>Have no impact on the URL matching behavior of routing.</li>
<li>Are only used for URL generation.</li>
</ul>
<p>Route names must be unique application-wide.</p>
<p>Contrast the preceding code with the conventional default route, which defines the <code>id</code> parameter as optional (<code>{id?}</code>). The ability to precisely specify APIs has advantages, such as  allowing <code>/products</code> and <code>/products/5</code> to be dispatched to different actions.</p>
<p><a name="routing-combining-ref-label"></a></p>
<h2 id="combining-attribute-routes-1">Combining attribute routes</h2>
<p>To make attribute routing less repetitive, route attributes on the controller are combined with route attributes on the individual actions. Any route templates defined on the controller are prepended to route templates on the actions. Placing a route attribute on the controller makes <strong>all</strong> actions in the controller use attribute routing.</p>
<pre><code class="lang-csharp">[ApiController]
[Route("products")]
public class ProductsApiController : ControllerBase
{
    [HttpGet]
    public IActionResult ListProducts()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }

    [HttpGet("{id}")]
    public IActionResult GetProduct(int id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
</code></pre>
<p>In the preceding example:</p>
<ul>
<li>The URL path <code>/products</code> can match <code>ProductsApi.ListProducts</code></li>
<li>The URL path <code>/products/5</code> can match <code>ProductsApi.GetProduct(int)</code>.</li>
</ul>
<p>Both of these actions only match HTTP <code>GET</code> because they're marked with the <code>[HttpGet]</code> attribute.</p>
<p>Route templates applied to an action that begin with <code>/</code> or <code>~/</code> don't get combined with route templates applied to the controller. The following example matches a set of URL paths similar to the default route.</p>
<pre><code class="lang-csharp">[Route("Home")]
public class HomeController : Controller
{
    [Route("")]
    [Route("Index")]
    [Route("/")]
    public IActionResult Index()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }

    [Route("About")]
    public IActionResult About()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }
}
</code></pre>
<p>The following table explains the <code>[Route]</code> attributes in the preceding code:</p>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Combines with <code>[Route("Home")]</code></th>
<th>Defines route template</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[Route("")]</code></td>
<td>Yes</td>
<td><code>"Home"</code></td>
</tr>
<tr>
<td><code>[Route("Index")]</code></td>
<td>Yes</td>
<td><code>"Home/Index"</code></td>
</tr>
<tr>
<td><code>[Route("/")]</code></td>
<td><strong>No</strong></td>
<td><code>""</code></td>
</tr>
<tr>
<td><code>[Route("About")]</code></td>
<td>Yes</td>
<td><code>"Home/About"</code></td>
</tr>
</tbody>
</table>
<p><a name="routing-ordering-ref-label"></a>
<a name="oar"></a></p>
<h3 id="attribute-route-order-1">Attribute route order</h3>
<p>Routing builds a tree and matches all endpoints simultaneously:</p>
<ul>
<li>The route entries behave as if placed in an ideal ordering.</li>
<li>The most specific routes have a chance to execute before the more general routes.</li>
</ul>
<p>For example, an attribute route like <code>blog/search/{topic}</code> is more specific than an attribute route like <code>blog/{*article}</code>. The <code>blog/search/{topic}</code> route has higher priority, by default, because it's more specific. Using <a href="#cr" data-linktype="self-bookmark">conventional routing</a>, the developer is responsible for placing routes in the desired order.</p>
<p>Attribute routes can configure an order using the <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.routeattribute.order#microsoft-aspnetcore-mvc-routeattribute-order" class="no-loc" data-linktype="absolute-path">Order</a> property. All of the framework provided <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.routeattribute" data-linktype="absolute-path">route attributes</a> include <code>Order</code> . Routes are processed according to an ascending sort of the <code>Order</code> property. The default order is <code>0</code>. Setting a route using <code>Order = -1</code> runs before routes that don't set an order. Setting a route using <code>Order = 1</code> runs after default route ordering.</p>
<p><strong>Avoid</strong> depending on <code>Order</code>. If an app's URL-space requires explicit order values to route correctly, then it's likely confusing to clients as well. In general, attribute routing selects the correct route with URL matching. If the default order used for URL generation isn't working, using a route name as an override is usually simpler than applying the <code>Order</code> property.</p>
<p>Consider the following two controllers which both define the route matching <code>/home</code>:</p>
<pre><code class="lang-csharp">public class HomeController : Controller
{
    [Route("")]
    [Route("Home")]
    [Route("Home/Index")]
    [Route("Home/Index/{id?}")]
    public IActionResult Index(int? id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }

    [Route("Home/About")]
    [Route("Home/About/{id?}")]
    public IActionResult About(int? id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
</code></pre><pre><code class="lang-csharp">public class MyDemoController : Controller
{
    [Route("")]
    [Route("Home")]
    [Route("Home/Index")]
    [Route("Home/Index/{id?}")]
    public IActionResult MyIndex(int? id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }

    [Route("Home/About")]
    [Route("Home/About/{id?}")]
    public IActionResult MyAbout(int? id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
</code></pre>
<p>Requesting <code>/home</code> with the preceding code throws an exception similar to the following:</p>
<pre><code class="lang-text">AmbiguousMatchException: The request matched multiple endpoints. Matches:

 WebMvcRouting.Controllers.HomeController.Index
 WebMvcRouting.Controllers.MyDemoController.MyIndex
</code></pre>
<p>Adding <code>Order</code> to one of the route attributes resolves the ambiguity:</p>
<pre><code class="lang-csharp">[Route("")]
[Route("Home", Order = 2)]
[Route("Home/MyIndex")]
public IActionResult MyIndex()
{
    return ControllerContext.MyDisplayRouteInfo();
}
</code></pre>
<p>With the preceding code, <code>/home</code> runs the <code>HomeController.Index</code> endpoint. To get to the <code>MyDemoController.MyIndex</code>, request <code>/home/MyIndex</code>. <strong>Note</strong>:</p>
<ul>
<li>The preceding code is an example or poor routing design. It was used to illustrate the <code>Order</code> property.</li>
<li>The <code>Order</code> property only resolves the ambiguity, that template cannot be matched. It would be better to remove the <code>[Route("Home")]</code> template.</li>
</ul>
<p>See <a href="https://learn.microsoft.com/en-us/aspnet/core/razor-pages/razor-pages-conventions?view=aspnetcore-9.0#route-order" data-linktype="relative-path">Razor Pages route and app conventions: Route order</a> for information on route order with Razor Pages.</p>
<p>In some cases, an HTTP 500 error is returned with ambiguous routes. Use <a href="../../fundamentals/logging/index553c.html?view=aspnetcore-9.0" data-linktype="relative-path">logging</a> to see which endpoints caused the <code>AmbiguousMatchException</code>.</p>
<p><a name="routing-token-replacement-templates-ref-label"></a></p>
<h2 id="token-replacement-in-route-templates-controller-action-area-1">Token replacement in route templates [controller], [action], [area]</h2>
<p>For convenience, attribute routes support <em>token replacement</em> by enclosing a token in square-brackets (<code>[</code>, <code>]</code>). The tokens <code>[action]</code>, <code>[area]</code>, and <code>[controller]</code> are replaced with the values of the action name, area name, and controller name from the action where the route is defined:</p>
<pre><code class="lang-csharp">[Route("[controller]/[action]")]
public class Products0Controller : Controller
{
    [HttpGet]
    public IActionResult List()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }


    [HttpGet("{id}")]
    public IActionResult Edit(int id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
</code></pre>
<p>In the preceding code:</p>
<pre><code class="lang-csharp">[HttpGet]
public IActionResult List()
{
    return ControllerContext.MyDisplayRouteInfo();
}
</code></pre>
<ul>
<li>Matches <code>/Products0/List</code></li>
</ul>
<pre><code class="lang-csharp">[HttpGet("{id}")]
public IActionResult Edit(int id)
{
    return ControllerContext.MyDisplayRouteInfo(id);
}
</code></pre>
<ul>
<li>Matches <code>/Products0/Edit/{id}</code></li>
</ul>
<p>Token replacement occurs as the last step of building the attribute routes. The preceding example behaves the same as the following code:</p>
<pre><code class="lang-csharp">public class Products20Controller : Controller
{
    [HttpGet("[controller]/[action]")]  // Matches '/Products20/List'
    public IActionResult List()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }

    [HttpGet("[controller]/[action]/{id}")]   // Matches '/Products20/Edit/{id}'
    public IActionResult Edit(int id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
</code></pre><p>If you are reading this in a language other than English, let us know in this <a href="https://github.com/dotnet/AspNetCore.Docs/issues/16455" data-linktype="external">GitHub discussion issue</a> if you'd like to see the code comments in your native language.</p>
<p>Attribute routes can also be combined with inheritance. This is powerful combined with token replacement. Token replacement also applies to route names defined by attribute routes.
<code>[Route("[controller]/[action]", Name="[controller]_[action]")]</code>generates a unique route name for each action:</p>
<pre><code class="lang-csharp">[ApiController]
[Route("api/[controller]/[action]", Name = "[controller]_[action]")]
public abstract class MyBase2Controller : ControllerBase
{
}

public class Products11Controller : MyBase2Controller
{
    [HttpGet]                      // /api/products11/list
    public IActionResult List()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }

    [HttpGet("{id}")]             //    /api/products11/edit/3
    public IActionResult Edit(int id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
</code></pre>
<p>To match the literal token replacement delimiter <code>[</code> or  <code>]</code>, escape it by repeating the character (<code>[[</code> or <code>]]</code>).</p>
<p><a name="routing-token-replacement-transformers-ref-label"></a></p>
<h3 id="use-a-parameter-transformer-to-customize-token-replacement-1">Use a parameter transformer to customize token replacement</h3>
<p>Token replacement can be customized using a parameter transformer. A parameter transformer implements <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.ioutboundparametertransformer" class="no-loc" data-linktype="absolute-path">IOutboundParameterTransformer</a> and transforms the value of parameters. For example, a custom <code>SlugifyParameterTransformer</code> parameter transformer changes the <code>SubscriptionManagement</code> route value to <code>subscription-management</code>:</p>
<pre><code class="lang-csharp">public class SlugifyParameterTransformer : IOutboundParameterTransformer
{
    public string TransformOutbound(object value)
    {
        if (value == null) { return null; }

        return Regex.Replace(value.ToString(),
                             "([a-z])([A-Z])",
                             "$1-$2",
                             RegexOptions.CultureInvariant,
                             TimeSpan.FromMilliseconds(100)).ToLowerInvariant();
    }
}
</code></pre>
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.applicationmodels.routetokentransformerconvention" class="no-loc" data-linktype="absolute-path">RouteTokenTransformerConvention</a> is an application model convention that:</p>
<ul>
<li>Applies a parameter transformer to all attribute routes in an application.</li>
<li>Customizes the attribute route token values as they are replaced.</li>
</ul>
<pre><code class="lang-csharp">public class SubscriptionManagementController : Controller
{
    [HttpGet("[controller]/[action]")]
    public IActionResult ListAll()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }
}
</code></pre>
<p>The preceding <code>ListAll</code> method matches <code>/subscription-management/list-all</code>.</p>
<p>The <code>RouteTokenTransformerConvention</code> is registered as an option in <code>ConfigureServices</code>.</p>
<pre><code class="lang-csharp">public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews(options =&gt;
    {
        options.Conventions.Add(new RouteTokenTransformerConvention(
                                     new SlugifyParameterTransformer()));
    });
}
</code></pre>
<p>See <a href="https://developer.mozilla.org/docs/Glossary/Slug" data-linktype="external">MDN web docs on Slug</a> for the definition of Slug.</p>
<div class="WARNING">
<p>Warning</p>
<p>When using <a href="https://learn.microsoft.com/en-us/dotnet/api/system.text.regularexpressions" class="no-loc" data-linktype="absolute-path">System.Text.RegularExpressions</a> to process untrusted input, pass a timeout. A malicious user can provide input to <code>RegularExpressions</code> causing a <a href="https://www.cisa.gov/news-events/news/understanding-denial-service-attacks" data-linktype="external">Denial-of-Service attack</a>. ASP.NET Core framework APIs that use <code>RegularExpressions</code> pass a timeout.</p>
</div>
<p><a name="routing-multiple-routes-ref-label"></a></p>
<h3 id="multiple-attribute-routes-1">Multiple attribute routes</h3>
<p>Attribute routing supports defining multiple routes that reach the same action. The most common usage of this is to mimic the behavior of the default conventional route as shown in the following example:</p>
<pre><code class="lang-csharp">[Route("[controller]")]
public class Products13Controller : Controller
{
    [Route("")]     // Matches 'Products13'
    [Route("Index")] // Matches 'Products13/Index'
    public IActionResult Index()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }
</code></pre>
<p>Putting multiple route attributes on the controller means that each one combines with each of the route attributes on the action methods:</p>
<pre><code class="lang-csharp">[Route("Store")]
[Route("[controller]")]
public class Products6Controller : Controller
{
    [HttpPost("Buy")]       // Matches 'Products6/Buy' and 'Store/Buy'
    [HttpPost("Checkout")]  // Matches 'Products6/Checkout' and 'Store/Checkout'
    public IActionResult Buy()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }
}
</code></pre>
<p>All the <a href="#verb" data-linktype="self-bookmark">HTTP verb</a> route constraints implement <code>IActionConstraint</code>.</p>
<p>When multiple route attributes that implement <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.actionconstraints.iactionconstraint" class="no-loc" data-linktype="absolute-path">IActionConstraint</a> are placed on an action:</p>
<ul>
<li>Each action constraint combines with the route template applied to the controller.</li>
</ul>
<pre><code class="lang-csharp">[Route("api/[controller]")]
public class Products7Controller : ControllerBase
{
    [HttpPut("Buy")]        // Matches PUT 'api/Products7/Buy'
    [HttpPost("Checkout")]  // Matches POST 'api/Products7/Checkout'
    public IActionResult Buy()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }
}
</code></pre>
<p>Using multiple routes on actions might seem useful and powerful, it's better to keep your app's URL space basic and well defined. Use multiple routes on actions <strong>only</strong> where needed, for example, to support existing clients.</p>
<p><a name="routing-attr-options"></a></p>
<h3 id="specifying-attribute-route-optional-parameters-default-values-and-constraints-1">Specifying attribute route optional parameters, default values, and constraints</h3>
<p>Attribute routes support the same inline syntax as conventional routes to specify optional parameters, default values, and constraints.</p>
<pre><code class="lang-csharp" highlight-lines="3">public class Products14Controller : Controller
{
    [HttpPost("product14/{id:int}")]
    public IActionResult ShowProduct(int id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
</code></pre>
<p>In the preceding code, <code>[HttpPost("product14/{id:int}")]</code> applies a route constraint. The <code>Products14Controller.ShowProduct</code> action is matched only by URL paths like <code>/product14/3</code>. The route template portion <code>{id:int}</code> constrains that segment to only integers.</p>
<p>See <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-9.0#route-template-reference" data-linktype="relative-path">Route Template Reference</a> for a detailed description of route template syntax.</p>
<p><a name="routing-cust-rt-attr-irt-ref-label"></a></p>
<h3 id="custom-route-attributes-using-iroutetemplateprovider-1">Custom route attributes using IRouteTemplateProvider</h3>
<p>All of the <a href="#rt" data-linktype="self-bookmark">route attributes</a> implement <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.routing.iroutetemplateprovider" class="no-loc" data-linktype="absolute-path">IRouteTemplateProvider</a>. The ASP.NET Core runtime:</p>
<ul>
<li>Looks for attributes on controller classes and action methods when the app starts.</li>
<li>Uses the attributes that implement <code>IRouteTemplateProvider</code> to build the initial set of routes.</li>
</ul>
<p>Implement <code>IRouteTemplateProvider</code> to define custom route attributes. Each <code>IRouteTemplateProvider</code> allows you to define a single route with a custom route template, order, and name:</p>
<pre><code class="lang-csharp" highlight-lines="1-10">public class MyApiControllerAttribute : Attribute, IRouteTemplateProvider
{
    public string Template =&gt; "api/[controller]";
    public int? Order =&gt; 2;
    public string Name { get; set; }
}

[MyApiController]
[ApiController]
public class MyTestApiController : ControllerBase
{
    // GET /api/MyTestApi
    [HttpGet]
    public IActionResult Get()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }
}
</code></pre>
<p>The preceding <code>Get</code> method returns <code>Order = 2, Template = api/MyTestApi</code>.</p>
<p><a name="routing-app-model-ref-label"></a></p>
<h3 id="use-application-model-to-customize-attribute-routes-1">Use application model to customize attribute routes</h3>
<p>The application model:</p>
<ul>
<li>Is an object model created at startup.</li>
<li>Contains all of the metadata used by ASP.NET Core to route and execute the actions in an app.</li>
</ul>
<p>The application model includes all of the data gathered from route attributes. The data from route attributes is provided by the <code>IRouteTemplateProvider</code> implementation. Conventions:</p>
<ul>
<li>Can be written to modify the application model to customize how routing behaves.</li>
<li>Are read at app startup.</li>
</ul>
<p>This section shows a basic example of customizing routing using application model. The following code makes routes roughly line up with the folder structure of the project.</p>
<pre><code class="lang-csharp">public class NamespaceRoutingConvention : Attribute, IControllerModelConvention
{
    private readonly string _baseNamespace;

    public NamespaceRoutingConvention(string baseNamespace)
    {
        _baseNamespace = baseNamespace;
    }

    public void Apply(ControllerModel controller)
    {
        var hasRouteAttributes = controller.Selectors.Any(selector =&gt;
                                                selector.AttributeRouteModel != null);
        if (hasRouteAttributes)
        {
            return;
        }

        var namespc = controller.ControllerType.Namespace;
        if (namespc == null)
            return;
        var template = new StringBuilder();
        template.Append(namespc, _baseNamespace.Length + 1,
                        namespc.Length - _baseNamespace.Length - 1);
        template.Replace('.', '/');
        template.Append("/[controller]/[action]/{id?}");

        foreach (var selector in controller.Selectors)
        {
            selector.AttributeRouteModel = new AttributeRouteModel()
            {
                Template = template.ToString()
            };
        }
    }
}
</code></pre>
<p>The following code prevents the <code>namespace</code> convention from being applied to controllers that are attribute routed:</p>
<pre><code class="lang-csharp">public void Apply(ControllerModel controller)
{
    var hasRouteAttributes = controller.Selectors.Any(selector =&gt;
                                            selector.AttributeRouteModel != null);
    if (hasRouteAttributes)
    {
        return;
    }
</code></pre>
<p>For example, the following controller doesn't use <code>NamespaceRoutingConvention</code>:</p>
<pre><code class="lang-csharp" highlight-lines="1">[Route("[controller]/[action]/{id?}")]
public class ManagersController : Controller
{
    // /managers/index
    public IActionResult Index()
    {
        var template = ControllerContext.ActionDescriptor.AttributeRouteInfo?.Template;
        return Content($"Index- template:{template}");
    }

    public IActionResult List(int? id)
    {
        var path = Request.Path.Value;
        return Content($"List- Path:{path}");
    }
}
</code></pre>
<p>The <code>NamespaceRoutingConvention.Apply</code> method:</p>
<ul>
<li>Does nothing if the controller is attribute routed.</li>
<li>Sets the controllers template based on the <code>namespace</code>, with the base <code>namespace</code> removed.</li>
</ul>
<p>The <code>NamespaceRoutingConvention</code> can be applied in <code>Startup.ConfigureServices</code>:</p>
<pre><code class="lang-csharp" highlight-lines="1,14-18">namespace My.Application
{
    public class Startup
    {
        public Startup(IConfiguration configuration)
        {
            Configuration = configuration;
        }

        public IConfiguration Configuration { get; }

        public void ConfigureServices(IServiceCollection services)
        {
            services.AddControllersWithViews(options =&gt;
            {
                options.Conventions.Add(
                    new NamespaceRoutingConvention(typeof(Startup).Namespace));
            });
        }
        // Remaining code ommitted for brevity.
</code></pre>
<p>For example, consider the following controller:</p>
<pre><code class="lang-csharp">using Microsoft.AspNetCore.Mvc;

namespace My.Application.Admin.Controllers
{
    public class UsersController : Controller
    {
        // GET /admin/controllers/users/index
        public IActionResult Index()
        {
            var fullname = typeof(UsersController).FullName;
            var template = 
                ControllerContext.ActionDescriptor.AttributeRouteInfo?.Template;
            var path = Request.Path.Value;

            return Content($"Path: {path} fullname: {fullname}  template:{template}");
        }

        public IActionResult List(int? id)
        {
            var path = Request.Path.Value;
            return Content($"Path: {path} ID:{id}");
        }
    }
}
</code></pre>
<p>In the preceding code:</p>
<ul>
<li>The base <code>namespace</code> is <code>My.Application</code>.</li>
<li>The full name of the preceding controller is <code>My.Application.Admin.Controllers.UsersController</code>.</li>
<li>The <code>NamespaceRoutingConvention</code> sets the controllers template to <code>Admin/Controllers/Users/[action]/{id?</code>.</li>
</ul>
<p>The <code>NamespaceRoutingConvention</code> can also be applied as an attribute on a controller:</p>
<pre><code class="lang-csharp" highlight-lines="1">[NamespaceRoutingConvention("My.Application")]
public class TestController : Controller
{
    // /admin/controllers/test/index
    public IActionResult Index()
    {
        var template = ControllerContext.ActionDescriptor.AttributeRouteInfo?.Template;
        var actionname = ControllerContext.ActionDescriptor.ActionName;
        return Content($"Action- {actionname} template:{template}");
    }

    public IActionResult List(int? id)
    {
        var path = Request.Path.Value;
        return Content($"List- Path:{path}");
    }
}
</code></pre>
<p><a name="routing-mixed-ref-label"></a></p>
<h2 id="mixed-routing-attribute-routing-vs-conventional-routing-1">Mixed routing: Attribute routing vs conventional routing</h2>
<p>ASP.NET Core apps can mix the use of conventional routing and attribute routing. It's typical to use conventional routes for controllers serving HTML pages for browsers, and attribute routing for controllers serving REST APIs.</p>
<p>Actions are either conventionally routed or attribute routed. Placing a route on the controller or the action makes it attribute routed. Actions that define attribute routes cannot be reached through the conventional routes and vice-versa. <strong>Any</strong> route attribute on the controller makes <strong>all</strong> actions in the controller attribute routed.</p>
<p>Attribute routing and conventional routing use the same routing engine.</p>
<p><a name="routing-url-gen-ref-label"></a>
<a name="ambient"></a></p>
<h2 id="url-generation-and-ambient-values-1">URL Generation and ambient values</h2>
<p>Apps can use routing URL generation features to generate URL links to actions. Generating URLs eliminates hardcoding URLs, making code more robust and maintainable. This section focuses on the URL generation features provided by MVC and only cover basics of how URL generation works. See <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-9.0" data-linktype="relative-path">Routing</a> for a detailed description of URL generation.</p>
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.iurlhelper" class="no-loc" data-linktype="absolute-path">IUrlHelper</a> interface is the underlying element of infrastructure between MVC and routing for URL generation. An instance of <code>IUrlHelper</code> is available through the <code>Url</code> property in controllers, views, and view components.</p>
<p>In the following example, the <code>IUrlHelper</code> interface is used through the <code>Controller.Url</code> property to generate a URL to another action.</p>
<pre><code class="lang-csharp">public class UrlGenerationController : Controller
{
    public IActionResult Source()
    {
        // Generates /UrlGeneration/Destination
        var url = Url.Action("Destination");
        return ControllerContext.MyDisplayRouteInfo("", $" URL = {url}");
    }

    public IActionResult Destination()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }
}
</code></pre>
<p>If the app is using the default conventional route, the value of the <code>url</code> variable is the URL path string <code>/UrlGeneration/Destination</code>. This URL path is created by routing by combining:</p>
<ul>
<li>The route values from the current request, which are called <strong>ambient values</strong>.</li>
<li>The values passed to <code>Url.Action</code> and substituting those values into the route template:</li>
</ul>
<pre><code class="lang-text">ambient values: { controller = "UrlGeneration", action = "Source" }
values passed to Url.Action: { controller = "UrlGeneration", action = "Destination" }
route template: {controller}/{action}/{id?}

result: /UrlGeneration/Destination
</code></pre>
<p>Each route parameter in the route template has its value substituted by matching names with the values and ambient values. A route parameter that doesn't have a value can:</p>
<ul>
<li>Use a default value if it has one.</li>
<li>Be skipped if it's optional. For example, the <code>id</code> from the  route template <code>{controller}/{action}/{id?}</code>.</li>
</ul>
<p>URL generation fails if any required route parameter doesn't have a corresponding value. If URL generation fails for a route, the next route is tried until all routes have been tried or a match is found.</p>
<p>The preceding example of <code>Url.Action</code> assumes <a href="#cr" data-linktype="self-bookmark">conventional routing</a>. URL generation works similarly with <a href="#ar" data-linktype="self-bookmark">attribute routing</a>, though the concepts are different. With conventional routing:</p>
<ul>
<li>The route values are used to expand a template.</li>
<li>The route values for <code>controller</code> and <code>action</code> usually appear in that template. This works because the URLs matched by routing adhere to a convention.</li>
</ul>
<p>The following example uses attribute routing:</p>
<pre><code class="lang-csharp">public class UrlGenerationAttrController : Controller
{
    [HttpGet("custom")]
    public IActionResult Source()
    {
        var url = Url.Action("Destination");
        return ControllerContext.MyDisplayRouteInfo("", $" URL = {url}");
    }

    [HttpGet("custom/url/to/destination")]
    public IActionResult Destination()
    {
       return ControllerContext.MyDisplayRouteInfo();
    }
}
</code></pre>
<p>The <code>Source</code> action in the preceding code generates <code>custom/url/to/destination</code>.</p>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.linkgenerator" class="no-loc" data-linktype="absolute-path">LinkGenerator</a> was added in ASP.NET Core 3.0 as an alternative to <code>IUrlHelper</code>. <code>LinkGenerator</code> offers similar but more flexible functionality. Each method on <code>IUrlHelper</code> has a corresponding family of methods on <code>LinkGenerator</code> as well.</p>
<h3 id="generating-urls-by-action-name-1">Generating URLs by action name</h3>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.iurlhelper.action" data-linktype="absolute-path">Url.Action</a>, <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.controllerlinkgeneratorextensions.getpathbyaction" data-linktype="absolute-path">LinkGenerator.GetPathByAction</a>, and all related overloads all are designed to generate the target endpoint by specifying a controller name and action name.</p>
<p>When using <code>Url.Action</code>, the current route values for <code>controller</code> and <code>action</code> are provided by the runtime:</p>
<ul>
<li>The value of <code>controller</code> and <code>action</code> are part of both <a href="#ambient" data-linktype="self-bookmark">ambient values</a> and values. The method <code>Url.Action</code> always uses the current values of <code>action</code> and <code>controller</code> and generates a URL path that routes to the current action.</li>
</ul>
<p>Routing attempts to use the values in ambient values to fill in information that wasn't provided when generating a URL. Consider a route like <code>{a}/{b}/{c}/{d}</code> with ambient values <code>{ a = Alice, b = Bob, c = Carol, d = David }</code>:</p>
<ul>
<li>Routing has enough information to generate a URL without any additional values.</li>
<li>Routing has enough information because all route parameters have a value.</li>
</ul>
<p>If the value <code>{ d = Donovan }</code> is added:</p>
<ul>
<li>The value <code>{ d = David }</code> is ignored.</li>
<li>The generated URL path is <code>Alice/Bob/Carol/Donovan</code>.</li>
</ul>
<p><strong>Warning</strong>: URL paths are hierarchical. In the preceding example, if the value <code>{ c = Cheryl }</code> is added:</p>
<ul>
<li>Both of the values <code>{ c = Carol, d = David }</code> are ignored.</li>
<li>There is no longer a value for <code>d</code> and URL generation fails.</li>
<li>The desired values of <code>c</code> and <code>d</code> must be specified to generate a URL.</li>
</ul>
<p>You might expect to hit this problem with the default route <code>{controller}/{action}/{id?}</code>. This problem is rare in practice because <code>Url.Action</code> always explicitly specifies a <code>controller</code> and <code>action</code> value.</p>
<p>Several overloads of <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.iurlhelper.action" data-linktype="absolute-path">Url.Action</a> take a route values object to provide values for route parameters other than <code>controller</code> and <code>action</code>. The route values object is frequently used with <code>id</code>. For example, <code>Url.Action("Buy", "Products", new { id = 17 })</code>. The route values object:</p>
<ul>
<li>By convention is usually an object of anonymous type.</li>
<li>Can be an <code>IDictionary&lt;&gt;</code> or a <a href="https://wikipedia.org/wiki/Plain_old_CLR_object" data-linktype="external">POCO</a>).</li>
</ul>
<p>Any additional route values that don't match route parameters are put in the query string.</p>
<pre><code class="lang-csharp">public IActionResult Index()
{
    var url = Url.Action("Buy", "Products", new { id = 17, color = "red" });
    return Content(url);
}
</code></pre>
<p>The preceding code generates <code>/Products/Buy/17?color=red</code>.</p>
<p>The following code generates an absolute URL:</p>
<pre><code class="lang-csharp">public IActionResult Index2()
{
    var url = Url.Action("Buy", "Products", new { id = 17 }, protocol: Request.Scheme);
    // Returns https://localhost:5001/Products/Buy/17
    return Content(url);
}
</code></pre>
<p>To create an absolute URL, use one of the following:</p>
<ul>
<li>An overload that accepts a <code>protocol</code>. For example, the preceding code.</li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.controllerlinkgeneratorextensions.geturibyaction" data-linktype="absolute-path">LinkGenerator.GetUriByAction</a>, which generates absolute URIs by default.</li>
</ul>
<p><a name="routing-gen-urls-route-ref-label"></a></p>
<h3 id="generate-urls-by-route-1">Generate URLs by route</h3>
<p>The preceding code demonstrated generating a URL by passing in the controller and action name. <code>IUrlHelper</code> also provides the <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.iurlhelper.routeurl" data-linktype="absolute-path">Url.RouteUrl</a> family of methods. These methods are similar to <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.iurlhelper.action" data-linktype="absolute-path">Url.Action</a>, but they don't copy the current values of <code>action</code> and <code>controller</code> to the route values. The most common usage of <code>Url.RouteUrl</code>:</p>
<ul>
<li>Specifies a route name to generate the URL.</li>
<li>Generally doesn't specify a controller or action name.</li>
</ul>
<pre><code class="lang-csharp">public class UrlGeneration2Controller : Controller
{
    [HttpGet("")]
    public IActionResult Source()
    {
        var url = Url.RouteUrl("Destination_Route");
        return ControllerContext.MyDisplayRouteInfo("", $" URL = {url}");
    }

    [HttpGet("custom/url/to/destination2", Name = "Destination_Route")]
    public IActionResult Destination()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }
</code></pre>
<p>The following Razor file generates an HTML link to the <code>Destination_Route</code>:</p>
<pre><code class="lang-cshtml">&lt;h1&gt;Test Links&lt;/h1&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;a href="@Url.RouteUrl("Destination_Route")"&gt;Test Destination_Route&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p><a name="routing-gen-urls-html-ref-label"></a></p>
<h3 id="generate-urls-in-html-and-razor-1">Generate URLs in HTML and Razor</h3>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.rendering.ihtmlhelper" class="no-loc" data-linktype="absolute-path">IHtmlHelper</a> provides the <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.viewfeatures.htmlhelper" class="no-loc" data-linktype="absolute-path">HtmlHelper</a> methods <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.rendering.ihtmlhelper.beginform" data-linktype="absolute-path">Html.BeginForm</a> and <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.rendering.ihtmlhelper.actionlink" data-linktype="absolute-path">Html.ActionLink</a> to generate <code>&lt;form&gt;</code> and <code>&lt;a&gt;</code> elements respectively. These methods use the <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.iurlhelper.action" data-linktype="absolute-path">Url.Action</a> method to generate a URL and they accept similar arguments. The <code>Url.RouteUrl</code> companions for <code>HtmlHelper</code> are <code>Html.BeginRouteForm</code> and <code>Html.RouteLink</code> which have similar functionality.</p>
<p>TagHelpers generate URLs through the <code>form</code> TagHelper and the <code>&lt;a&gt;</code> TagHelper. Both of these use <code>IUrlHelper</code> for their implementation. See <a href="https://learn.microsoft.com/en-us/aspnet/core/mvc/views/working-with-forms?view=aspnetcore-9.0" data-linktype="relative-path">Tag Helpers in forms</a> for more information.</p>
<p>Inside views, the <code>IUrlHelper</code> is available through the <code>Url</code> property for any ad-hoc URL generation not covered by the above.</p>
<p><a name="routing-gen-urls-action-ref-label"></a></p>
<h3 id="url-generation-in-action-results-1">URL generation in Action Results</h3>
<p>The preceding examples showed using <code>IUrlHelper</code> in a controller. The most common usage in a controller is to generate a URL as part of an action result.</p>
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase" class="no-loc" data-linktype="absolute-path">ControllerBase</a> and <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controller" class="no-loc" data-linktype="absolute-path">Controller</a> base classes provide convenience methods for action results that reference another action. One typical usage is to redirect after accepting user input:</p>
<pre><code class="lang-csharp">[HttpPost]
[ValidateAntiForgeryToken]
public IActionResult Edit(int id, Customer customer)
{
    if (ModelState.IsValid)
    {
        // Update DB with new details.
        ViewData["Message"] = $"Successful edit of customer {id}";
        return RedirectToAction("Index");
    }
    return View(customer);
}
</code></pre>
<p>The action results factory methods such as <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase.redirecttoaction" class="no-loc" data-linktype="absolute-path">RedirectToAction</a> and <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase.createdataction" class="no-loc" data-linktype="absolute-path">CreatedAtAction</a> follow a similar pattern to the methods on <code>IUrlHelper</code>.</p>
<p><a name="routing-dedicated-ref-label"></a></p>
<h3 id="special-case-for-dedicated-conventional-routes-1">Special case for dedicated conventional routes</h3>
<p><a href="#cr" data-linktype="self-bookmark">Conventional routing</a> can use a special kind of route definition called a <a href="#dcr" data-linktype="self-bookmark">dedicated conventional route</a>. In the following example, the route named <code>blog</code> is a dedicated conventional route:</p>
<pre><code class="lang-csharp">app.UseEndpoints(endpoints =&gt;
{
    endpoints.MapControllerRoute(name: "blog",
                pattern: "blog/{*article}",
                defaults: new { controller = "Blog", action = "Article" });
    endpoints.MapControllerRoute(name: "default",
                pattern: "{controller=Home}/{action=Index}/{id?}");
});
</code></pre>
<p>Using the preceding route definitions, <code>Url.Action("Index", "Home")</code> generates the URL path <code>/</code> using the <code>default</code> route, but why? You might guess the route values <code>{ controller = Home, action = Index }</code> would be enough to generate a URL using <code>blog</code>, and the result would be <code>/blog?action=Index&amp;controller=Home</code>.</p>
<p><a href="#dcr" data-linktype="self-bookmark">Dedicated conventional routes</a> rely on a special behavior of default values that don't have a corresponding route parameter that prevents the route from being too <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-9.0#greedy" data-linktype="relative-path">greedy</a> with URL generation. In this case the default values are <code>{ controller = Blog, action = Article }</code>, and neither <code>controller</code> nor <code>action</code> appears as a route parameter. When routing performs URL generation, the values provided must match the default values. URL generation using <code>blog</code> fails because the values <code>{ controller = Home, action = Index }</code> don't match <code>{ controller = Blog, action = Article }</code>. Routing then falls back to try <code>default</code>, which succeeds.</p>
<p><a name="routing-areas-ref-label"></a></p>
<h2 id="areas-1">Areas</h2>
<p><a href="https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/areas?view=aspnetcore-9.0" data-linktype="relative-path">Areas</a> are an MVC feature used to organize related functionality into a group as a separate:</p>
<ul>
<li>Routing namespace for controller actions.</li>
<li>Folder structure for views.</li>
</ul>
<p>Using areas allows an app to have multiple controllers with the same name, as long as they have different areas. Using areas creates a hierarchy for the purpose of routing by adding another route parameter, <code>area</code> to <code>controller</code> and <code>action</code>. This section discusses how routing interacts with areas. See <a href="https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/areas?view=aspnetcore-9.0" data-linktype="relative-path">Areas</a> for details about how areas are used with views.</p>
<p>The following example configures MVC to use the default conventional route and an <code>area</code> route for an <code>area</code> named <code>Blog</code>:</p>
<pre><code class="lang-csharp">app.UseEndpoints(endpoints =&gt;
{
    endpoints.MapAreaControllerRoute("blog_route", "Blog",
        "Manage/{controller}/{action}/{id?}");
    endpoints.MapControllerRoute("default_route", "{controller}/{action}/{id?}");
});
</code></pre>
<p>In the preceding code, <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapareacontrollerroute" class="no-loc" data-linktype="absolute-path">MapAreaControllerRoute</a> is called to create the <code>"blog_route"</code>. The second parameter, <code>"Blog"</code>, is the area name.</p>
<p>When matching a URL path like <code>/Manage/Users/AddUser</code>, the <code>"blog_route"</code> route generates the route values <code>{ area = Blog, controller = Users, action = AddUser }</code>. The <code>area</code> route value is produced by a default value for <code>area</code>. The route created by <code>MapAreaControllerRoute</code> is equivalent to the following:</p>
<pre><code class="lang-csharp">app.UseEndpoints(endpoints =&gt;
{
    endpoints.MapControllerRoute("blog_route", "Manage/{controller}/{action}/{id?}",
        defaults: new { area = "Blog" }, constraints: new { area = "Blog" });
    endpoints.MapControllerRoute("default_route", "{controller}/{action}/{id?}");
});
</code></pre>
<p><code>MapAreaControllerRoute</code> creates a route using both a default value and constraint for <code>area</code> using the provided area name, in this case <code>Blog</code>. The default value ensures that the route always produces <code>{ area = Blog, ... }</code>, the constraint requires the value <code>{ area = Blog, ... }</code> for URL generation.</p>
<p>Conventional routing is order-dependent. In general, routes with areas should be placed earlier as they're more specific than routes without an area.</p>
<p>Using the preceding example, the route values <code>{ area = Blog, controller = Users, action = AddUser }</code> match the following action:</p>
<pre><code class="lang-csharp">using Microsoft.AspNetCore.Mvc;

namespace MyApp.Namespace1
{
    [Area("Blog")]
    public class UsersController : Controller
    {
        // GET /manage/users/adduser
        public IActionResult AddUser()
        {
            var area = ControllerContext.ActionDescriptor.RouteValues["area"];
            var actionName = ControllerContext.ActionDescriptor.ActionName;
            var controllerName = ControllerContext.ActionDescriptor.ControllerName;

            return Content($"area name:{area}" +
                $" controller:{controllerName}  action name: {actionName}");
        }        
    }
}
</code></pre>
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.areaattribute" data-linktype="absolute-path">[Area]</a> attribute is what denotes a controller as part of an area. This controller is in the <code>Blog</code> area. Controllers without an <code>[Area]</code> attribute are not members of any area, and do <strong>not</strong> match when the <code>area</code> route value is provided by routing. In the following example, only the first controller listed can match the route values <code>{ area = Blog, controller = Users, action = AddUser }</code>.</p>
<pre><code class="lang-csharp">using Microsoft.AspNetCore.Mvc;

namespace MyApp.Namespace1
{
    [Area("Blog")]
    public class UsersController : Controller
    {
        // GET /manage/users/adduser
        public IActionResult AddUser()
        {
            var area = ControllerContext.ActionDescriptor.RouteValues["area"];
            var actionName = ControllerContext.ActionDescriptor.ActionName;
            var controllerName = ControllerContext.ActionDescriptor.ControllerName;

            return Content($"area name:{area}" +
                $" controller:{controllerName}  action name: {actionName}");
        }        
    }
}
</code></pre><pre><code class="lang-csharp">using Microsoft.AspNetCore.Mvc;

namespace MyApp.Namespace2
{
    // Matches { area = Zebra, controller = Users, action = AddUser }
    [Area("Zebra")]
    public class UsersController : Controller
    {
        // GET /zebra/users/adduser
        public IActionResult AddUser()
        {
            var area = ControllerContext.ActionDescriptor.RouteValues["area"];
            var actionName = ControllerContext.ActionDescriptor.ActionName;
            var controllerName = ControllerContext.ActionDescriptor.ControllerName;

            return Content($"area name:{area}" +
                $" controller:{controllerName}  action name: {actionName}");
        }        
    }
}
</code></pre><pre><code class="lang-csharp">using Microsoft.AspNetCore.Mvc;

namespace MyApp.Namespace3
{
    // Matches { area = string.Empty, controller = Users, action = AddUser }
    // Matches { area = null, controller = Users, action = AddUser }
    // Matches { controller = Users, action = AddUser }
    public class UsersController : Controller
    {
        // GET /users/adduser
        public IActionResult AddUser()
        {
            var area = ControllerContext.ActionDescriptor.RouteValues["area"];
            var actionName = ControllerContext.ActionDescriptor.ActionName;
            var controllerName = ControllerContext.ActionDescriptor.ControllerName;

            return Content($"area name:{area}" +
                $" controller:{controllerName}  action name: {actionName}");
        }
    }
}
</code></pre>
<p>The namespace of each controller is shown here for completeness. If the preceding controllers used the same namespace, a compiler error would be generated. Class namespaces have no effect on MVC's routing.</p>
<p>The first two controllers are members of areas, and only match when their respective area name is provided by the <code>area</code> route value. The third controller isn't a member of any area, and can only match when no value for <code>area</code> is provided by routing.</p>
<p><a name="aa"></a></p>
<p>In terms of matching <em>no value</em>, the absence of the <code>area</code> value is the same as if the value for <code>area</code> were null or the empty string.</p>
<p>When executing an action inside an area, the route value for <code>area</code> is available as an <a href="#ambient" data-linktype="self-bookmark">ambient value</a> for routing to use for URL generation. This means that by default areas act <em>sticky</em> for URL generation as demonstrated by the following sample.</p>
<pre><code class="lang-csharp">app.UseEndpoints(endpoints =&gt;
{
    endpoints.MapAreaControllerRoute(name: "duck_route", 
                                     areaName: "Duck",
                                     pattern: "Manage/{controller}/{action}/{id?}");
    endpoints.MapControllerRoute(name: "default",
                                 pattern: "Manage/{controller=Home}/{action=Index}/{id?}");
});
</code></pre><pre><code class="lang-csharp">using Microsoft.AspNetCore.Mvc;

namespace MyApp.Namespace4
{
    [Area("Duck")]
    public class UsersController : Controller
    {
        // GET /Manage/users/GenerateURLInArea
        public IActionResult GenerateURLInArea()
        {
            // Uses the 'ambient' value of area.
            var url = Url.Action("Index", "Home");
            // Returns /Manage/Home/Index
            return Content(url);
        }

        // GET /Manage/users/GenerateURLOutsideOfArea
        public IActionResult GenerateURLOutsideOfArea()
        {
            // Uses the empty value for area.
            var url = Url.Action("Index", "Home", new { area = "" });
            // Returns /Manage
            return Content(url);
        }
    }
}
</code></pre>
<p>The following code generates a URL to <code>/Zebra/Users/AddUser</code>:</p>
<pre><code class="lang-csharp">public class HomeController : Controller
{
    public IActionResult About()
    {
        var url = Url.Action("AddUser", "Users", new { Area = "Zebra" });
        return Content($"URL: {url}");
    }
</code></pre>
<p><a name="action"></a></p>
<h2 id="action-definition-1">Action definition</h2>
<p>Public methods on a controller, except those with the <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.nonactionattribute" data-linktype="absolute-path">NonAction</a> attribute, are actions.</p>
<h2 id="sample-code-1">Sample code</h2>
<ul>
<li><a href="https://github.com/Rick-Anderson/RouteInfo/blob/master/Microsoft.Docs.Samples.RouteInfo/ControllerContextExtensions.cs" data-linktype="external">MyDisplayRouteInfo</a> is provided by the <a href="https://www.nuget.org/packages/Rick.Docs.Samples.RouteInfo" data-linktype="external">Rick.Docs.Samples.RouteInfo</a> NuGet package and displays route information.</li>
<li><a href="https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/mvc/controllers/routing/samples/3.x" data-linktype="external">View or download sample code</a> (<a href="../../overview553c.html?view=aspnetcore-9.0#how-to-download-a-sample" data-linktype="relative-path">how to download</a>)</li>
</ul>
<h2 id="debug-diagnostics">Debug diagnostics</h2>
<p>For detailed routing diagnostic output, set <code>Logging:LogLevel:Microsoft</code> to <code>Debug</code>. In the development environment, set the log level in <code>appsettings.Development.json</code>:</p>
<pre><code class="lang-json">{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Debug",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  }
}
</code></pre>
</div>
</div>
					
		<div
			id="ms--inline-notifications"
			class="margin-block-xs"
			data-bi-name="inline-notification"
		></div>
	 
		<div
			id="assertive-live-region"
			role="alert"
			aria-live="assertive"
			class="visually-hidden"
			aria-relevant="additions"
			aria-atomic="true"
		></div>
		<div
			id="polite-live-region"
			role="status"
			aria-live="polite"
			class="visually-hidden"
			aria-relevant="additions"
			aria-atomic="true"
		></div>
	
					
			
		<!-- feedback section -->
		<section
			class="feedback-section position-relative margin-top-lg border border-radius padding-xxs display-none-print"
			data-bi-name="open-source-feedback-section"
			data-open-source-feedback-section
			hidden
		>
			<div class="display-flex flex-direction-column flex-direction-row-tablet">
				<div
					class="width-450-tablet padding-inline-xs padding-inline-xs-tablet padding-top-xs padding-bottom-sm padding-top-xs-tablet background-color-body-medium"
				>
					<div class="display-flex flex-direction-column">
						<div class="padding-bottom-xxs">
							<span class="icon margin-right-xxs" aria-hidden="true">
								<span class="docon docon-brand-github"></span>
							</span>
							<span class="font-weight-semibold">
								Collaborate with us on GitHub
							</span>
						</div>
						<span class="line-height-normal">
							The source for this content can be found on GitHub, where you can also create and review issues and pull requests. For more information, see <a href="https://learn.microsoft.com/contribute/content/dotnet/dotnet-contribute">our contributor guide</a>.
						</span>
					</div>
				</div>
				<div
					class="display-flex gap-xs width-full-tablet flex-direction-column padding-xs justify-content-space-evenly"
				>
					<div class="media">
						
					<div class="media-left">
						<div class="image image-36x36" hidden data-open-source-image-container>
							<img
								class="theme-display is-light"
								src="https://learn.microsoft.com/media/logos/logo_net.svg"
								aria-hidden="true"
								data-open-source-image-light
							/>
							<img
								class="theme-display is-dark is-high-contrast"
								src="https://learn.microsoft.com/media/logos/logo_net.svg"
								aria-hidden="true"
								data-open-source-image-dark
							/>
						</div>
					</div>
			  

						<div class="media-content">
							<p
								class="font-size-xl font-weight-semibold margin-bottom-xxs"
								data-open-source-product-title
							>
								ASP.NET Core
							</p>
							<div class="display-flex gap-xs flex-direction-column">
								<p class="line-height-normal" data-open-source-product-description></p>
								<div class="display-flex gap-xs flex-direction-column">
									<a href="#" data-github-link>
										<span class="icon margin-right-xxs" aria-hidden="true">
											<span class="docon docon-bug"></span>
										</span>
										<span>Open a documentation issue</span>
									</a>
									<a
										href="https://github.com/dotnet/aspnetcore/blob/main/CONTRIBUTING.md"
										class="display-block margin-top-auto font-size-md"
										data-feedback-product-url
									>
										<span class="icon margin-right-xxs" aria-hidden="true">
											<span class="docon docon-feedback"></span>
										</span>
										<span>Provide product feedback</span>
									</a>
								</div>
							</div>
						</div>
					</div>
				</div>
			</div>
		</section>
		<!-- end feedback section -->
	
			
		<!-- feedback section -->
		<section
			id="site-user-feedback-footer"
			class="font-size-sm margin-top-md display-none-print display-none-desktop"
			data-test-id="site-user-feedback-footer"
			data-bi-name="site-feedback-section"
		>
			<hr class="hr" />
			<h2 id="ms--feedback" class="title is-3">Feedback</h2>
			<div class="display-flex flex-wrap-wrap align-items-center">
				<p class="font-weight-semibold margin-xxs margin-left-none">
					Was this page helpful?
				</p>
				<div class="buttons">
					<button
						class="thumb-rating-button like button button-primary button-sm"
						data-test-id="footer-rating-yes"
						data-binary-rating-response="rating-yes"
						type="button"
						title="This article is helpful"
						data-bi-name="button-rating-yes"
						aria-pressed="false"
					>
						<span class="icon" aria-hidden="true">
							<span class="docon docon-like"></span>
						</span>
						<span>Yes</span>
					</button>
					<button
						class="thumb-rating-button dislike button button-primary button-sm"
						data-test-id="footer-rating-no"
						data-binary-rating-response="rating-no"
						type="button"
						title="This article is not helpful"
						data-bi-name="button-rating-no"
						aria-pressed="false"
					>
						<span class="icon" aria-hidden="true">
							<span class="docon docon-dislike"></span>
						</span>
						<span>No</span>
					</button>
				</div>
			</div>
		</section>
		<!-- end feedback section -->
	
		
				</div>
				
		<div id="ms--additional-resources-mobile" class="display-none-print">
			<hr class="hr" hidden />
			<h2 id="ms--additional-resources-mobile-heading" class="title is-3" hidden>
				Additional resources
			</h2>
			
		<section
			id="right-rail-recommendations-mobile"
			class=""
			data-bi-name="recommendations"
			hidden
		></section>
	 
		<section
			id="right-rail-training-mobile"
			class=""
			data-bi-name="learning-resource-card"
			hidden
		></section>
	 
		<section
			id="right-rail-events-mobile"
			class=""
			data-bi-name="events-card"
			hidden
		></section>
	 
		<section
			id="right-rail-qna-mobile"
			class="margin-top-xxs"
			data-bi-name="qna-link-card"
			hidden
		></section>
	
		</div>
	
			</div>
			
		<div
			id="action-panel"
			role="region"
			aria-label="Action Panel"
			class="action-panel"
			tabindex="-1"
		></div>
	
		
				</main>
				<aside
					id="layout-body-aside"
					class="layout-body-aside "
					data-bi-name="aside"
			  >
					
		<div
			id="ms--additional-resources"
			class="right-container padding-sm display-none display-block-desktop height-full"
			data-bi-name="pageactions"
			role="complementary"
			aria-label="Additional resources"
		>
			<div id="affixed-right-container" data-bi-name="right-column">
				
		<nav
			id="side-doc-outline"
			class="doc-outline border-bottom padding-bottom-xs margin-bottom-xs"
			data-bi-name="intopic toc"
			aria-label="In this article"
		>
			<h3>In this article</h3>
		</nav>
	
				<!-- Feedback -->
				
		<section
			id="ms--site-user-feedback-right-rail"
			class="font-size-sm display-none-print"
			data-test-id="site-user-feedback-right-rail"
			data-bi-name="site-feedback-right-rail"
		>
			<p class="font-weight-semibold margin-bottom-xs">Was this page helpful?</p>
			<div class="buttons">
				<button
					class="thumb-rating-button like button button-primary button-sm"
					data-test-id="right-rail-rating-yes"
					data-binary-rating-response="rating-yes"
					type="button"
					title="This article is helpful"
					data-bi-name="button-rating-yes"
					aria-pressed="false"
				>
					<span class="icon" aria-hidden="true">
						<span class="docon docon-like"></span>
					</span>
					<span>Yes</span>
				</button>
				<button
					class="thumb-rating-button dislike button button-primary button-sm"
					data-test-id="right-rail-rating-no"
					data-binary-rating-response="rating-no"
					type="button"
					title="This article is not helpful"
					data-bi-name="button-rating-no"
					aria-pressed="false"
				>
					<span class="icon" aria-hidden="true">
						<span class="docon docon-dislike"></span>
					</span>
					<span>No</span>
				</button>
			</div>
		</section>
	
			</div>
		</div>
	
			  </aside> <section
					id="layout-body-flyout"
					class="layout-body-flyout "
					data-bi-name="flyout"
			  >
					 <div
	class="height-full border-left background-color-body-medium"
	id="ask-learn-flyout"
></div>
			  </section> <div class="layout-body-footer " data-bi-name="layout-footer">
		<footer
			id="footer"
			data-test-id="footer"
			data-bi-name="footer"
			class="footer-layout has-padding has-default-focus border-top  uhf-container"
			role="contentinfo"
		>
			<div class="display-flex gap-xs flex-wrap-wrap is-full-height padding-right-lg-desktop">
				
		<a
			data-mscc-ic="false"
			href="#"
			data-bi-name="select-locale"
			class="locale-selector-link flex-shrink-0 button button-sm button-clear external-link-indicator"
			id=""
			title=""
			><span class="icon" aria-hidden="true"
				><span class="docon docon-world"></span></span
			><span class="local-selector-link-text">en-us</span></a
		>
	
				<div class="ccpa-privacy-link" data-ccpa-privacy-link hidden>
		
		<a
			data-mscc-ic="false"
			href="https://aka.ms/yourcaliforniaprivacychoices"
			data-bi-name="your-privacy-choices"
			class="button button-sm button-clear flex-shrink-0 external-link-indicator"
			id=""
			title=""
			>
		<svg
			xmlns="http://www.w3.org/2000/svg"
			viewBox="0 0 30 14"
			xml:space="preserve"
			height="16"
			width="43"
			aria-hidden="true"
			focusable="false"
		>
			<path
				d="M7.4 12.8h6.8l3.1-11.6H7.4C4.2 1.2 1.6 3.8 1.6 7s2.6 5.8 5.8 5.8z"
				style="fill-rule:evenodd;clip-rule:evenodd;fill:#fff"
			></path>
			<path
				d="M22.6 0H7.4c-3.9 0-7 3.1-7 7s3.1 7 7 7h15.2c3.9 0 7-3.1 7-7s-3.2-7-7-7zm-21 7c0-3.2 2.6-5.8 5.8-5.8h9.9l-3.1 11.6H7.4c-3.2 0-5.8-2.6-5.8-5.8z"
				style="fill-rule:evenodd;clip-rule:evenodd;fill:#06f"
			></path>
			<path
				d="M24.6 4c.2.2.2.6 0 .8L22.5 7l2.2 2.2c.2.2.2.6 0 .8-.2.2-.6.2-.8 0l-2.2-2.2-2.2 2.2c-.2.2-.6.2-.8 0-.2-.2-.2-.6 0-.8L20.8 7l-2.2-2.2c-.2-.2-.2-.6 0-.8.2-.2.6-.2.8 0l2.2 2.2L23.8 4c.2-.2.6-.2.8 0z"
				style="fill:#fff"
			></path>
			<path
				d="M12.7 4.1c.2.2.3.6.1.8L8.6 9.8c-.1.1-.2.2-.3.2-.2.1-.5.1-.7-.1L5.4 7.7c-.2-.2-.2-.6 0-.8.2-.2.6-.2.8 0L8 8.6l3.8-4.5c.2-.2.6-.2.9 0z"
				style="fill:#06f"
			></path>
		</svg>
	
			<span>Your Privacy Choices</span></a
		>
	
	</div>
				<div class="flex-shrink-0">
		<div class="dropdown has-caret-up">
			<button
				data-test-id="theme-selector-button"
				class="dropdown-trigger button button-clear button-sm has-inner-focus theme-dropdown-trigger"
				aria-controls="{{ themeMenuId }}"
				aria-expanded="false"
				title="Theme"
				data-bi-name="theme"
			>
				<span class="icon">
					<span class="docon docon-sun" aria-hidden="true"></span>
				</span>
				<span>Theme</span>
				<span class="icon expanded-indicator" aria-hidden="true">
					<span class="docon docon-chevron-down-light"></span>
				</span>
			</button>
			<div class="dropdown-menu" id="{{ themeMenuId }}" role="menu">
				<ul class="theme-selector padding-xxs" data-test-id="theme-dropdown-menu">
					<li class="theme display-block">
						<button
							class="button button-clear button-sm theme-control button-block justify-content-flex-start text-align-left"
							data-theme-to="light"
						>
							<span class="theme-light margin-right-xxs">
								<span
									class="theme-selector-icon border display-inline-block has-body-background"
									aria-hidden="true"
								>
									<svg class="svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 22 14">
										<rect width="22" height="14" class="has-fill-body-background" />
										<rect x="5" y="5" width="12" height="4" class="has-fill-secondary" />
										<rect x="5" y="2" width="2" height="1" class="has-fill-secondary" />
										<rect x="8" y="2" width="2" height="1" class="has-fill-secondary" />
										<rect x="11" y="2" width="3" height="1" class="has-fill-secondary" />
										<rect x="1" y="1" width="2" height="2" class="has-fill-secondary" />
										<rect x="5" y="10" width="7" height="2" rx="0.3" class="has-fill-primary" />
										<rect x="19" y="1" width="2" height="2" rx="1" class="has-fill-secondary" />
									</svg>
								</span>
							</span>
							<span role="menuitem"> Light </span>
						</button>
					</li>
					<li class="theme display-block">
						<button
							class="button button-clear button-sm theme-control button-block justify-content-flex-start text-align-left"
							data-theme-to="dark"
						>
							<span class="theme-dark margin-right-xxs">
								<span
									class="border theme-selector-icon display-inline-block has-body-background"
									aria-hidden="true"
								>
									<svg class="svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 22 14">
										<rect width="22" height="14" class="has-fill-body-background" />
										<rect x="5" y="5" width="12" height="4" class="has-fill-secondary" />
										<rect x="5" y="2" width="2" height="1" class="has-fill-secondary" />
										<rect x="8" y="2" width="2" height="1" class="has-fill-secondary" />
										<rect x="11" y="2" width="3" height="1" class="has-fill-secondary" />
										<rect x="1" y="1" width="2" height="2" class="has-fill-secondary" />
										<rect x="5" y="10" width="7" height="2" rx="0.3" class="has-fill-primary" />
										<rect x="19" y="1" width="2" height="2" rx="1" class="has-fill-secondary" />
									</svg>
								</span>
							</span>
							<span role="menuitem"> Dark </span>
						</button>
					</li>
					<li class="theme display-block">
						<button
							class="button button-clear button-sm theme-control button-block justify-content-flex-start text-align-left"
							data-theme-to="high-contrast"
						>
							<span class="theme-high-contrast margin-right-xxs">
								<span
									class="border theme-selector-icon display-inline-block has-body-background"
									aria-hidden="true"
								>
									<svg class="svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 22 14">
										<rect width="22" height="14" class="has-fill-body-background" />
										<rect x="5" y="5" width="12" height="4" class="has-fill-secondary" />
										<rect x="5" y="2" width="2" height="1" class="has-fill-secondary" />
										<rect x="8" y="2" width="2" height="1" class="has-fill-secondary" />
										<rect x="11" y="2" width="3" height="1" class="has-fill-secondary" />
										<rect x="1" y="1" width="2" height="2" class="has-fill-secondary" />
										<rect x="5" y="10" width="7" height="2" rx="0.3" class="has-fill-primary" />
										<rect x="19" y="1" width="2" height="2" rx="1" class="has-fill-secondary" />
									</svg>
								</span>
							</span>
							<span role="menuitem"> High contrast </span>
						</button>
					</li>
				</ul>
			</div>
		</div>
	</div>
			</div>
			<ul class="links" data-bi-name="footerlinks">
				<li class="manage-cookies-holder" hidden=""></li>
				<li>
		
		<a
			data-mscc-ic="false"
			href="https://learn.microsoft.com/en-us/principles-for-ai-generated-content"
			data-bi-name="aiDisclaimer"
			class=" external-link-indicator"
			id=""
			title=""
			>AI Disclaimer</a
		>
	
	</li><li>
		
		<a
			data-mscc-ic="false"
			href="https://learn.microsoft.com/en-us/previous-versions/"
			data-bi-name="archivelink"
			class=" external-link-indicator"
			id=""
			title=""
			>Previous Versions</a
		>
	
	</li> <li>
		
		<a
			data-mscc-ic="false"
			href="https://techcommunity.microsoft.com/t5/microsoft-learn-blog/bg-p/MicrosoftLearnBlog"
			data-bi-name="bloglink"
			class=" external-link-indicator"
			id=""
			title=""
			>Blog</a
		>
	
	</li> <li>
		
		<a
			data-mscc-ic="false"
			href="https://learn.microsoft.com/en-us/contribute"
			data-bi-name="contributorGuide"
			class=" external-link-indicator"
			id=""
			title=""
			>Contribute</a
		>
	
	</li><li>
		
		<a
			data-mscc-ic="false"
			href="https://go.microsoft.com/fwlink/?LinkId=521839"
			data-bi-name="privacy"
			class=" external-link-indicator"
			id=""
			title=""
			>Privacy</a
		>
	
	</li><li>
		
		<a
			data-mscc-ic="false"
			href="https://learn.microsoft.com/en-us/legal/termsofuse"
			data-bi-name="termsofuse"
			class=" external-link-indicator"
			id=""
			title=""
			>Terms of Use</a
		>
	
	</li><li>
		
		<a
			data-mscc-ic="false"
			href="https://www.microsoft.com/legal/intellectualproperty/Trademarks/"
			data-bi-name="trademarks"
			class=" external-link-indicator"
			id=""
			title=""
			>Trademarks</a
		>
	
	</li>
				<li>&copy; Microsoft 2025</li>
			</ul>
		</footer>
	</footer>
			</body>
		
<!-- Mirrored from learn.microsoft.com/en-us/aspnet/core/mvc/controllers/routing?view=aspnetcore-9.0 by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 06 Aug 2025 14:53:03 GMT -->
</html>