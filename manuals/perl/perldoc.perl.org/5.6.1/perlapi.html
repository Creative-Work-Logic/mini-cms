<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from perldoc.perl.org/5.6.1/perlapi by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 06 Aug 2025 16:20:46 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>perlapi - autogenerated documentation for the perl public API - Perldoc Browser</title>
    <link rel="search" href="../opensearch.xml" type="application/opensearchdescription+xml" title="Perldoc Browser">
    <link rel="canonical" href="../perlapi.html">
    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/stackoverflow-light.min.css" rel="stylesheet">
    <link href="../css/perldoc.css" rel="stylesheet">
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-KVNWBNT5FB"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-KVNWBNT5FB');
      gtag('config', 'UA-50555-3');
    </script>
  </head>
  <body>
    <nav class="navbar navbar-expand-md bg-dark" data-bs-theme="dark"><div class="container-fluid">
  <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <a class="navbar-brand" href="../index.html"><img src="../images/perl_camel_30.png" width="30" height="30" class="d-inline-block align-text-top" alt="Perl Camel Logo"> Perldoc Browser</a>
  <div class="collapse navbar-collapse" id="navbarNav">
    <ul class="navbar-nav me-auto">
      <li class="nav-item dropdown text-nowrap">
        <a class="nav-link dropdown-toggle" href="#" id="dropdownlink-stable" role="button" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">5.6.1</a>
        <div class="dropdown-menu" aria-labelledby="dropdownlink-stable">
          <a class="dropdown-item" href="../perlapi.html">Latest</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.42.0/perlapi">5.42.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.40.3/perlapi">5.40.3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.40.2/perlapi">5.40.2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.40.1/perlapi">5.40.1</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.40.0/perlapi">5.40.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.38.5/perlapi">5.38.5</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.38.4/perlapi">5.38.4</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.38.3/perlapi">5.38.3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.38.2/perlapi">5.38.2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.38.1/perlapi">5.38.1</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.38.0/perlapi">5.38.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.36.3/perlapi">5.36.3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.36.2/perlapi">5.36.2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.36.1/perlapi">5.36.1</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.36.0/perlapi">5.36.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.34.3/perlapi">5.34.3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.34.2/perlapi">5.34.2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.34.1/perlapi">5.34.1</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.34.0/perlapi">5.34.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.32.1/perlapi">5.32.1</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.32.0/perlapi">5.32.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.30.3/perlapi">5.30.3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.30.2/perlapi">5.30.2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.30.1/perlapi">5.30.1</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.30.0/perlapi">5.30.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.28.3/perlapi">5.28.3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.28.2/perlapi">5.28.2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.28.1/perlapi">5.28.1</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.28.0/perlapi">5.28.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.26.3/perlapi">5.26.3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.26.2/perlapi">5.26.2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.26.1/perlapi">5.26.1</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.26.0/perlapi">5.26.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.24.4/perlapi">5.24.4</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.24.3/perlapi">5.24.3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.24.2/perlapi">5.24.2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.24.1/perlapi">5.24.1</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.24.0/perlapi">5.24.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.22.4/perlapi">5.22.4</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.22.3/perlapi">5.22.3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.22.2/perlapi">5.22.2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.22.1/perlapi">5.22.1</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.22.0/perlapi">5.22.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.20.3/perlapi">5.20.3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.20.2/perlapi">5.20.2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.20.1/perlapi">5.20.1</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.20.0/perlapi">5.20.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.18.4/perlapi">5.18.4</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.18.3/perlapi">5.18.3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.18.2/perlapi">5.18.2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.18.1/perlapi">5.18.1</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.18.0/perlapi">5.18.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.16.3/perlapi">5.16.3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.16.2/perlapi">5.16.2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.16.1/perlapi">5.16.1</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.16.0/perlapi">5.16.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.14.4/perlapi">5.14.4</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.14.3/perlapi">5.14.3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.14.2/perlapi">5.14.2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.14.1/perlapi">5.14.1</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.14.0/perlapi">5.14.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.12.5/perlapi">5.12.5</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.12.4/perlapi">5.12.4</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.12.3/perlapi">5.12.3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.12.2/perlapi">5.12.2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.12.1/perlapi">5.12.1</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.12.0/perlapi">5.12.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.10.1/perlapi">5.10.1</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.10.0/perlapi">5.10.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.8.9/perlapi">5.8.9</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.8.8/perlapi">5.8.8</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.8.7/perlapi">5.8.7</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.8.6/perlapi">5.8.6</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.8.5/perlapi">5.8.5</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.8.4/perlapi">5.8.4</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.8.3/perlapi">5.8.3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.8.2/perlapi">5.8.2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.8.1/perlapi">5.8.1</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.8.0/perlapi">5.8.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="../5.6.2/perlapi.html">5.6.2</a>
          <a class="dropdown-item active" href="perlapi.html">5.6.1</a>
          <a class="dropdown-item" href="../5.6.0/perlapi.html">5.6.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.005_04/perlapi">5.005_04</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.005_03/perlapi">5.005_03</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.005_02/perlapi">5.005_02</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.005_01/perlapi">5.005_01</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.005/perlapi">5.005</a>
        </div>
      </li>
      <li class="nav-item dropdown text-nowrap">
        <a class="nav-link dropdown-toggle" href="#" id="dropdownlink-dev" role="button" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Dev</a>
        <div class="dropdown-menu" aria-labelledby="dropdownlink-dev">
          <a class="dropdown-item" href="https://perldoc.perl.org/blead/perlapi">blead</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.43.1/perlapi">5.43.1</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.42.0-RC3/perlapi">5.42.0-RC3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.42.0-RC2/perlapi">5.42.0-RC2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.42.0-RC1/perlapi">5.42.0-RC1</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.41.13/perlapi">5.41.13</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.41.12/perlapi">5.41.12</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.41.11/perlapi">5.41.11</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.41.10/perlapi">5.41.10</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.41.9/perlapi">5.41.9</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.41.8/perlapi">5.41.8</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.41.7/perlapi">5.41.7</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.41.6/perlapi">5.41.6</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.41.5/perlapi">5.41.5</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.41.4/perlapi">5.41.4</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.41.3/perlapi">5.41.3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.41.2/perlapi">5.41.2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.41.1/perlapi">5.41.1</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.40.3-RC1/perlapi">5.40.3-RC1</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.38.5-RC1/perlapi">5.38.5-RC1</a>
        </div>
      </li>
      <li class="nav-item dropdown text-nowrap">
        <a class="nav-link dropdown-toggle" href="#" id="dropdownlink-nav" role="button" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Documentation</a>
        <div class="dropdown-menu" aria-labelledby="dropdownlink-nav">
          <a class="dropdown-item" href="perl.html">Perl</a>
          <a class="dropdown-item" href="perlintro.html">Intro</a>
          <a class="dropdown-item" href="perl.html#Tutorials">Tutorials</a>
          <a class="dropdown-item" href="perlfaq.html">FAQs</a>
          <a class="dropdown-item" href="perl.html#Reference-Manual">Reference</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="perlop.html">Operators</a>
          <a class="dropdown-item" href="functions.html">Functions</a>
          <a class="dropdown-item" href="variables.html">Variables</a>
          <a class="dropdown-item" href="modules.html">Modules</a>
          <a class="dropdown-item" href="perlutil.html">Utilities</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="perldelta.html">Release Notes</a>
          <a class="dropdown-item" href="perlcommunity.html">Community</a>
          <a class="dropdown-item" href="perlhist.html">History</a>
        </div>
      </li>
    </ul>
    <ul class="navbar-nav">
      <button id="content-expand-button" type="button" class="btn btn-dark d-none d-lg-inline-block me-4">Expand</button>
      <script src="../js/perldoc-expand-page.js"></script>
    </ul>
    <form class="form-inline" method="get" action="https://perldoc.perl.org/5.6.1/search">
      <input id="search-input" class="form-control me-3" type="search" name="q" placeholder="[S]earch" aria-label="Search" value="">
    </form>
    <script src="../js/perldoc-focus-search.js"></script>
  </div>
</div></nav>

    <div id="wrapperlicious" class="container-fluid">
      <div id="perldocdiv">
        <div id="links">
          <a href="perlapi.html">perlapi</a>
          <div id="more">
            (<a href="https://perldoc.perl.org/5.6.1/perlapi.txt">source</a>,
            <a href="https://metacpan.org/pod/perlapi">CPAN</a>)
          </div>
        </div>
        <div class="leading-notice">
          You are viewing the version of this documentation from Perl 5.6.1.
            <a href="../perlapi.html">View the latest version</a>
        </div>
        <h1><a id="toc">CONTENTS</a></h1>
                  <ul>
              <li>
                <a class="text-decoration-none" href="#NAME">NAME</a>
              </li>
              <li>
                <a class="text-decoration-none" href="#DESCRIPTION">DESCRIPTION</a>
              </li>
              <li>
                <a class="text-decoration-none" href="#AUTHORS">AUTHORS</a>
              </li>
              <li>
                <a class="text-decoration-none" href="#SEE-ALSO">SEE ALSO</a>
              </li>
          </ul>

      <h1 id="NAME"><a class="permalink" href="#NAME">#</a>NAME</h1>

<p>perlapi - autogenerated documentation for the perl public API</p>

<h1 id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">#</a>DESCRIPTION</h1>

<p>This file contains the documentation of the perl public API generated by embed.pl, specifically a listing of functions, macros, flags, and variables that may be used by extension writers. The interfaces of any functions that are not listed here are subject to change without notice. For this reason, blindly using functions listed in proto.h is to be avoided when writing extensions.</p>

<p>Note that all Perl API global variables must be referenced with the <code>PL_</code> prefix. Some macros are provided for compatibility with the older, unadorned names, but this support may be disabled in a future release.</p>

<p>The listing is alphabetical, case insensitive.</p>

<dl>

<dt id="AvFILL"><a class="permalink" href="#AvFILL">#</a>AvFILL</dt>
<dd>

<p>Same as <code>av_len()</code>. Deprecated, use <code>av_len()</code> instead.</p>

<pre><code class="plaintext">int	AvFILL(AV* av)</code></pre>

</dd>
<dt id="av_clear"><a class="permalink" href="#av_clear">#</a>av_clear</dt>
<dd>

<p>Clears an array, making it empty. Does not free the memory used by the array itself.</p>

<pre><code class="plaintext">void	av_clear(AV* ar)</code></pre>

</dd>
<dt id="av_delete"><a class="permalink" href="#av_delete">#</a>av_delete</dt>
<dd>

<p>Deletes the element indexed by <code>key</code> from the array. Returns the deleted element. <code>flags</code> is currently ignored.</p>

<pre><code class="plaintext">SV*	av_delete(AV* ar, I32 key, I32 flags)</code></pre>

</dd>
<dt id="av_exists"><a class="permalink" href="#av_exists">#</a>av_exists</dt>
<dd>

<p>Returns true if the element indexed by <code>key</code> has been initialized.</p>

<p>This relies on the fact that uninitialized array elements are set to <code>&amp;PL_sv_undef</code>.</p>

<pre><code class="plaintext">bool	av_exists(AV* ar, I32 key)</code></pre>

</dd>
<dt id="av_extend"><a class="permalink" href="#av_extend">#</a>av_extend</dt>
<dd>

<p>Pre-extend an array. The <code>key</code> is the index to which the array should be extended.</p>

<pre><code class="plaintext">void	av_extend(AV* ar, I32 key)</code></pre>

</dd>
<dt id="av_fetch"><a class="permalink" href="#av_fetch">#</a>av_fetch</dt>
<dd>

<p>Returns the SV at the specified index in the array. The <code>key</code> is the index. If <code>lval</code> is set then the fetch will be part of a store. Check that the return value is non-null before dereferencing it to a <code>SV*</code>.</p>

<p>See <a href="perlguts.html#Understanding-the-Magic-of-Tied-Hashes-and-Arrays">&quot;Understanding the Magic of Tied Hashes and Arrays&quot; in perlguts</a> for more information on how to use this function on tied arrays.</p>

<pre><code class="plaintext">SV**	av_fetch(AV* ar, I32 key, I32 lval)</code></pre>

</dd>
<dt id="av_fill"><a class="permalink" href="#av_fill">#</a>av_fill</dt>
<dd>

<p>Ensure than an array has a given number of elements, equivalent to Perl&#39;s <code>$#array = $fill;</code>.</p>

<pre><code class="plaintext">void	av_fill(AV* ar, I32 fill)</code></pre>

</dd>
<dt id="av_len"><a class="permalink" href="#av_len">#</a>av_len</dt>
<dd>

<p>Returns the highest index in the array. Returns -1 if the array is empty.</p>

<pre><code class="plaintext">I32	av_len(AV* ar)</code></pre>

</dd>
<dt id="av_make"><a class="permalink" href="#av_make">#</a>av_make</dt>
<dd>

<p>Creates a new AV and populates it with a list of SVs. The SVs are copied into the array, so they may be freed after the call to av_make. The new AV will have a reference count of 1.</p>

<pre><code class="plaintext">AV*	av_make(I32 size, SV** svp)</code></pre>

</dd>
<dt id="av_pop"><a class="permalink" href="#av_pop">#</a>av_pop</dt>
<dd>

<p>Pops an SV off the end of the array. Returns <code>&amp;PL_sv_undef</code> if the array is empty.</p>

<pre><code class="plaintext">SV*	av_pop(AV* ar)</code></pre>

</dd>
<dt id="av_push"><a class="permalink" href="#av_push">#</a>av_push</dt>
<dd>

<p>Pushes an SV onto the end of the array. The array will grow automatically to accommodate the addition.</p>

<pre><code class="plaintext">void	av_push(AV* ar, SV* val)</code></pre>

</dd>
<dt id="av_shift"><a class="permalink" href="#av_shift">#</a>av_shift</dt>
<dd>

<p>Shifts an SV off the beginning of the array.</p>

<pre><code class="plaintext">SV*	av_shift(AV* ar)</code></pre>

</dd>
<dt id="av_store"><a class="permalink" href="#av_store">#</a>av_store</dt>
<dd>

<p>Stores an SV in an array. The array index is specified as <code>key</code>. The return value will be NULL if the operation failed or if the value did not need to be actually stored within the array (as in the case of tied arrays). Otherwise it can be dereferenced to get the original <code>SV*</code>. Note that the caller is responsible for suitably incrementing the reference count of <code>val</code> before the call, and decrementing it if the function returned NULL.</p>

<p>See <a href="perlguts.html#Understanding-the-Magic-of-Tied-Hashes-and-Arrays">&quot;Understanding the Magic of Tied Hashes and Arrays&quot; in perlguts</a> for more information on how to use this function on tied arrays.</p>

<pre><code class="plaintext">SV**	av_store(AV* ar, I32 key, SV* val)</code></pre>

</dd>
<dt id="av_undef"><a class="permalink" href="#av_undef">#</a>av_undef</dt>
<dd>

<p>Undefines the array. Frees the memory used by the array itself.</p>

<pre><code class="plaintext">void	av_undef(AV* ar)</code></pre>

</dd>
<dt id="av_unshift"><a class="permalink" href="#av_unshift">#</a>av_unshift</dt>
<dd>

<p>Unshift the given number of <code>undef</code> values onto the beginning of the array. The array will grow automatically to accommodate the addition. You must then use <code>av_store</code> to assign values to these new elements.</p>

<pre><code class="plaintext">void	av_unshift(AV* ar, I32 num)</code></pre>

</dd>
<dt id="bytes_from_utf8"><a class="permalink" href="#bytes_from_utf8">#</a>bytes_from_utf8</dt>
<dd>

<p>Converts a string <code>s</code> of length <code>len</code> from UTF8 into byte encoding. Unlike &lt;utf8_to_bytes&gt; but like <code>bytes_to_utf8</code>, returns a pointer to the newly-created string, and updates <code>len</code> to contain the new length. Returns the original string if no conversion occurs, <code>len</code> is unchanged. Do nothing if <code>is_utf8</code> points to 0. Sets <code>is_utf8</code> to 0 if <code>s</code> is converted or contains all 7bit characters.</p>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<pre><code class="plaintext">U8*	bytes_from_utf8(U8 *s, STRLEN *len, bool *is_utf8)</code></pre>

</dd>
<dt id="bytes_to_utf8"><a class="permalink" href="#bytes_to_utf8">#</a>bytes_to_utf8</dt>
<dd>

<p>Converts a string <code>s</code> of length <code>len</code> from ASCII into UTF8 encoding. Returns a pointer to the newly-created string, and sets <code>len</code> to reflect the new length.</p>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<pre><code class="plaintext">U8*	bytes_to_utf8(U8 *s, STRLEN *len)</code></pre>

</dd>
<dt id="call_argv"><a class="permalink" href="#call_argv">#</a>call_argv</dt>
<dd>

<p>Performs a callback to the specified Perl sub. See <a href="perlcall.html">perlcall</a>.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code class="plaintext">I32	call_argv(const char* sub_name, I32 flags, char** argv)</code></pre>

</dd>
<dt id="call_method"><a class="permalink" href="#call_method">#</a>call_method</dt>
<dd>

<p>Performs a callback to the specified Perl method. The blessed object must be on the stack. See <a href="perlcall.html">perlcall</a>.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code class="plaintext">I32	call_method(const char* methname, I32 flags)</code></pre>

</dd>
<dt id="call_pv"><a class="permalink" href="#call_pv">#</a>call_pv</dt>
<dd>

<p>Performs a callback to the specified Perl sub. See <a href="perlcall.html">perlcall</a>.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code class="plaintext">I32	call_pv(const char* sub_name, I32 flags)</code></pre>

</dd>
<dt id="call_sv"><a class="permalink" href="#call_sv">#</a>call_sv</dt>
<dd>

<p>Performs a callback to the Perl sub whose name is in the SV. See <a href="perlcall.html">perlcall</a>.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code class="plaintext">I32	call_sv(SV* sv, I32 flags)</code></pre>

</dd>
<dt id="CLASS"><a class="permalink" href="#CLASS">#</a>CLASS</dt>
<dd>

<p>Variable which is setup by <code>xsubpp</code> to indicate the class name for a C++ XS constructor. This is always a <code>char*</code>. See <code>THIS</code>.</p>

<pre><code class="plaintext">char*	CLASS</code></pre>

</dd>
<dt id="Copy"><a class="permalink" href="#Copy">#</a>Copy</dt>
<dd>

<p>The XSUB-writer&#39;s interface to the C <code>memcpy</code> function. The <code>src</code> is the source, <code>dest</code> is the destination, <code>nitems</code> is the number of items, and <code>type</code> is the type. May fail on overlapping copies. See also <code>Move</code>.</p>

<pre><code class="plaintext">void	Copy(void* src, void* dest, int nitems, type)</code></pre>

</dd>
<dt id="croak"><a class="permalink" href="#croak">#</a>croak</dt>
<dd>

<p>This is the XSUB-writer&#39;s interface to Perl&#39;s <code>die</code> function. Normally use this function the same way you use the C <code>printf</code> function. See <code>warn</code>.</p>

<p>If you want to throw an exception object, assign the object to <code>$@</code> and then pass <code>Nullch</code> to croak():</p>

<pre><code>   errsv = get_sv(&quot;@&quot;, TRUE);
   sv_setsv(errsv, exception_object);
   croak(Nullch);

	void	croak(const char* pat, ...)</code></pre>

</dd>
<dt id="CvSTASH"><a class="permalink" href="#CvSTASH">#</a>CvSTASH</dt>
<dd>

<p>Returns the stash of the CV.</p>

<pre><code class="plaintext">HV*	CvSTASH(CV* cv)</code></pre>

</dd>
<dt id="dMARK"><a class="permalink" href="#dMARK">#</a>dMARK</dt>
<dd>

<p>Declare a stack marker variable, <code>mark</code>, for the XSUB. See <code>MARK</code> and <code>dORIGMARK</code>.</p>

<pre><code>dMARK;</code></pre>

</dd>
<dt id="dORIGMARK"><a class="permalink" href="#dORIGMARK">#</a>dORIGMARK</dt>
<dd>

<p>Saves the original stack mark for the XSUB. See <code>ORIGMARK</code>.</p>

<pre><code>dORIGMARK;</code></pre>

</dd>
<dt id="dSP"><a class="permalink" href="#dSP">#</a>dSP</dt>
<dd>

<p>Declares a local copy of perl&#39;s stack pointer for the XSUB, available via the <code>SP</code> macro. See <code>SP</code>.</p>

<pre><code>dSP;</code></pre>

</dd>
<dt id="dXSARGS"><a class="permalink" href="#dXSARGS">#</a>dXSARGS</dt>
<dd>

<p>Sets up stack and mark pointers for an XSUB, calling dSP and dMARK. This is usually handled automatically by <code>xsubpp</code>. Declares the <code>items</code> variable to indicate the number of items on the stack.</p>

<pre><code>dXSARGS;</code></pre>

</dd>
<dt id="dXSI32"><a class="permalink" href="#dXSI32">#</a>dXSI32</dt>
<dd>

<p>Sets up the <code>ix</code> variable for an XSUB which has aliases. This is usually handled automatically by <code>xsubpp</code>.</p>

<pre><code>dXSI32;</code></pre>

</dd>
<dt id="ENTER"><a class="permalink" href="#ENTER">#</a>ENTER</dt>
<dd>

<p>Opening bracket on a callback. See <code>LEAVE</code> and <a href="perlcall.html">perlcall</a>.</p>

<pre><code>ENTER;</code></pre>

</dd>
<dt id="eval_pv"><a class="permalink" href="#eval_pv">#</a>eval_pv</dt>
<dd>

<p>Tells Perl to <code>eval</code> the given string and return an SV* result.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code class="plaintext">SV*	eval_pv(const char* p, I32 croak_on_error)</code></pre>

</dd>
<dt id="eval_sv"><a class="permalink" href="#eval_sv">#</a>eval_sv</dt>
<dd>

<p>Tells Perl to <code>eval</code> the string in the SV.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code class="plaintext">I32	eval_sv(SV* sv, I32 flags)</code></pre>

</dd>
<dt id="EXTEND"><a class="permalink" href="#EXTEND">#</a>EXTEND</dt>
<dd>

<p>Used to extend the argument stack for an XSUB&#39;s return values. Once used, guarantees that there is room for at least <code>nitems</code> to be pushed onto the stack.</p>

<pre><code class="plaintext">void	EXTEND(SP, int nitems)</code></pre>

</dd>
<dt id="fbm_compile"><a class="permalink" href="#fbm_compile">#</a>fbm_compile</dt>
<dd>

<p>Analyses the string in order to make fast searches on it using fbm_instr() -- the Boyer-Moore algorithm.</p>

<pre><code class="plaintext">void	fbm_compile(SV* sv, U32 flags)</code></pre>

</dd>
<dt id="fbm_instr"><a class="permalink" href="#fbm_instr">#</a>fbm_instr</dt>
<dd>

<p>Returns the location of the SV in the string delimited by <code>str</code> and <code>strend</code>. It returns <code>Nullch</code> if the string can&#39;t be found. The <code>sv</code> does not have to be fbm_compiled, but the search will not be as fast then.</p>

<pre><code class="plaintext">char*	fbm_instr(unsigned char* big, unsigned char* bigend, SV* littlesv, U32 flags)</code></pre>

</dd>
<dt id="FREETMPS"><a class="permalink" href="#FREETMPS">#</a>FREETMPS</dt>
<dd>

<p>Closing bracket for temporaries on a callback. See <code>SAVETMPS</code> and <a href="perlcall.html">perlcall</a>.</p>

<pre><code>FREETMPS;</code></pre>

</dd>
<dt id="get_av"><a class="permalink" href="#get_av">#</a>get_av</dt>
<dd>

<p>Returns the AV of the specified Perl array. If <code>create</code> is set and the Perl variable does not exist then it will be created. If <code>create</code> is not set and the variable does not exist then NULL is returned.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code class="plaintext">AV*	get_av(const char* name, I32 create)</code></pre>

</dd>
<dt id="get_cv"><a class="permalink" href="#get_cv">#</a>get_cv</dt>
<dd>

<p>Returns the CV of the specified Perl subroutine. If <code>create</code> is set and the Perl subroutine does not exist then it will be declared (which has the same effect as saying <code>sub name;</code>). If <code>create</code> is not set and the subroutine does not exist then NULL is returned.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code class="plaintext">CV*	get_cv(const char* name, I32 create)</code></pre>

</dd>
<dt id="get_hv"><a class="permalink" href="#get_hv">#</a>get_hv</dt>
<dd>

<p>Returns the HV of the specified Perl hash. If <code>create</code> is set and the Perl variable does not exist then it will be created. If <code>create</code> is not set and the variable does not exist then NULL is returned.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code class="plaintext">HV*	get_hv(const char* name, I32 create)</code></pre>

</dd>
<dt id="get_sv"><a class="permalink" href="#get_sv">#</a>get_sv</dt>
<dd>

<p>Returns the SV of the specified Perl scalar. If <code>create</code> is set and the Perl variable does not exist then it will be created. If <code>create</code> is not set and the variable does not exist then NULL is returned.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code class="plaintext">SV*	get_sv(const char* name, I32 create)</code></pre>

</dd>
<dt id="GIMME"><a class="permalink" href="#GIMME">#</a>GIMME</dt>
<dd>

<p>A backward-compatible version of <code>GIMME_V</code> which can only return <code>G_SCALAR</code> or <code>G_ARRAY</code>; in a void context, it returns <code>G_SCALAR</code>. Deprecated. Use <code>GIMME_V</code> instead.</p>

<pre><code class="plaintext">U32	GIMME</code></pre>

</dd>
<dt id="GIMME_V"><a class="permalink" href="#GIMME_V">#</a>GIMME_V</dt>
<dd>

<p>The XSUB-writer&#39;s equivalent to Perl&#39;s <code>wantarray</code>. Returns <code>G_VOID</code>, <code>G_SCALAR</code> or <code>G_ARRAY</code> for void, scalar or list context, respectively.</p>

<pre><code class="plaintext">U32	GIMME_V</code></pre>

</dd>
<dt id="GvSV"><a class="permalink" href="#GvSV">#</a>GvSV</dt>
<dd>

<p>Return the SV from the GV.</p>

<pre><code class="plaintext">SV*	GvSV(GV* gv)</code></pre>

</dd>
<dt id="gv_fetchmeth"><a class="permalink" href="#gv_fetchmeth">#</a>gv_fetchmeth</dt>
<dd>

<p>Returns the glob with the given <code>name</code> and a defined subroutine or <code>NULL</code>. The glob lives in the given <code>stash</code>, or in the stashes accessible via @ISA and @UNIVERSAL.</p>

<p>The argument <code>level</code> should be either 0 or -1. If <code>level==0</code>, as a side-effect creates a glob with the given <code>name</code> in the given <code>stash</code> which in the case of success contains an alias for the subroutine, and sets up caching info for this glob. Similarly for all the searched stashes.</p>

<p>This function grants <code>&quot;SUPER&quot;</code> token as a postfix of the stash name. The GV returned from <code>gv_fetchmeth</code> may be a method cache entry, which is not visible to Perl code. So when calling <code>call_sv</code>, you should not use the GV directly; instead, you should use the method&#39;s CV, which can be obtained from the GV with the <code>GvCV</code> macro.</p>

<pre><code class="plaintext">GV*	gv_fetchmeth(HV* stash, const char* name, STRLEN len, I32 level)</code></pre>

</dd>
<dt id="gv_fetchmethod"><a class="permalink" href="#gv_fetchmethod">#</a>gv_fetchmethod</dt>
<dd>

<p>See <a href="https://metacpan.org/pod/gv_fetchmethod_autoload">gv_fetchmethod_autoload</a>.</p>

<pre><code class="plaintext">GV*	gv_fetchmethod(HV* stash, const char* name)</code></pre>

</dd>
<dt id="gv_fetchmethod_autoload"><a class="permalink" href="#gv_fetchmethod_autoload">#</a>gv_fetchmethod_autoload</dt>
<dd>

<p>Returns the glob which contains the subroutine to call to invoke the method on the <code>stash</code>. In fact in the presence of autoloading this may be the glob for &quot;AUTOLOAD&quot;. In this case the corresponding variable $AUTOLOAD is already setup.</p>

<p>The third parameter of <code>gv_fetchmethod_autoload</code> determines whether AUTOLOAD lookup is performed if the given method is not present: non-zero means yes, look for AUTOLOAD; zero means no, don&#39;t look for AUTOLOAD. Calling <code>gv_fetchmethod</code> is equivalent to calling <code>gv_fetchmethod_autoload</code> with a non-zero <code>autoload</code> parameter.</p>

<p>These functions grant <code>&quot;SUPER&quot;</code> token as a prefix of the method name. Note that if you want to keep the returned glob for a long time, you need to check for it being &quot;AUTOLOAD&quot;, since at the later time the call may load a different subroutine due to $AUTOLOAD changing its value. Use the glob created via a side effect to do this.</p>

<p>These functions have the same side-effects and as <code>gv_fetchmeth</code> with <code>level==0</code>. <code>name</code> should be writable if contains <code>&#39;:&#39;</code> or <code>&#39; &#39;&#39;</code>. The warning against passing the GV returned by <code>gv_fetchmeth</code> to <code>call_sv</code> apply equally to these functions.</p>

<pre><code class="plaintext">GV*	gv_fetchmethod_autoload(HV* stash, const char* name, I32 autoload)</code></pre>

</dd>
<dt id="gv_stashpv"><a class="permalink" href="#gv_stashpv">#</a>gv_stashpv</dt>
<dd>

<p>Returns a pointer to the stash for a specified package. <code>name</code> should be a valid UTF-8 string. If <code>create</code> is set then the package will be created if it does not already exist. If <code>create</code> is not set and the package does not exist then NULL is returned.</p>

<pre><code class="plaintext">HV*	gv_stashpv(const char* name, I32 create)</code></pre>

</dd>
<dt id="gv_stashsv"><a class="permalink" href="#gv_stashsv">#</a>gv_stashsv</dt>
<dd>

<p>Returns a pointer to the stash for a specified package, which must be a valid UTF-8 string. See <code>gv_stashpv</code>.</p>

<pre><code class="plaintext">HV*	gv_stashsv(SV* sv, I32 create)</code></pre>

</dd>
<dt id="G_ARRAY"><a class="permalink" href="#G_ARRAY">#</a>G_ARRAY</dt>
<dd>

<p>Used to indicate list context. See <code>GIMME_V</code>, <code>GIMME</code> and <a href="perlcall.html">perlcall</a>.</p>

</dd>
<dt id="G_DISCARD"><a class="permalink" href="#G_DISCARD">#</a>G_DISCARD</dt>
<dd>

<p>Indicates that arguments returned from a callback should be discarded. See <a href="perlcall.html">perlcall</a>.</p>

</dd>
<dt id="G_EVAL"><a class="permalink" href="#G_EVAL">#</a>G_EVAL</dt>
<dd>

<p>Used to force a Perl <code>eval</code> wrapper around a callback. See <a href="perlcall.html">perlcall</a>.</p>

</dd>
<dt id="G_NOARGS"><a class="permalink" href="#G_NOARGS">#</a>G_NOARGS</dt>
<dd>

<p>Indicates that no arguments are being sent to a callback. See <a href="perlcall.html">perlcall</a>.</p>

</dd>
<dt id="G_SCALAR"><a class="permalink" href="#G_SCALAR">#</a>G_SCALAR</dt>
<dd>

<p>Used to indicate scalar context. See <code>GIMME_V</code>, <code>GIMME</code>, and <a href="perlcall.html">perlcall</a>.</p>

</dd>
<dt id="G_VOID"><a class="permalink" href="#G_VOID">#</a>G_VOID</dt>
<dd>

<p>Used to indicate void context. See <code>GIMME_V</code> and <a href="perlcall.html">perlcall</a>.</p>

</dd>
<dt id="HEf_SVKEY"><a class="permalink" href="#HEf_SVKEY">#</a>HEf_SVKEY</dt>
<dd>

<p>This flag, used in the length slot of hash entries and magic structures, specifies the structure contains a <code>SV*</code> pointer where a <code>char*</code> pointer is to be expected. (For information only--not to be used).</p>

</dd>
<dt id="HeHASH"><a class="permalink" href="#HeHASH">#</a>HeHASH</dt>
<dd>

<p>Returns the computed hash stored in the hash entry.</p>

<pre><code class="plaintext">U32	HeHASH(HE* he)</code></pre>

</dd>
<dt id="HeKEY"><a class="permalink" href="#HeKEY">#</a>HeKEY</dt>
<dd>

<p>Returns the actual pointer stored in the key slot of the hash entry. The pointer may be either <code>char*</code> or <code>SV*</code>, depending on the value of <code>HeKLEN()</code>. Can be assigned to. The <code>HePV()</code> or <code>HeSVKEY()</code> macros are usually preferable for finding the value of a key.</p>

<pre><code class="plaintext">void*	HeKEY(HE* he)</code></pre>

</dd>
<dt id="HeKLEN"><a class="permalink" href="#HeKLEN">#</a>HeKLEN</dt>
<dd>

<p>If this is negative, and amounts to <code>HEf_SVKEY</code>, it indicates the entry holds an <code>SV*</code> key. Otherwise, holds the actual length of the key. Can be assigned to. The <code>HePV()</code> macro is usually preferable for finding key lengths.</p>

<pre><code class="plaintext">STRLEN	HeKLEN(HE* he)</code></pre>

</dd>
<dt id="HePV"><a class="permalink" href="#HePV">#</a>HePV</dt>
<dd>

<p>Returns the key slot of the hash entry as a <code>char*</code> value, doing any necessary dereferencing of possibly <code>SV*</code> keys. The length of the string is placed in <code>len</code> (this is a macro, so do <i>not</i> use <code>&amp;len</code>). If you do not care about what the length of the key is, you may use the global variable <code>PL_na</code>, though this is rather less efficient than using a local variable. Remember though, that hash keys in perl are free to contain embedded nulls, so using <code>strlen()</code> or similar is not a good way to find the length of hash keys. This is very similar to the <code>SvPV()</code> macro described elsewhere in this document.</p>

<pre><code class="plaintext">char*	HePV(HE* he, STRLEN len)</code></pre>

</dd>
<dt id="HeSVKEY"><a class="permalink" href="#HeSVKEY">#</a>HeSVKEY</dt>
<dd>

<p>Returns the key as an <code>SV*</code>, or <code>Nullsv</code> if the hash entry does not contain an <code>SV*</code> key.</p>

<pre><code class="plaintext">SV*	HeSVKEY(HE* he)</code></pre>

</dd>
<dt id="HeSVKEY_force"><a class="permalink" href="#HeSVKEY_force">#</a>HeSVKEY_force</dt>
<dd>

<p>Returns the key as an <code>SV*</code>. Will create and return a temporary mortal <code>SV*</code> if the hash entry contains only a <code>char*</code> key.</p>

<pre><code class="plaintext">SV*	HeSVKEY_force(HE* he)</code></pre>

</dd>
<dt id="HeSVKEY_set"><a class="permalink" href="#HeSVKEY_set">#</a>HeSVKEY_set</dt>
<dd>

<p>Sets the key to a given <code>SV*</code>, taking care to set the appropriate flags to indicate the presence of an <code>SV*</code> key, and returns the same <code>SV*</code>.</p>

<pre><code class="plaintext">SV*	HeSVKEY_set(HE* he, SV* sv)</code></pre>

</dd>
<dt id="HeVAL"><a class="permalink" href="#HeVAL">#</a>HeVAL</dt>
<dd>

<p>Returns the value slot (type <code>SV*</code>) stored in the hash entry.</p>

<pre><code class="plaintext">SV*	HeVAL(HE* he)</code></pre>

</dd>
<dt id="HvNAME"><a class="permalink" href="#HvNAME">#</a>HvNAME</dt>
<dd>

<p>Returns the package name of a stash. See <code>SvSTASH</code>, <code>CvSTASH</code>.</p>

<pre><code class="plaintext">char*	HvNAME(HV* stash)</code></pre>

</dd>
<dt id="hv_clear"><a class="permalink" href="#hv_clear">#</a>hv_clear</dt>
<dd>

<p>Clears a hash, making it empty.</p>

<pre><code class="plaintext">void	hv_clear(HV* tb)</code></pre>

</dd>
<dt id="hv_delete"><a class="permalink" href="#hv_delete">#</a>hv_delete</dt>
<dd>

<p>Deletes a key/value pair in the hash. The value SV is removed from the hash and returned to the caller. The <code>klen</code> is the length of the key. The <code>flags</code> value will normally be zero; if set to G_DISCARD then NULL will be returned.</p>

<pre><code class="plaintext">SV*	hv_delete(HV* tb, const char* key, U32 klen, I32 flags)</code></pre>

</dd>
<dt id="hv_delete_ent"><a class="permalink" href="#hv_delete_ent">#</a>hv_delete_ent</dt>
<dd>

<p>Deletes a key/value pair in the hash. The value SV is removed from the hash and returned to the caller. The <code>flags</code> value will normally be zero; if set to G_DISCARD then NULL will be returned. <code>hash</code> can be a valid precomputed hash value, or 0 to ask for it to be computed.</p>

<pre><code class="plaintext">SV*	hv_delete_ent(HV* tb, SV* key, I32 flags, U32 hash)</code></pre>

</dd>
<dt id="hv_exists"><a class="permalink" href="#hv_exists">#</a>hv_exists</dt>
<dd>

<p>Returns a boolean indicating whether the specified hash key exists. The <code>klen</code> is the length of the key.</p>

<pre><code class="plaintext">bool	hv_exists(HV* tb, const char* key, U32 klen)</code></pre>

</dd>
<dt id="hv_exists_ent"><a class="permalink" href="#hv_exists_ent">#</a>hv_exists_ent</dt>
<dd>

<p>Returns a boolean indicating whether the specified hash key exists. <code>hash</code> can be a valid precomputed hash value, or 0 to ask for it to be computed.</p>

<pre><code class="plaintext">bool	hv_exists_ent(HV* tb, SV* key, U32 hash)</code></pre>

</dd>
<dt id="hv_fetch"><a class="permalink" href="#hv_fetch">#</a>hv_fetch</dt>
<dd>

<p>Returns the SV which corresponds to the specified key in the hash. The <code>klen</code> is the length of the key. If <code>lval</code> is set then the fetch will be part of a store. Check that the return value is non-null before dereferencing it to a <code>SV*</code>.</p>

<p>See <a href="perlguts.html#Understanding-the-Magic-of-Tied-Hashes-and-Arrays">&quot;Understanding the Magic of Tied Hashes and Arrays&quot; in perlguts</a> for more information on how to use this function on tied hashes.</p>

<pre><code class="plaintext">SV**	hv_fetch(HV* tb, const char* key, U32 klen, I32 lval)</code></pre>

</dd>
<dt id="hv_fetch_ent"><a class="permalink" href="#hv_fetch_ent">#</a>hv_fetch_ent</dt>
<dd>

<p>Returns the hash entry which corresponds to the specified key in the hash. <code>hash</code> must be a valid precomputed hash number for the given <code>key</code>, or 0 if you want the function to compute it. IF <code>lval</code> is set then the fetch will be part of a store. Make sure the return value is non-null before accessing it. The return value when <code>tb</code> is a tied hash is a pointer to a static location, so be sure to make a copy of the structure if you need to store it somewhere.</p>

<p>See <a href="perlguts.html#Understanding-the-Magic-of-Tied-Hashes-and-Arrays">&quot;Understanding the Magic of Tied Hashes and Arrays&quot; in perlguts</a> for more information on how to use this function on tied hashes.</p>

<pre><code class="plaintext">HE*	hv_fetch_ent(HV* tb, SV* key, I32 lval, U32 hash)</code></pre>

</dd>
<dt id="hv_iterinit"><a class="permalink" href="#hv_iterinit">#</a>hv_iterinit</dt>
<dd>

<p>Prepares a starting point to traverse a hash table. Returns the number of keys in the hash (i.e. the same as <code>HvKEYS(tb)</code>). The return value is currently only meaningful for hashes without tie magic.</p>

<p>NOTE: Before version 5.004_65, <code>hv_iterinit</code> used to return the number of hash buckets that happen to be in use. If you still need that esoteric value, you can get it through the macro <code>HvFILL(tb)</code>.</p>

<pre><code class="plaintext">I32	hv_iterinit(HV* tb)</code></pre>

</dd>
<dt id="hv_iterkey"><a class="permalink" href="#hv_iterkey">#</a>hv_iterkey</dt>
<dd>

<p>Returns the key from the current position of the hash iterator. See <code>hv_iterinit</code>.</p>

<pre><code class="plaintext">char*	hv_iterkey(HE* entry, I32* retlen)</code></pre>

</dd>
<dt id="hv_iterkeysv"><a class="permalink" href="#hv_iterkeysv">#</a>hv_iterkeysv</dt>
<dd>

<p>Returns the key as an <code>SV*</code> from the current position of the hash iterator. The return value will always be a mortal copy of the key. Also see <code>hv_iterinit</code>.</p>

<pre><code class="plaintext">SV*	hv_iterkeysv(HE* entry)</code></pre>

</dd>
<dt id="hv_iternext"><a class="permalink" href="#hv_iternext">#</a>hv_iternext</dt>
<dd>

<p>Returns entries from a hash iterator. See <code>hv_iterinit</code>.</p>

<pre><code class="plaintext">HE*	hv_iternext(HV* tb)</code></pre>

</dd>
<dt id="hv_iternextsv"><a class="permalink" href="#hv_iternextsv">#</a>hv_iternextsv</dt>
<dd>

<p>Performs an <code>hv_iternext</code>, <code>hv_iterkey</code>, and <code>hv_iterval</code> in one operation.</p>

<pre><code class="plaintext">SV*	hv_iternextsv(HV* hv, char** key, I32* retlen)</code></pre>

</dd>
<dt id="hv_iterval"><a class="permalink" href="#hv_iterval">#</a>hv_iterval</dt>
<dd>

<p>Returns the value from the current position of the hash iterator. See <code>hv_iterkey</code>.</p>

<pre><code class="plaintext">SV*	hv_iterval(HV* tb, HE* entry)</code></pre>

</dd>
<dt id="hv_magic"><a class="permalink" href="#hv_magic">#</a>hv_magic</dt>
<dd>

<p>Adds magic to a hash. See <code>sv_magic</code>.</p>

<pre><code class="plaintext">void	hv_magic(HV* hv, GV* gv, int how)</code></pre>

</dd>
<dt id="hv_store"><a class="permalink" href="#hv_store">#</a>hv_store</dt>
<dd>

<p>Stores an SV in a hash. The hash key is specified as <code>key</code> and <code>klen</code> is the length of the key. The <code>hash</code> parameter is the precomputed hash value; if it is zero then Perl will compute it. The return value will be NULL if the operation failed or if the value did not need to be actually stored within the hash (as in the case of tied hashes). Otherwise it can be dereferenced to get the original <code>SV*</code>. Note that the caller is responsible for suitably incrementing the reference count of <code>val</code> before the call, and decrementing it if the function returned NULL.</p>

<p>See <a href="perlguts.html#Understanding-the-Magic-of-Tied-Hashes-and-Arrays">&quot;Understanding the Magic of Tied Hashes and Arrays&quot; in perlguts</a> for more information on how to use this function on tied hashes.</p>

<pre><code class="plaintext">SV**	hv_store(HV* tb, const char* key, U32 klen, SV* val, U32 hash)</code></pre>

</dd>
<dt id="hv_store_ent"><a class="permalink" href="#hv_store_ent">#</a>hv_store_ent</dt>
<dd>

<p>Stores <code>val</code> in a hash. The hash key is specified as <code>key</code>. The <code>hash</code> parameter is the precomputed hash value; if it is zero then Perl will compute it. The return value is the new hash entry so created. It will be NULL if the operation failed or if the value did not need to be actually stored within the hash (as in the case of tied hashes). Otherwise the contents of the return value can be accessed using the <code>He???</code> macros described here. Note that the caller is responsible for suitably incrementing the reference count of <code>val</code> before the call, and decrementing it if the function returned NULL.</p>

<p>See <a href="perlguts.html#Understanding-the-Magic-of-Tied-Hashes-and-Arrays">&quot;Understanding the Magic of Tied Hashes and Arrays&quot; in perlguts</a> for more information on how to use this function on tied hashes.</p>

<pre><code class="plaintext">HE*	hv_store_ent(HV* tb, SV* key, SV* val, U32 hash)</code></pre>

</dd>
<dt id="hv_undef"><a class="permalink" href="#hv_undef">#</a>hv_undef</dt>
<dd>

<p>Undefines the hash.</p>

<pre><code class="plaintext">void	hv_undef(HV* tb)</code></pre>

</dd>
<dt id="isALNUM"><a class="permalink" href="#isALNUM">#</a>isALNUM</dt>
<dd>

<p>Returns a boolean indicating whether the C <code>char</code> is an ASCII alphanumeric character (including underscore) or digit.</p>

<pre><code class="plaintext">bool	isALNUM(char ch)</code></pre>

</dd>
<dt id="isALPHA"><a class="permalink" href="#isALPHA">#</a>isALPHA</dt>
<dd>

<p>Returns a boolean indicating whether the C <code>char</code> is an ASCII alphabetic character.</p>

<pre><code class="plaintext">bool	isALPHA(char ch)</code></pre>

</dd>
<dt id="isDIGIT"><a class="permalink" href="#isDIGIT">#</a>isDIGIT</dt>
<dd>

<p>Returns a boolean indicating whether the C <code>char</code> is an ASCII digit.</p>

<pre><code class="plaintext">bool	isDIGIT(char ch)</code></pre>

</dd>
<dt id="isLOWER"><a class="permalink" href="#isLOWER">#</a>isLOWER</dt>
<dd>

<p>Returns a boolean indicating whether the C <code>char</code> is a lowercase character.</p>

<pre><code class="plaintext">bool	isLOWER(char ch)</code></pre>

</dd>
<dt id="isSPACE"><a class="permalink" href="#isSPACE">#</a>isSPACE</dt>
<dd>

<p>Returns a boolean indicating whether the C <code>char</code> is whitespace.</p>

<pre><code class="plaintext">bool	isSPACE(char ch)</code></pre>

</dd>
<dt id="isUPPER"><a class="permalink" href="#isUPPER">#</a>isUPPER</dt>
<dd>

<p>Returns a boolean indicating whether the C <code>char</code> is an uppercase character.</p>

<pre><code class="plaintext">bool	isUPPER(char ch)</code></pre>

</dd>
<dt id="is_utf8_char"><a class="permalink" href="#is_utf8_char">#</a>is_utf8_char</dt>
<dd>

<p>Tests if some arbitrary number of bytes begins in a valid UTF-8 character. The actual number of bytes in the UTF-8 character will be returned if it is valid, otherwise 0.</p>

<pre><code class="plaintext">STRLEN	is_utf8_char(U8 *p)</code></pre>

</dd>
<dt id="is_utf8_string"><a class="permalink" href="#is_utf8_string">#</a>is_utf8_string</dt>
<dd>

<p>Returns true if first <code>len</code> bytes of the given string form valid a UTF8 string, false otherwise.</p>

<pre><code class="plaintext">bool	is_utf8_string(U8 *s, STRLEN len)</code></pre>

</dd>
<dt id="items"><a class="permalink" href="#items">#</a>items</dt>
<dd>

<p>Variable which is setup by <code>xsubpp</code> to indicate the number of items on the stack. See <a href="perlxs.html#Variable-length-Parameter-Lists">&quot;Variable-length Parameter Lists&quot; in perlxs</a>.</p>

<pre><code class="plaintext">I32	items</code></pre>

</dd>
<dt id="ix"><a class="permalink" href="#ix">#</a>ix</dt>
<dd>

<p>Variable which is setup by <code>xsubpp</code> to indicate which of an XSUB&#39;s aliases was used to invoke it. See <a href="perlxs.html#The-ALIAS%3A-Keyword">&quot;The ALIAS: Keyword&quot; in perlxs</a>.</p>

<pre><code class="plaintext">I32	ix</code></pre>

</dd>
<dt id="LEAVE"><a class="permalink" href="#LEAVE">#</a>LEAVE</dt>
<dd>

<p>Closing bracket on a callback. See <code>ENTER</code> and <a href="perlcall.html">perlcall</a>.</p>

<pre><code>LEAVE;</code></pre>

</dd>
<dt id="looks_like_number"><a class="permalink" href="#looks_like_number">#</a>looks_like_number</dt>
<dd>

<p>Test if an the content of an SV looks like a number (or is a number).</p>

<pre><code class="plaintext">I32	looks_like_number(SV* sv)</code></pre>

</dd>
<dt id="MARK"><a class="permalink" href="#MARK">#</a>MARK</dt>
<dd>

<p>Stack marker variable for the XSUB. See <code>dMARK</code>.</p>

</dd>
<dt id="mg_clear"><a class="permalink" href="#mg_clear">#</a>mg_clear</dt>
<dd>

<p>Clear something magical that the SV represents. See <code>sv_magic</code>.</p>

<pre><code class="plaintext">int	mg_clear(SV* sv)</code></pre>

</dd>
<dt id="mg_copy"><a class="permalink" href="#mg_copy">#</a>mg_copy</dt>
<dd>

<p>Copies the magic from one SV to another. See <code>sv_magic</code>.</p>

<pre><code class="plaintext">int	mg_copy(SV* sv, SV* nsv, const char* key, I32 klen)</code></pre>

</dd>
<dt id="mg_find"><a class="permalink" href="#mg_find">#</a>mg_find</dt>
<dd>

<p>Finds the magic pointer for type matching the SV. See <code>sv_magic</code>.</p>

<pre><code class="plaintext">MAGIC*	mg_find(SV* sv, int type)</code></pre>

</dd>
<dt id="mg_free"><a class="permalink" href="#mg_free">#</a>mg_free</dt>
<dd>

<p>Free any magic storage used by the SV. See <code>sv_magic</code>.</p>

<pre><code class="plaintext">int	mg_free(SV* sv)</code></pre>

</dd>
<dt id="mg_get"><a class="permalink" href="#mg_get">#</a>mg_get</dt>
<dd>

<p>Do magic after a value is retrieved from the SV. See <code>sv_magic</code>.</p>

<pre><code class="plaintext">int	mg_get(SV* sv)</code></pre>

</dd>
<dt id="mg_length"><a class="permalink" href="#mg_length">#</a>mg_length</dt>
<dd>

<p>Report on the SV&#39;s length. See <code>sv_magic</code>.</p>

<pre><code class="plaintext">U32	mg_length(SV* sv)</code></pre>

</dd>
<dt id="mg_magical"><a class="permalink" href="#mg_magical">#</a>mg_magical</dt>
<dd>

<p>Turns on the magical status of an SV. See <code>sv_magic</code>.</p>

<pre><code class="plaintext">void	mg_magical(SV* sv)</code></pre>

</dd>
<dt id="mg_set"><a class="permalink" href="#mg_set">#</a>mg_set</dt>
<dd>

<p>Do magic after a value is assigned to the SV. See <code>sv_magic</code>.</p>

<pre><code class="plaintext">int	mg_set(SV* sv)</code></pre>

</dd>
<dt id="Move"><a class="permalink" href="#Move">#</a>Move</dt>
<dd>

<p>The XSUB-writer&#39;s interface to the C <code>memmove</code> function. The <code>src</code> is the source, <code>dest</code> is the destination, <code>nitems</code> is the number of items, and <code>type</code> is the type. Can do overlapping moves. See also <code>Copy</code>.</p>

<pre><code class="plaintext">void	Move(void* src, void* dest, int nitems, type)</code></pre>

</dd>
<dt id="New"><a class="permalink" href="#New">#</a>New</dt>
<dd>

<p>The XSUB-writer&#39;s interface to the C <code>malloc</code> function.</p>

<pre><code class="plaintext">void	New(int id, void* ptr, int nitems, type)</code></pre>

</dd>
<dt id="newAV"><a class="permalink" href="#newAV">#</a>newAV</dt>
<dd>

<p>Creates a new AV. The reference count is set to 1.</p>

<pre><code class="plaintext">AV*	newAV()</code></pre>

</dd>
<dt id="Newc"><a class="permalink" href="#Newc">#</a>Newc</dt>
<dd>

<p>The XSUB-writer&#39;s interface to the C <code>malloc</code> function, with cast.</p>

<pre><code class="plaintext">void	Newc(int id, void* ptr, int nitems, type, cast)</code></pre>

</dd>
<dt id="newCONSTSUB"><a class="permalink" href="#newCONSTSUB">#</a>newCONSTSUB</dt>
<dd>

<p>Creates a constant sub equivalent to Perl <code>sub FOO () { 123 }</code> which is eligible for inlining at compile-time.</p>

<pre><code class="plaintext">void	newCONSTSUB(HV* stash, char* name, SV* sv)</code></pre>

</dd>
<dt id="newHV"><a class="permalink" href="#newHV">#</a>newHV</dt>
<dd>

<p>Creates a new HV. The reference count is set to 1.</p>

<pre><code class="plaintext">HV*	newHV()</code></pre>

</dd>
<dt id="newRV_inc"><a class="permalink" href="#newRV_inc">#</a>newRV_inc</dt>
<dd>

<p>Creates an RV wrapper for an SV. The reference count for the original SV is incremented.</p>

<pre><code class="plaintext">SV*	newRV_inc(SV* sv)</code></pre>

</dd>
<dt id="newRV_noinc"><a class="permalink" href="#newRV_noinc">#</a>newRV_noinc</dt>
<dd>

<p>Creates an RV wrapper for an SV. The reference count for the original SV is <b>not</b> incremented.</p>

<pre><code class="plaintext">SV*	newRV_noinc(SV *sv)</code></pre>

</dd>
<dt id="NEWSV"><a class="permalink" href="#NEWSV">#</a>NEWSV</dt>
<dd>

<p>Creates a new SV. A non-zero <code>len</code> parameter indicates the number of bytes of preallocated string space the SV should have. An extra byte for a tailing NUL is also reserved. (SvPOK is not set for the SV even if string space is allocated.) The reference count for the new SV is set to 1. <code>id</code> is an integer id between 0 and 1299 (used to identify leaks).</p>

<pre><code class="plaintext">SV*	NEWSV(int id, STRLEN len)</code></pre>

</dd>
<dt id="newSViv"><a class="permalink" href="#newSViv">#</a>newSViv</dt>
<dd>

<p>Creates a new SV and copies an integer into it. The reference count for the SV is set to 1.</p>

<pre><code class="plaintext">SV*	newSViv(IV i)</code></pre>

</dd>
<dt id="newSVnv"><a class="permalink" href="#newSVnv">#</a>newSVnv</dt>
<dd>

<p>Creates a new SV and copies a floating point value into it. The reference count for the SV is set to 1.</p>

<pre><code class="plaintext">SV*	newSVnv(NV n)</code></pre>

</dd>
<dt id="newSVpv"><a class="permalink" href="#newSVpv">#</a>newSVpv</dt>
<dd>

<p>Creates a new SV and copies a string into it. The reference count for the SV is set to 1. If <code>len</code> is zero, Perl will compute the length using strlen(). For efficiency, consider using <code>newSVpvn</code> instead.</p>

<pre><code class="plaintext">SV*	newSVpv(const char* s, STRLEN len)</code></pre>

</dd>
<dt id="newSVpvf"><a class="permalink" href="#newSVpvf">#</a>newSVpvf</dt>
<dd>

<p>Creates a new SV an initialize it with the string formatted like <code>sprintf</code>.</p>

<pre><code class="plaintext">SV*	newSVpvf(const char* pat, ...)</code></pre>

</dd>
<dt id="newSVpvn"><a class="permalink" href="#newSVpvn">#</a>newSVpvn</dt>
<dd>

<p>Creates a new SV and copies a string into it. The reference count for the SV is set to 1. Note that if <code>len</code> is zero, Perl will create a zero length string. You are responsible for ensuring that the source string is at least <code>len</code> bytes long.</p>

<pre><code class="plaintext">SV*	newSVpvn(const char* s, STRLEN len)</code></pre>

</dd>
<dt id="newSVrv"><a class="permalink" href="#newSVrv">#</a>newSVrv</dt>
<dd>

<p>Creates a new SV for the RV, <code>rv</code>, to point to. If <code>rv</code> is not an RV then it will be upgraded to one. If <code>classname</code> is non-null then the new SV will be blessed in the specified package. The new SV is returned and its reference count is 1.</p>

<pre><code class="plaintext">SV*	newSVrv(SV* rv, const char* classname)</code></pre>

</dd>
<dt id="newSVsv"><a class="permalink" href="#newSVsv">#</a>newSVsv</dt>
<dd>

<p>Creates a new SV which is an exact duplicate of the original SV.</p>

<pre><code class="plaintext">SV*	newSVsv(SV* old)</code></pre>

</dd>
<dt id="newSVuv"><a class="permalink" href="#newSVuv">#</a>newSVuv</dt>
<dd>

<p>Creates a new SV and copies an unsigned integer into it. The reference count for the SV is set to 1.</p>

<pre><code class="plaintext">SV*	newSVuv(UV u)</code></pre>

</dd>
<dt id="newXS"><a class="permalink" href="#newXS">#</a>newXS</dt>
<dd>

<p>Used by <code>xsubpp</code> to hook up XSUBs as Perl subs.</p>

</dd>
<dt id="newXSproto"><a class="permalink" href="#newXSproto">#</a>newXSproto</dt>
<dd>

<p>Used by <code>xsubpp</code> to hook up XSUBs as Perl subs. Adds Perl prototypes to the subs.</p>

</dd>
<dt id="Newz"><a class="permalink" href="#Newz">#</a>Newz</dt>
<dd>

<p>The XSUB-writer&#39;s interface to the C <code>malloc</code> function. The allocated memory is zeroed with <code>memzero</code>.</p>

<pre><code class="plaintext">void	Newz(int id, void* ptr, int nitems, type)</code></pre>

</dd>
<dt id="Nullav"><a class="permalink" href="#Nullav">#</a>Nullav</dt>
<dd>

<p>Null AV pointer.</p>

</dd>
<dt id="Nullch"><a class="permalink" href="#Nullch">#</a>Nullch</dt>
<dd>

<p>Null character pointer.</p>

</dd>
<dt id="Nullcv"><a class="permalink" href="#Nullcv">#</a>Nullcv</dt>
<dd>

<p>Null CV pointer.</p>

</dd>
<dt id="Nullhv"><a class="permalink" href="#Nullhv">#</a>Nullhv</dt>
<dd>

<p>Null HV pointer.</p>

</dd>
<dt id="Nullsv"><a class="permalink" href="#Nullsv">#</a>Nullsv</dt>
<dd>

<p>Null SV pointer.</p>

</dd>
<dt id="ORIGMARK"><a class="permalink" href="#ORIGMARK">#</a>ORIGMARK</dt>
<dd>

<p>The original stack mark for the XSUB. See <code>dORIGMARK</code>.</p>

</dd>
<dt id="perl_alloc"><a class="permalink" href="#perl_alloc">#</a>perl_alloc</dt>
<dd>

<p>Allocates a new Perl interpreter. See <a href="perlembed.html">perlembed</a>.</p>

<pre><code class="plaintext">PerlInterpreter*	perl_alloc()</code></pre>

</dd>
<dt id="perl_construct"><a class="permalink" href="#perl_construct">#</a>perl_construct</dt>
<dd>

<p>Initializes a new Perl interpreter. See <a href="perlembed.html">perlembed</a>.</p>

<pre><code class="plaintext">void	perl_construct(PerlInterpreter* interp)</code></pre>

</dd>
<dt id="perl_destruct"><a class="permalink" href="#perl_destruct">#</a>perl_destruct</dt>
<dd>

<p>Shuts down a Perl interpreter. See <a href="perlembed.html">perlembed</a>.</p>

<pre><code class="plaintext">void	perl_destruct(PerlInterpreter* interp)</code></pre>

</dd>
<dt id="perl_free"><a class="permalink" href="#perl_free">#</a>perl_free</dt>
<dd>

<p>Releases a Perl interpreter. See <a href="perlembed.html">perlembed</a>.</p>

<pre><code class="plaintext">void	perl_free(PerlInterpreter* interp)</code></pre>

</dd>
<dt id="perl_parse"><a class="permalink" href="#perl_parse">#</a>perl_parse</dt>
<dd>

<p>Tells a Perl interpreter to parse a Perl script. See <a href="perlembed.html">perlembed</a>.</p>

<pre><code class="plaintext">int	perl_parse(PerlInterpreter* interp, XSINIT_t xsinit, int argc, char** argv, char** env)</code></pre>

</dd>
<dt id="perl_run"><a class="permalink" href="#perl_run">#</a>perl_run</dt>
<dd>

<p>Tells a Perl interpreter to run. See <a href="perlembed.html">perlembed</a>.</p>

<pre><code class="plaintext">int	perl_run(PerlInterpreter* interp)</code></pre>

</dd>
<dt id="PL_modglobal"><a class="permalink" href="#PL_modglobal">#</a>PL_modglobal</dt>
<dd>

<p><code>PL_modglobal</code> is a general purpose, interpreter global HV for use by extensions that need to keep information on a per-interpreter basis. In a pinch, it can also be used as a symbol table for extensions to share data among each other. It is a good idea to use keys prefixed by the package name of the extension that owns the data.</p>

<pre><code class="plaintext">HV*	PL_modglobal</code></pre>

</dd>
<dt id="PL_na"><a class="permalink" href="#PL_na">#</a>PL_na</dt>
<dd>

<p>A convenience variable which is typically used with <code>SvPV</code> when one doesn&#39;t care about the length of the string. It is usually more efficient to either declare a local variable and use that instead or to use the <code>SvPV_nolen</code> macro.</p>

<pre><code class="plaintext">STRLEN	PL_na</code></pre>

</dd>
<dt id="PL_sv_no"><a class="permalink" href="#PL_sv_no">#</a>PL_sv_no</dt>
<dd>

<p>This is the <code>false</code> SV. See <code>PL_sv_yes</code>. Always refer to this as <code>&amp;PL_sv_no</code>.</p>

<pre><code class="plaintext">SV	PL_sv_no</code></pre>

</dd>
<dt id="PL_sv_undef"><a class="permalink" href="#PL_sv_undef">#</a>PL_sv_undef</dt>
<dd>

<p>This is the <code>undef</code> SV. Always refer to this as <code>&amp;PL_sv_undef</code>.</p>

<pre><code class="plaintext">SV	PL_sv_undef</code></pre>

</dd>
<dt id="PL_sv_yes"><a class="permalink" href="#PL_sv_yes">#</a>PL_sv_yes</dt>
<dd>

<p>This is the <code>true</code> SV. See <code>PL_sv_no</code>. Always refer to this as <code>&amp;PL_sv_yes</code>.</p>

<pre><code class="plaintext">SV	PL_sv_yes</code></pre>

</dd>
<dt id="POPi"><a class="permalink" href="#POPi">#</a>POPi</dt>
<dd>

<p>Pops an integer off the stack.</p>

<pre><code class="plaintext">IV	POPi</code></pre>

</dd>
<dt id="POPl"><a class="permalink" href="#POPl">#</a>POPl</dt>
<dd>

<p>Pops a long off the stack.</p>

<pre><code class="plaintext">long	POPl</code></pre>

</dd>
<dt id="POPn"><a class="permalink" href="#POPn">#</a>POPn</dt>
<dd>

<p>Pops a double off the stack.</p>

<pre><code class="plaintext">NV	POPn</code></pre>

</dd>
<dt id="POPp"><a class="permalink" href="#POPp">#</a>POPp</dt>
<dd>

<p>Pops a string off the stack.</p>

<pre><code class="plaintext">char*	POPp</code></pre>

</dd>
<dt id="POPs"><a class="permalink" href="#POPs">#</a>POPs</dt>
<dd>

<p>Pops an SV off the stack.</p>

<pre><code class="plaintext">SV*	POPs</code></pre>

</dd>
<dt id="PUSHi"><a class="permalink" href="#PUSHi">#</a>PUSHi</dt>
<dd>

<p>Push an integer onto the stack. The stack must have room for this element. Handles &#39;set&#39; magic. See <code>XPUSHi</code>.</p>

<pre><code class="plaintext">void	PUSHi(IV iv)</code></pre>

</dd>
<dt id="PUSHMARK"><a class="permalink" href="#PUSHMARK">#</a>PUSHMARK</dt>
<dd>

<p>Opening bracket for arguments on a callback. See <code>PUTBACK</code> and <a href="perlcall.html">perlcall</a>.</p>

<pre><code>PUSHMARK;</code></pre>

</dd>
<dt id="PUSHn"><a class="permalink" href="#PUSHn">#</a>PUSHn</dt>
<dd>

<p>Push a double onto the stack. The stack must have room for this element. Handles &#39;set&#39; magic. See <code>XPUSHn</code>.</p>

<pre><code class="plaintext">void	PUSHn(NV nv)</code></pre>

</dd>
<dt id="PUSHp"><a class="permalink" href="#PUSHp">#</a>PUSHp</dt>
<dd>

<p>Push a string onto the stack. The stack must have room for this element. The <code>len</code> indicates the length of the string. Handles &#39;set&#39; magic. See <code>XPUSHp</code>.</p>

<pre><code class="plaintext">void	PUSHp(char* str, STRLEN len)</code></pre>

</dd>
<dt id="PUSHs"><a class="permalink" href="#PUSHs">#</a>PUSHs</dt>
<dd>

<p>Push an SV onto the stack. The stack must have room for this element. Does not handle &#39;set&#39; magic. See <code>XPUSHs</code>.</p>

<pre><code class="plaintext">void	PUSHs(SV* sv)</code></pre>

</dd>
<dt id="PUSHu"><a class="permalink" href="#PUSHu">#</a>PUSHu</dt>
<dd>

<p>Push an unsigned integer onto the stack. The stack must have room for this element. See <code>XPUSHu</code>.</p>

<pre><code class="plaintext">void	PUSHu(UV uv)</code></pre>

</dd>
<dt id="PUTBACK"><a class="permalink" href="#PUTBACK">#</a>PUTBACK</dt>
<dd>

<p>Closing bracket for XSUB arguments. This is usually handled by <code>xsubpp</code>. See <code>PUSHMARK</code> and <a href="perlcall.html">perlcall</a> for other uses.</p>

<pre><code>PUTBACK;</code></pre>

</dd>
<dt id="Renew"><a class="permalink" href="#Renew">#</a>Renew</dt>
<dd>

<p>The XSUB-writer&#39;s interface to the C <code>realloc</code> function.</p>

<pre><code class="plaintext">void	Renew(void* ptr, int nitems, type)</code></pre>

</dd>
<dt id="Renewc"><a class="permalink" href="#Renewc">#</a>Renewc</dt>
<dd>

<p>The XSUB-writer&#39;s interface to the C <code>realloc</code> function, with cast.</p>

<pre><code class="plaintext">void	Renewc(void* ptr, int nitems, type, cast)</code></pre>

</dd>
<dt id="require_pv"><a class="permalink" href="#require_pv">#</a>require_pv</dt>
<dd>

<p>Tells Perl to <code>require</code> a module.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code class="plaintext">void	require_pv(const char* pv)</code></pre>

</dd>
<dt id="RETVAL"><a class="permalink" href="#RETVAL">#</a>RETVAL</dt>
<dd>

<p>Variable which is setup by <code>xsubpp</code> to hold the return value for an XSUB. This is always the proper type for the XSUB. See <a href="perlxs.html#The-RETVAL-Variable">&quot;The RETVAL Variable&quot; in perlxs</a>.</p>

<pre><code class="plaintext">(whatever)	RETVAL</code></pre>

</dd>
<dt id="Safefree"><a class="permalink" href="#Safefree">#</a>Safefree</dt>
<dd>

<p>The XSUB-writer&#39;s interface to the C <code>free</code> function.</p>

<pre><code class="plaintext">void	Safefree(void* ptr)</code></pre>

</dd>
<dt id="savepv"><a class="permalink" href="#savepv">#</a>savepv</dt>
<dd>

<p>Copy a string to a safe spot. This does not use an SV.</p>

<pre><code class="plaintext">char*	savepv(const char* sv)</code></pre>

</dd>
<dt id="savepvn"><a class="permalink" href="#savepvn">#</a>savepvn</dt>
<dd>

<p>Copy a string to a safe spot. The <code>len</code> indicates number of bytes to copy. This does not use an SV.</p>

<pre><code class="plaintext">char*	savepvn(const char* sv, I32 len)</code></pre>

</dd>
<dt id="SAVETMPS"><a class="permalink" href="#SAVETMPS">#</a>SAVETMPS</dt>
<dd>

<p>Opening bracket for temporaries on a callback. See <code>FREETMPS</code> and <a href="perlcall.html">perlcall</a>.</p>

<pre><code>SAVETMPS;</code></pre>

</dd>
<dt id="SP"><a class="permalink" href="#SP">#</a>SP</dt>
<dd>

<p>Stack pointer. This is usually handled by <code>xsubpp</code>. See <code>dSP</code> and <code>SPAGAIN</code>.</p>

</dd>
<dt id="SPAGAIN"><a class="permalink" href="#SPAGAIN">#</a>SPAGAIN</dt>
<dd>

<p>Refetch the stack pointer. Used after a callback. See <a href="perlcall.html">perlcall</a>.</p>

<pre><code>SPAGAIN;</code></pre>

</dd>
<dt id="ST"><a class="permalink" href="#ST">#</a>ST</dt>
<dd>

<p>Used to access elements on the XSUB&#39;s stack.</p>

<pre><code class="plaintext">SV*	ST(int ix)</code></pre>

</dd>
<dt id="strEQ"><a class="permalink" href="#strEQ">#</a>strEQ</dt>
<dd>

<p>Test two strings to see if they are equal. Returns true or false.</p>

<pre><code class="plaintext">bool	strEQ(char* s1, char* s2)</code></pre>

</dd>
<dt id="strGE"><a class="permalink" href="#strGE">#</a>strGE</dt>
<dd>

<p>Test two strings to see if the first, <code>s1</code>, is greater than or equal to the second, <code>s2</code>. Returns true or false.</p>

<pre><code class="plaintext">bool	strGE(char* s1, char* s2)</code></pre>

</dd>
<dt id="strGT"><a class="permalink" href="#strGT">#</a>strGT</dt>
<dd>

<p>Test two strings to see if the first, <code>s1</code>, is greater than the second, <code>s2</code>. Returns true or false.</p>

<pre><code class="plaintext">bool	strGT(char* s1, char* s2)</code></pre>

</dd>
<dt id="strLE"><a class="permalink" href="#strLE">#</a>strLE</dt>
<dd>

<p>Test two strings to see if the first, <code>s1</code>, is less than or equal to the second, <code>s2</code>. Returns true or false.</p>

<pre><code class="plaintext">bool	strLE(char* s1, char* s2)</code></pre>

</dd>
<dt id="strLT"><a class="permalink" href="#strLT">#</a>strLT</dt>
<dd>

<p>Test two strings to see if the first, <code>s1</code>, is less than the second, <code>s2</code>. Returns true or false.</p>

<pre><code class="plaintext">bool	strLT(char* s1, char* s2)</code></pre>

</dd>
<dt id="strNE"><a class="permalink" href="#strNE">#</a>strNE</dt>
<dd>

<p>Test two strings to see if they are different. Returns true or false.</p>

<pre><code class="plaintext">bool	strNE(char* s1, char* s2)</code></pre>

</dd>
<dt id="strnEQ"><a class="permalink" href="#strnEQ">#</a>strnEQ</dt>
<dd>

<p>Test two strings to see if they are equal. The <code>len</code> parameter indicates the number of bytes to compare. Returns true or false. (A wrapper for <code>strncmp</code>).</p>

<pre><code class="plaintext">bool	strnEQ(char* s1, char* s2, STRLEN len)</code></pre>

</dd>
<dt id="strnNE"><a class="permalink" href="#strnNE">#</a>strnNE</dt>
<dd>

<p>Test two strings to see if they are different. The <code>len</code> parameter indicates the number of bytes to compare. Returns true or false. (A wrapper for <code>strncmp</code>).</p>

<pre><code class="plaintext">bool	strnNE(char* s1, char* s2, STRLEN len)</code></pre>

</dd>
<dt id="StructCopy"><a class="permalink" href="#StructCopy">#</a>StructCopy</dt>
<dd>

<p>This is an architecture-independent macro to copy one structure to another.</p>

<pre><code class="plaintext">void	StructCopy(type src, type dest, type)</code></pre>

</dd>
<dt id="SvCUR"><a class="permalink" href="#SvCUR">#</a>SvCUR</dt>
<dd>

<p>Returns the length of the string which is in the SV. See <code>SvLEN</code>.</p>

<pre><code class="plaintext">STRLEN	SvCUR(SV* sv)</code></pre>

</dd>
<dt id="SvCUR_set"><a class="permalink" href="#SvCUR_set">#</a>SvCUR_set</dt>
<dd>

<p>Set the length of the string which is in the SV. See <code>SvCUR</code>.</p>

<pre><code class="plaintext">void	SvCUR_set(SV* sv, STRLEN len)</code></pre>

</dd>
<dt id="SvEND"><a class="permalink" href="#SvEND">#</a>SvEND</dt>
<dd>

<p>Returns a pointer to the last character in the string which is in the SV. See <code>SvCUR</code>. Access the character as *(SvEND(sv)).</p>

<pre><code class="plaintext">char*	SvEND(SV* sv)</code></pre>

</dd>
<dt id="SvGETMAGIC"><a class="permalink" href="#SvGETMAGIC">#</a>SvGETMAGIC</dt>
<dd>

<p>Invokes <code>mg_get</code> on an SV if it has &#39;get&#39; magic. This macro evaluates its argument more than once.</p>

<pre><code class="plaintext">void	SvGETMAGIC(SV* sv)</code></pre>

</dd>
<dt id="SvGROW"><a class="permalink" href="#SvGROW">#</a>SvGROW</dt>
<dd>

<p>Expands the character buffer in the SV so that it has room for the indicated number of bytes (remember to reserve space for an extra trailing NUL character). Calls <code>sv_grow</code> to perform the expansion if necessary. Returns a pointer to the character buffer.</p>

<pre><code class="plaintext">void	SvGROW(SV* sv, STRLEN len)</code></pre>

</dd>
<dt id="SvIOK"><a class="permalink" href="#SvIOK">#</a>SvIOK</dt>
<dd>

<p>Returns a boolean indicating whether the SV contains an integer.</p>

<pre><code class="plaintext">bool	SvIOK(SV* sv)</code></pre>

</dd>
<dt id="SvIOKp"><a class="permalink" href="#SvIOKp">#</a>SvIOKp</dt>
<dd>

<p>Returns a boolean indicating whether the SV contains an integer. Checks the <b>private</b> setting. Use <code>SvIOK</code>.</p>

<pre><code class="plaintext">bool	SvIOKp(SV* sv)</code></pre>

</dd>
<dt id="SvIOK_notUV"><a class="permalink" href="#SvIOK_notUV">#</a>SvIOK_notUV</dt>
<dd>

<p>Returns a boolean indicating whether the SV contains an signed integer.</p>

<pre><code class="plaintext">void	SvIOK_notUV(SV* sv)</code></pre>

</dd>
<dt id="SvIOK_off"><a class="permalink" href="#SvIOK_off">#</a>SvIOK_off</dt>
<dd>

<p>Unsets the IV status of an SV.</p>

<pre><code class="plaintext">void	SvIOK_off(SV* sv)</code></pre>

</dd>
<dt id="SvIOK_on"><a class="permalink" href="#SvIOK_on">#</a>SvIOK_on</dt>
<dd>

<p>Tells an SV that it is an integer.</p>

<pre><code class="plaintext">void	SvIOK_on(SV* sv)</code></pre>

</dd>
<dt id="SvIOK_only"><a class="permalink" href="#SvIOK_only">#</a>SvIOK_only</dt>
<dd>

<p>Tells an SV that it is an integer and disables all other OK bits.</p>

<pre><code class="plaintext">void	SvIOK_only(SV* sv)</code></pre>

</dd>
<dt id="SvIOK_only_UV"><a class="permalink" href="#SvIOK_only_UV">#</a>SvIOK_only_UV</dt>
<dd>

<p>Tells and SV that it is an unsigned integer and disables all other OK bits.</p>

<pre><code class="plaintext">void	SvIOK_only_UV(SV* sv)</code></pre>

</dd>
<dt id="SvIOK_UV"><a class="permalink" href="#SvIOK_UV">#</a>SvIOK_UV</dt>
<dd>

<p>Returns a boolean indicating whether the SV contains an unsigned integer.</p>

<pre><code class="plaintext">void	SvIOK_UV(SV* sv)</code></pre>

</dd>
<dt id="SvIV"><a class="permalink" href="#SvIV">#</a>SvIV</dt>
<dd>

<p>Coerces the given SV to an integer and returns it.</p>

<pre><code class="plaintext">IV	SvIV(SV* sv)</code></pre>

</dd>
<dt id="SvIVX"><a class="permalink" href="#SvIVX">#</a>SvIVX</dt>
<dd>

<p>Returns the integer which is stored in the SV, assuming SvIOK is true.</p>

<pre><code class="plaintext">IV	SvIVX(SV* sv)</code></pre>

</dd>
<dt id="SvLEN"><a class="permalink" href="#SvLEN">#</a>SvLEN</dt>
<dd>

<p>Returns the size of the string buffer in the SV, not including any part attributable to <code>SvOOK</code>. See <code>SvCUR</code>.</p>

<pre><code class="plaintext">STRLEN	SvLEN(SV* sv)</code></pre>

</dd>
<dt id="SvNIOK"><a class="permalink" href="#SvNIOK">#</a>SvNIOK</dt>
<dd>

<p>Returns a boolean indicating whether the SV contains a number, integer or double.</p>

<pre><code class="plaintext">bool	SvNIOK(SV* sv)</code></pre>

</dd>
<dt id="SvNIOKp"><a class="permalink" href="#SvNIOKp">#</a>SvNIOKp</dt>
<dd>

<p>Returns a boolean indicating whether the SV contains a number, integer or double. Checks the <b>private</b> setting. Use <code>SvNIOK</code>.</p>

<pre><code class="plaintext">bool	SvNIOKp(SV* sv)</code></pre>

</dd>
<dt id="SvNIOK_off"><a class="permalink" href="#SvNIOK_off">#</a>SvNIOK_off</dt>
<dd>

<p>Unsets the NV/IV status of an SV.</p>

<pre><code class="plaintext">void	SvNIOK_off(SV* sv)</code></pre>

</dd>
<dt id="SvNOK"><a class="permalink" href="#SvNOK">#</a>SvNOK</dt>
<dd>

<p>Returns a boolean indicating whether the SV contains a double.</p>

<pre><code class="plaintext">bool	SvNOK(SV* sv)</code></pre>

</dd>
<dt id="SvNOKp"><a class="permalink" href="#SvNOKp">#</a>SvNOKp</dt>
<dd>

<p>Returns a boolean indicating whether the SV contains a double. Checks the <b>private</b> setting. Use <code>SvNOK</code>.</p>

<pre><code class="plaintext">bool	SvNOKp(SV* sv)</code></pre>

</dd>
<dt id="SvNOK_off"><a class="permalink" href="#SvNOK_off">#</a>SvNOK_off</dt>
<dd>

<p>Unsets the NV status of an SV.</p>

<pre><code class="plaintext">void	SvNOK_off(SV* sv)</code></pre>

</dd>
<dt id="SvNOK_on"><a class="permalink" href="#SvNOK_on">#</a>SvNOK_on</dt>
<dd>

<p>Tells an SV that it is a double.</p>

<pre><code class="plaintext">void	SvNOK_on(SV* sv)</code></pre>

</dd>
<dt id="SvNOK_only"><a class="permalink" href="#SvNOK_only">#</a>SvNOK_only</dt>
<dd>

<p>Tells an SV that it is a double and disables all other OK bits.</p>

<pre><code class="plaintext">void	SvNOK_only(SV* sv)</code></pre>

</dd>
<dt id="SvNV"><a class="permalink" href="#SvNV">#</a>SvNV</dt>
<dd>

<p>Coerce the given SV to a double and return it.</p>

<pre><code class="plaintext">NV	SvNV(SV* sv)</code></pre>

</dd>
<dt id="SvNVX"><a class="permalink" href="#SvNVX">#</a>SvNVX</dt>
<dd>

<p>Returns the double which is stored in the SV, assuming SvNOK is true.</p>

<pre><code class="plaintext">NV	SvNVX(SV* sv)</code></pre>

</dd>
<dt id="SvOK"><a class="permalink" href="#SvOK">#</a>SvOK</dt>
<dd>

<p>Returns a boolean indicating whether the value is an SV.</p>

<pre><code class="plaintext">bool	SvOK(SV* sv)</code></pre>

</dd>
<dt id="SvOOK"><a class="permalink" href="#SvOOK">#</a>SvOOK</dt>
<dd>

<p>Returns a boolean indicating whether the SvIVX is a valid offset value for the SvPVX. This hack is used internally to speed up removal of characters from the beginning of a SvPV. When SvOOK is true, then the start of the allocated string buffer is really (SvPVX - SvIVX).</p>

<pre><code class="plaintext">bool	SvOOK(SV* sv)</code></pre>

</dd>
<dt id="SvPOK"><a class="permalink" href="#SvPOK">#</a>SvPOK</dt>
<dd>

<p>Returns a boolean indicating whether the SV contains a character string.</p>

<pre><code class="plaintext">bool	SvPOK(SV* sv)</code></pre>

</dd>
<dt id="SvPOKp"><a class="permalink" href="#SvPOKp">#</a>SvPOKp</dt>
<dd>

<p>Returns a boolean indicating whether the SV contains a character string. Checks the <b>private</b> setting. Use <code>SvPOK</code>.</p>

<pre><code class="plaintext">bool	SvPOKp(SV* sv)</code></pre>

</dd>
<dt id="SvPOK_off"><a class="permalink" href="#SvPOK_off">#</a>SvPOK_off</dt>
<dd>

<p>Unsets the PV status of an SV.</p>

<pre><code class="plaintext">void	SvPOK_off(SV* sv)</code></pre>

</dd>
<dt id="SvPOK_on"><a class="permalink" href="#SvPOK_on">#</a>SvPOK_on</dt>
<dd>

<p>Tells an SV that it is a string.</p>

<pre><code class="plaintext">void	SvPOK_on(SV* sv)</code></pre>

</dd>
<dt id="SvPOK_only"><a class="permalink" href="#SvPOK_only">#</a>SvPOK_only</dt>
<dd>

<p>Tells an SV that it is a string and disables all other OK bits.</p>

<pre><code class="plaintext">void	SvPOK_only(SV* sv)</code></pre>

</dd>
<dt id="SvPOK_only_UTF8"><a class="permalink" href="#SvPOK_only_UTF8">#</a>SvPOK_only_UTF8</dt>
<dd>

<p>Tells an SV that it is a UTF8 string (do not use frivolously) and disables all other OK bits.</p>

<pre><code class="plaintext">void	SvPOK_only_UTF8(SV* sv)</code></pre>

</dd>
<dt id="SvPV"><a class="permalink" href="#SvPV">#</a>SvPV</dt>
<dd>

<p>Returns a pointer to the string in the SV, or a stringified form of the SV if the SV does not contain a string. Handles &#39;get&#39; magic.</p>

<pre><code class="plaintext">char*	SvPV(SV* sv, STRLEN len)</code></pre>

</dd>
<dt id="SvPVX"><a class="permalink" href="#SvPVX">#</a>SvPVX</dt>
<dd>

<p>Returns a pointer to the string in the SV. The SV must contain a string.</p>

<pre><code class="plaintext">char*	SvPVX(SV* sv)</code></pre>

</dd>
<dt id="SvPV_force"><a class="permalink" href="#SvPV_force">#</a>SvPV_force</dt>
<dd>

<p>Like &lt;SvPV&gt; but will force the SV into becoming a string (SvPOK). You want force if you are going to update the SvPVX directly.</p>

<pre><code class="plaintext">char*	SvPV_force(SV* sv, STRLEN len)</code></pre>

</dd>
<dt id="SvPV_nolen"><a class="permalink" href="#SvPV_nolen">#</a>SvPV_nolen</dt>
<dd>

<p>Returns a pointer to the string in the SV, or a stringified form of the SV if the SV does not contain a string. Handles &#39;get&#39; magic.</p>

<pre><code class="plaintext">char*	SvPV_nolen(SV* sv)</code></pre>

</dd>
<dt id="SvREFCNT"><a class="permalink" href="#SvREFCNT">#</a>SvREFCNT</dt>
<dd>

<p>Returns the value of the object&#39;s reference count.</p>

<pre><code class="plaintext">U32	SvREFCNT(SV* sv)</code></pre>

</dd>
<dt id="SvREFCNT_dec"><a class="permalink" href="#SvREFCNT_dec">#</a>SvREFCNT_dec</dt>
<dd>

<p>Decrements the reference count of the given SV.</p>

<pre><code class="plaintext">void	SvREFCNT_dec(SV* sv)</code></pre>

</dd>
<dt id="SvREFCNT_inc"><a class="permalink" href="#SvREFCNT_inc">#</a>SvREFCNT_inc</dt>
<dd>

<p>Increments the reference count of the given SV.</p>

<pre><code class="plaintext">SV*	SvREFCNT_inc(SV* sv)</code></pre>

</dd>
<dt id="SvROK"><a class="permalink" href="#SvROK">#</a>SvROK</dt>
<dd>

<p>Tests if the SV is an RV.</p>

<pre><code class="plaintext">bool	SvROK(SV* sv)</code></pre>

</dd>
<dt id="SvROK_off"><a class="permalink" href="#SvROK_off">#</a>SvROK_off</dt>
<dd>

<p>Unsets the RV status of an SV.</p>

<pre><code class="plaintext">void	SvROK_off(SV* sv)</code></pre>

</dd>
<dt id="SvROK_on"><a class="permalink" href="#SvROK_on">#</a>SvROK_on</dt>
<dd>

<p>Tells an SV that it is an RV.</p>

<pre><code class="plaintext">void	SvROK_on(SV* sv)</code></pre>

</dd>
<dt id="SvRV"><a class="permalink" href="#SvRV">#</a>SvRV</dt>
<dd>

<p>Dereferences an RV to return the SV.</p>

<pre><code class="plaintext">SV*	SvRV(SV* sv)</code></pre>

</dd>
<dt id="SvSETMAGIC"><a class="permalink" href="#SvSETMAGIC">#</a>SvSETMAGIC</dt>
<dd>

<p>Invokes <code>mg_set</code> on an SV if it has &#39;set&#39; magic. This macro evaluates its argument more than once.</p>

<pre><code class="plaintext">void	SvSETMAGIC(SV* sv)</code></pre>

</dd>
<dt id="SvSetSV"><a class="permalink" href="#SvSetSV">#</a>SvSetSV</dt>
<dd>

<p>Calls <code>sv_setsv</code> if dsv is not the same as ssv. May evaluate arguments more than once.</p>

<pre><code class="plaintext">void	SvSetSV(SV* dsb, SV* ssv)</code></pre>

</dd>
<dt id="SvSetSV_nosteal"><a class="permalink" href="#SvSetSV_nosteal">#</a>SvSetSV_nosteal</dt>
<dd>

<p>Calls a non-destructive version of <code>sv_setsv</code> if dsv is not the same as ssv. May evaluate arguments more than once.</p>

<pre><code class="plaintext">void	SvSetSV_nosteal(SV* dsv, SV* ssv)</code></pre>

</dd>
<dt id="SvSTASH"><a class="permalink" href="#SvSTASH">#</a>SvSTASH</dt>
<dd>

<p>Returns the stash of the SV.</p>

<pre><code class="plaintext">HV*	SvSTASH(SV* sv)</code></pre>

</dd>
<dt id="SvTAINT"><a class="permalink" href="#SvTAINT">#</a>SvTAINT</dt>
<dd>

<p>Taints an SV if tainting is enabled</p>

<pre><code class="plaintext">void	SvTAINT(SV* sv)</code></pre>

</dd>
<dt id="SvTAINTED"><a class="permalink" href="#SvTAINTED">#</a>SvTAINTED</dt>
<dd>

<p>Checks to see if an SV is tainted. Returns TRUE if it is, FALSE if not.</p>

<pre><code class="plaintext">bool	SvTAINTED(SV* sv)</code></pre>

</dd>
<dt id="SvTAINTED_off"><a class="permalink" href="#SvTAINTED_off">#</a>SvTAINTED_off</dt>
<dd>

<p>Untaints an SV. Be <i>very</i> careful with this routine, as it short-circuits some of Perl&#39;s fundamental security features. XS module authors should not use this function unless they fully understand all the implications of unconditionally untainting the value. Untainting should be done in the standard perl fashion, via a carefully crafted regexp, rather than directly untainting variables.</p>

<pre><code class="plaintext">void	SvTAINTED_off(SV* sv)</code></pre>

</dd>
<dt id="SvTAINTED_on"><a class="permalink" href="#SvTAINTED_on">#</a>SvTAINTED_on</dt>
<dd>

<p>Marks an SV as tainted.</p>

<pre><code class="plaintext">void	SvTAINTED_on(SV* sv)</code></pre>

</dd>
<dt id="SvTRUE"><a class="permalink" href="#SvTRUE">#</a>SvTRUE</dt>
<dd>

<p>Returns a boolean indicating whether Perl would evaluate the SV as true or false, defined or undefined. Does not handle &#39;get&#39; magic.</p>

<pre><code class="plaintext">bool	SvTRUE(SV* sv)</code></pre>

</dd>
<dt id="svtype"><a class="permalink" href="#svtype">#</a>svtype</dt>
<dd>

<p>An enum of flags for Perl types. These are found in the file <b>sv.h</b> in the <code>svtype</code> enum. Test these flags with the <code>SvTYPE</code> macro.</p>

</dd>
<dt id="SvTYPE"><a class="permalink" href="#SvTYPE">#</a>SvTYPE</dt>
<dd>

<p>Returns the type of the SV. See <code>svtype</code>.</p>

<pre><code class="plaintext">svtype	SvTYPE(SV* sv)</code></pre>

</dd>
<dt id="SVt_IV"><a class="permalink" href="#SVt_IV">#</a>SVt_IV</dt>
<dd>

<p>Integer type flag for scalars. See <code>svtype</code>.</p>

</dd>
<dt id="SVt_NV"><a class="permalink" href="#SVt_NV">#</a>SVt_NV</dt>
<dd>

<p>Double type flag for scalars. See <code>svtype</code>.</p>

</dd>
<dt id="SVt_PV"><a class="permalink" href="#SVt_PV">#</a>SVt_PV</dt>
<dd>

<p>Pointer type flag for scalars. See <code>svtype</code>.</p>

</dd>
<dt id="SVt_PVAV"><a class="permalink" href="#SVt_PVAV">#</a>SVt_PVAV</dt>
<dd>

<p>Type flag for arrays. See <code>svtype</code>.</p>

</dd>
<dt id="SVt_PVCV"><a class="permalink" href="#SVt_PVCV">#</a>SVt_PVCV</dt>
<dd>

<p>Type flag for code refs. See <code>svtype</code>.</p>

</dd>
<dt id="SVt_PVHV"><a class="permalink" href="#SVt_PVHV">#</a>SVt_PVHV</dt>
<dd>

<p>Type flag for hashes. See <code>svtype</code>.</p>

</dd>
<dt id="SVt_PVMG"><a class="permalink" href="#SVt_PVMG">#</a>SVt_PVMG</dt>
<dd>

<p>Type flag for blessed scalars. See <code>svtype</code>.</p>

</dd>
<dt id="SvUPGRADE"><a class="permalink" href="#SvUPGRADE">#</a>SvUPGRADE</dt>
<dd>

<p>Used to upgrade an SV to a more complex form. Uses <code>sv_upgrade</code> to perform the upgrade if necessary. See <code>svtype</code>.</p>

<pre><code class="plaintext">void	SvUPGRADE(SV* sv, svtype type)</code></pre>

</dd>
<dt id="SvUTF8"><a class="permalink" href="#SvUTF8">#</a>SvUTF8</dt>
<dd>

<p>Returns a boolean indicating whether the SV contains UTF-8 encoded data.</p>

<pre><code class="plaintext">void	SvUTF8(SV* sv)</code></pre>

</dd>
<dt id="SvUTF8_off"><a class="permalink" href="#SvUTF8_off">#</a>SvUTF8_off</dt>
<dd>

<p>Unsets the UTF8 status of an SV.</p>

<pre><code class="plaintext">void	SvUTF8_off(SV *sv)</code></pre>

</dd>
<dt id="SvUTF8_on"><a class="permalink" href="#SvUTF8_on">#</a>SvUTF8_on</dt>
<dd>

<p>Tells an SV that it is a string and encoded in UTF8. Do not use frivolously.</p>

<pre><code class="plaintext">void	SvUTF8_on(SV *sv)</code></pre>

</dd>
<dt id="SvUV"><a class="permalink" href="#SvUV">#</a>SvUV</dt>
<dd>

<p>Coerces the given SV to an unsigned integer and returns it.</p>

<pre><code class="plaintext">UV	SvUV(SV* sv)</code></pre>

</dd>
<dt id="SvUVX"><a class="permalink" href="#SvUVX">#</a>SvUVX</dt>
<dd>

<p>Returns the unsigned integer which is stored in the SV, assuming SvIOK is true.</p>

<pre><code class="plaintext">UV	SvUVX(SV* sv)</code></pre>

</dd>
<dt id="sv_2mortal"><a class="permalink" href="#sv_2mortal">#</a>sv_2mortal</dt>
<dd>

<p>Marks an SV as mortal. The SV will be destroyed when the current context ends.</p>

<pre><code class="plaintext">SV*	sv_2mortal(SV* sv)</code></pre>

</dd>
<dt id="sv_bless"><a class="permalink" href="#sv_bless">#</a>sv_bless</dt>
<dd>

<p>Blesses an SV into a specified package. The SV must be an RV. The package must be designated by its stash (see <code>gv_stashpv()</code>). The reference count of the SV is unaffected.</p>

<pre><code class="plaintext">SV*	sv_bless(SV* sv, HV* stash)</code></pre>

</dd>
<dt id="sv_catpv"><a class="permalink" href="#sv_catpv">#</a>sv_catpv</dt>
<dd>

<p>Concatenates the string onto the end of the string which is in the SV. Handles &#39;get&#39; magic, but not &#39;set&#39; magic. See <code>sv_catpv_mg</code>.</p>

<pre><code class="plaintext">void	sv_catpv(SV* sv, const char* ptr)</code></pre>

</dd>
<dt id="sv_catpvf"><a class="permalink" href="#sv_catpvf">#</a>sv_catpvf</dt>
<dd>

<p>Processes its arguments like <code>sprintf</code> and appends the formatted output to an SV. Handles &#39;get&#39; magic, but not &#39;set&#39; magic. <code>SvSETMAGIC()</code> must typically be called after calling this function to handle &#39;set&#39; magic.</p>

<pre><code class="plaintext">void	sv_catpvf(SV* sv, const char* pat, ...)</code></pre>

</dd>
<dt id="sv_catpvf_mg"><a class="permalink" href="#sv_catpvf_mg">#</a>sv_catpvf_mg</dt>
<dd>

<p>Like <code>sv_catpvf</code>, but also handles &#39;set&#39; magic.</p>

<pre><code class="plaintext">void	sv_catpvf_mg(SV *sv, const char* pat, ...)</code></pre>

</dd>
<dt id="sv_catpvn"><a class="permalink" href="#sv_catpvn">#</a>sv_catpvn</dt>
<dd>

<p>Concatenates the string onto the end of the string which is in the SV. The <code>len</code> indicates number of bytes to copy. Handles &#39;get&#39; magic, but not &#39;set&#39; magic. See <code>sv_catpvn_mg</code>.</p>

<pre><code class="plaintext">void	sv_catpvn(SV* sv, const char* ptr, STRLEN len)</code></pre>

</dd>
<dt id="sv_catpvn_mg"><a class="permalink" href="#sv_catpvn_mg">#</a>sv_catpvn_mg</dt>
<dd>

<p>Like <code>sv_catpvn</code>, but also handles &#39;set&#39; magic.</p>

<pre><code class="plaintext">void	sv_catpvn_mg(SV *sv, const char *ptr, STRLEN len)</code></pre>

</dd>
<dt id="sv_catpv_mg"><a class="permalink" href="#sv_catpv_mg">#</a>sv_catpv_mg</dt>
<dd>

<p>Like <code>sv_catpv</code>, but also handles &#39;set&#39; magic.</p>

<pre><code class="plaintext">void	sv_catpv_mg(SV *sv, const char *ptr)</code></pre>

</dd>
<dt id="sv_catsv"><a class="permalink" href="#sv_catsv">#</a>sv_catsv</dt>
<dd>

<p>Concatenates the string from SV <code>ssv</code> onto the end of the string in SV <code>dsv</code>. Modifies <code>dsv</code> but not <code>ssv</code>. Handles &#39;get&#39; magic, but not &#39;set&#39; magic. See <code>sv_catsv_mg</code>.</p>

<pre><code class="plaintext">void	sv_catsv(SV* dsv, SV* ssv)</code></pre>

</dd>
<dt id="sv_catsv_mg"><a class="permalink" href="#sv_catsv_mg">#</a>sv_catsv_mg</dt>
<dd>

<p>Like <code>sv_catsv</code>, but also handles &#39;set&#39; magic.</p>

<pre><code class="plaintext">void	sv_catsv_mg(SV *dstr, SV *sstr)</code></pre>

</dd>
<dt id="sv_chop"><a class="permalink" href="#sv_chop">#</a>sv_chop</dt>
<dd>

<p>Efficient removal of characters from the beginning of the string buffer. SvPOK(sv) must be true and the <code>ptr</code> must be a pointer to somewhere inside the string buffer. The <code>ptr</code> becomes the first character of the adjusted string.</p>

<pre><code class="plaintext">void	sv_chop(SV* sv, char* ptr)</code></pre>

</dd>
<dt id="sv_clear"><a class="permalink" href="#sv_clear">#</a>sv_clear</dt>
<dd>

<p>Clear an SV, making it empty. Does not free the memory used by the SV itself.</p>

<pre><code class="plaintext">void	sv_clear(SV* sv)</code></pre>

</dd>
<dt id="sv_cmp"><a class="permalink" href="#sv_cmp">#</a>sv_cmp</dt>
<dd>

<p>Compares the strings in two SVs. Returns -1, 0, or 1 indicating whether the string in <code>sv1</code> is less than, equal to, or greater than the string in <code>sv2</code>.</p>

<pre><code class="plaintext">I32	sv_cmp(SV* sv1, SV* sv2)</code></pre>

</dd>
<dt id="sv_cmp_locale"><a class="permalink" href="#sv_cmp_locale">#</a>sv_cmp_locale</dt>
<dd>

<p>Compares the strings in two SVs in a locale-aware manner. See <a href="#sv_cmp_locale">&quot;sv_cmp_locale&quot;</a></p>

<pre><code class="plaintext">I32	sv_cmp_locale(SV* sv1, SV* sv2)</code></pre>

</dd>
<dt id="sv_dec"><a class="permalink" href="#sv_dec">#</a>sv_dec</dt>
<dd>

<p>Auto-decrement of the value in the SV.</p>

<pre><code class="plaintext">void	sv_dec(SV* sv)</code></pre>

</dd>
<dt id="sv_derived_from"><a class="permalink" href="#sv_derived_from">#</a>sv_derived_from</dt>
<dd>

<p>Returns a boolean indicating whether the SV is derived from the specified class. This is the function that implements <code>UNIVERSAL::isa</code>. It works for class names as well as for objects.</p>

<pre><code class="plaintext">bool	sv_derived_from(SV* sv, const char* name)</code></pre>

</dd>
<dt id="sv_eq"><a class="permalink" href="#sv_eq">#</a>sv_eq</dt>
<dd>

<p>Returns a boolean indicating whether the strings in the two SVs are identical.</p>

<pre><code class="plaintext">I32	sv_eq(SV* sv1, SV* sv2)</code></pre>

</dd>
<dt id="sv_free"><a class="permalink" href="#sv_free">#</a>sv_free</dt>
<dd>

<p>Free the memory used by an SV.</p>

<pre><code class="plaintext">void	sv_free(SV* sv)</code></pre>

</dd>
<dt id="sv_gets"><a class="permalink" href="#sv_gets">#</a>sv_gets</dt>
<dd>

<p>Get a line from the filehandle and store it into the SV, optionally appending to the currently-stored string.</p>

<pre><code class="plaintext">char*	sv_gets(SV* sv, PerlIO* fp, I32 append)</code></pre>

</dd>
<dt id="sv_grow"><a class="permalink" href="#sv_grow">#</a>sv_grow</dt>
<dd>

<p>Expands the character buffer in the SV. This will use <code>sv_unref</code> and will upgrade the SV to <code>SVt_PV</code>. Returns a pointer to the character buffer. Use <code>SvGROW</code>.</p>

<pre><code class="plaintext">char*	sv_grow(SV* sv, STRLEN newlen)</code></pre>

</dd>
<dt id="sv_inc"><a class="permalink" href="#sv_inc">#</a>sv_inc</dt>
<dd>

<p>Auto-increment of the value in the SV.</p>

<pre><code class="plaintext">void	sv_inc(SV* sv)</code></pre>

</dd>
<dt id="sv_insert"><a class="permalink" href="#sv_insert">#</a>sv_insert</dt>
<dd>

<p>Inserts a string at the specified offset/length within the SV. Similar to the Perl substr() function.</p>

<pre><code class="plaintext">void	sv_insert(SV* bigsv, STRLEN offset, STRLEN len, char* little, STRLEN littlelen)</code></pre>

</dd>
<dt id="sv_isa"><a class="permalink" href="#sv_isa">#</a>sv_isa</dt>
<dd>

<p>Returns a boolean indicating whether the SV is blessed into the specified class. This does not check for subtypes; use <code>sv_derived_from</code> to verify an inheritance relationship.</p>

<pre><code class="plaintext">int	sv_isa(SV* sv, const char* name)</code></pre>

</dd>
<dt id="sv_isobject"><a class="permalink" href="#sv_isobject">#</a>sv_isobject</dt>
<dd>

<p>Returns a boolean indicating whether the SV is an RV pointing to a blessed object. If the SV is not an RV, or if the object is not blessed, then this will return false.</p>

<pre><code class="plaintext">int	sv_isobject(SV* sv)</code></pre>

</dd>
<dt id="sv_len"><a class="permalink" href="#sv_len">#</a>sv_len</dt>
<dd>

<p>Returns the length of the string in the SV. See also <code>SvCUR</code>.</p>

<pre><code class="plaintext">STRLEN	sv_len(SV* sv)</code></pre>

</dd>
<dt id="sv_len_utf8"><a class="permalink" href="#sv_len_utf8">#</a>sv_len_utf8</dt>
<dd>

<p>Returns the number of characters in the string in an SV, counting wide UTF8 bytes as a single character.</p>

<pre><code class="plaintext">STRLEN	sv_len_utf8(SV* sv)</code></pre>

</dd>
<dt id="sv_magic"><a class="permalink" href="#sv_magic">#</a>sv_magic</dt>
<dd>

<p>Adds magic to an SV.</p>

<pre><code class="plaintext">void	sv_magic(SV* sv, SV* obj, int how, const char* name, I32 namlen)</code></pre>

</dd>
<dt id="sv_mortalcopy"><a class="permalink" href="#sv_mortalcopy">#</a>sv_mortalcopy</dt>
<dd>

<p>Creates a new SV which is a copy of the original SV. The new SV is marked as mortal.</p>

<pre><code class="plaintext">SV*	sv_mortalcopy(SV* oldsv)</code></pre>

</dd>
<dt id="sv_newmortal"><a class="permalink" href="#sv_newmortal">#</a>sv_newmortal</dt>
<dd>

<p>Creates a new SV which is mortal. The reference count of the SV is set to 1.</p>

<pre><code class="plaintext">SV*	sv_newmortal()</code></pre>

</dd>
<dt id="sv_pvn_force"><a class="permalink" href="#sv_pvn_force">#</a>sv_pvn_force</dt>
<dd>

<p>Get a sensible string out of the SV somehow.</p>

<pre><code class="plaintext">char*	sv_pvn_force(SV* sv, STRLEN* lp)</code></pre>

</dd>
<dt id="sv_pvutf8n_force"><a class="permalink" href="#sv_pvutf8n_force">#</a>sv_pvutf8n_force</dt>
<dd>

<p>Get a sensible UTF8-encoded string out of the SV somehow. See <a href="#sv_pvn_force">&quot;sv_pvn_force&quot;</a>.</p>

<pre><code class="plaintext">char*	sv_pvutf8n_force(SV* sv, STRLEN* lp)</code></pre>

</dd>
<dt id="sv_reftype"><a class="permalink" href="#sv_reftype">#</a>sv_reftype</dt>
<dd>

<p>Returns a string describing what the SV is a reference to.</p>

<pre><code class="plaintext">char*	sv_reftype(SV* sv, int ob)</code></pre>

</dd>
<dt id="sv_replace"><a class="permalink" href="#sv_replace">#</a>sv_replace</dt>
<dd>

<p>Make the first argument a copy of the second, then delete the original.</p>

<pre><code class="plaintext">void	sv_replace(SV* sv, SV* nsv)</code></pre>

</dd>
<dt id="sv_rvweaken"><a class="permalink" href="#sv_rvweaken">#</a>sv_rvweaken</dt>
<dd>

<p>Weaken a reference.</p>

<pre><code class="plaintext">SV*	sv_rvweaken(SV *sv)</code></pre>

</dd>
<dt id="sv_setiv"><a class="permalink" href="#sv_setiv">#</a>sv_setiv</dt>
<dd>

<p>Copies an integer into the given SV. Does not handle &#39;set&#39; magic. See <code>sv_setiv_mg</code>.</p>

<pre><code class="plaintext">void	sv_setiv(SV* sv, IV num)</code></pre>

</dd>
<dt id="sv_setiv_mg"><a class="permalink" href="#sv_setiv_mg">#</a>sv_setiv_mg</dt>
<dd>

<p>Like <code>sv_setiv</code>, but also handles &#39;set&#39; magic.</p>

<pre><code class="plaintext">void	sv_setiv_mg(SV *sv, IV i)</code></pre>

</dd>
<dt id="sv_setnv"><a class="permalink" href="#sv_setnv">#</a>sv_setnv</dt>
<dd>

<p>Copies a double into the given SV. Does not handle &#39;set&#39; magic. See <code>sv_setnv_mg</code>.</p>

<pre><code class="plaintext">void	sv_setnv(SV* sv, NV num)</code></pre>

</dd>
<dt id="sv_setnv_mg"><a class="permalink" href="#sv_setnv_mg">#</a>sv_setnv_mg</dt>
<dd>

<p>Like <code>sv_setnv</code>, but also handles &#39;set&#39; magic.</p>

<pre><code class="plaintext">void	sv_setnv_mg(SV *sv, NV num)</code></pre>

</dd>
<dt id="sv_setpv"><a class="permalink" href="#sv_setpv">#</a>sv_setpv</dt>
<dd>

<p>Copies a string into an SV. The string must be null-terminated. Does not handle &#39;set&#39; magic. See <code>sv_setpv_mg</code>.</p>

<pre><code class="plaintext">void	sv_setpv(SV* sv, const char* ptr)</code></pre>

</dd>
<dt id="sv_setpvf"><a class="permalink" href="#sv_setpvf">#</a>sv_setpvf</dt>
<dd>

<p>Processes its arguments like <code>sprintf</code> and sets an SV to the formatted output. Does not handle &#39;set&#39; magic. See <code>sv_setpvf_mg</code>.</p>

<pre><code class="plaintext">void	sv_setpvf(SV* sv, const char* pat, ...)</code></pre>

</dd>
<dt id="sv_setpvf_mg"><a class="permalink" href="#sv_setpvf_mg">#</a>sv_setpvf_mg</dt>
<dd>

<p>Like <code>sv_setpvf</code>, but also handles &#39;set&#39; magic.</p>

<pre><code class="plaintext">void	sv_setpvf_mg(SV *sv, const char* pat, ...)</code></pre>

</dd>
<dt id="sv_setpviv"><a class="permalink" href="#sv_setpviv">#</a>sv_setpviv</dt>
<dd>

<p>Copies an integer into the given SV, also updating its string value. Does not handle &#39;set&#39; magic. See <code>sv_setpviv_mg</code>.</p>

<pre><code class="plaintext">void	sv_setpviv(SV* sv, IV num)</code></pre>

</dd>
<dt id="sv_setpviv_mg"><a class="permalink" href="#sv_setpviv_mg">#</a>sv_setpviv_mg</dt>
<dd>

<p>Like <code>sv_setpviv</code>, but also handles &#39;set&#39; magic.</p>

<pre><code class="plaintext">void	sv_setpviv_mg(SV *sv, IV iv)</code></pre>

</dd>
<dt id="sv_setpvn"><a class="permalink" href="#sv_setpvn">#</a>sv_setpvn</dt>
<dd>

<p>Copies a string into an SV. The <code>len</code> parameter indicates the number of bytes to be copied. Does not handle &#39;set&#39; magic. See <code>sv_setpvn_mg</code>.</p>

<pre><code class="plaintext">void	sv_setpvn(SV* sv, const char* ptr, STRLEN len)</code></pre>

</dd>
<dt id="sv_setpvn_mg"><a class="permalink" href="#sv_setpvn_mg">#</a>sv_setpvn_mg</dt>
<dd>

<p>Like <code>sv_setpvn</code>, but also handles &#39;set&#39; magic.</p>

<pre><code class="plaintext">void	sv_setpvn_mg(SV *sv, const char *ptr, STRLEN len)</code></pre>

</dd>
<dt id="sv_setpv_mg"><a class="permalink" href="#sv_setpv_mg">#</a>sv_setpv_mg</dt>
<dd>

<p>Like <code>sv_setpv</code>, but also handles &#39;set&#39; magic.</p>

<pre><code class="plaintext">void	sv_setpv_mg(SV *sv, const char *ptr)</code></pre>

</dd>
<dt id="sv_setref_iv"><a class="permalink" href="#sv_setref_iv">#</a>sv_setref_iv</dt>
<dd>

<p>Copies an integer into a new SV, optionally blessing the SV. The <code>rv</code> argument will be upgraded to an RV. That RV will be modified to point to the new SV. The <code>classname</code> argument indicates the package for the blessing. Set <code>classname</code> to <code>Nullch</code> to avoid the blessing. The new SV will be returned and will have a reference count of 1.</p>

<pre><code class="plaintext">SV*	sv_setref_iv(SV* rv, const char* classname, IV iv)</code></pre>

</dd>
<dt id="sv_setref_nv"><a class="permalink" href="#sv_setref_nv">#</a>sv_setref_nv</dt>
<dd>

<p>Copies a double into a new SV, optionally blessing the SV. The <code>rv</code> argument will be upgraded to an RV. That RV will be modified to point to the new SV. The <code>classname</code> argument indicates the package for the blessing. Set <code>classname</code> to <code>Nullch</code> to avoid the blessing. The new SV will be returned and will have a reference count of 1.</p>

<pre><code class="plaintext">SV*	sv_setref_nv(SV* rv, const char* classname, NV nv)</code></pre>

</dd>
<dt id="sv_setref_pv"><a class="permalink" href="#sv_setref_pv">#</a>sv_setref_pv</dt>
<dd>

<p>Copies a pointer into a new SV, optionally blessing the SV. The <code>rv</code> argument will be upgraded to an RV. That RV will be modified to point to the new SV. If the <code>pv</code> argument is NULL then <code>PL_sv_undef</code> will be placed into the SV. The <code>classname</code> argument indicates the package for the blessing. Set <code>classname</code> to <code>Nullch</code> to avoid the blessing. The new SV will be returned and will have a reference count of 1.</p>

<p>Do not use with other Perl types such as HV, AV, SV, CV, because those objects will become corrupted by the pointer copy process.</p>

<p>Note that <code>sv_setref_pvn</code> copies the string while this copies the pointer.</p>

<pre><code class="plaintext">SV*	sv_setref_pv(SV* rv, const char* classname, void* pv)</code></pre>

</dd>
<dt id="sv_setref_pvn"><a class="permalink" href="#sv_setref_pvn">#</a>sv_setref_pvn</dt>
<dd>

<p>Copies a string into a new SV, optionally blessing the SV. The length of the string must be specified with <code>n</code>. The <code>rv</code> argument will be upgraded to an RV. That RV will be modified to point to the new SV. The <code>classname</code> argument indicates the package for the blessing. Set <code>classname</code> to <code>Nullch</code> to avoid the blessing. The new SV will be returned and will have a reference count of 1.</p>

<p>Note that <code>sv_setref_pv</code> copies the pointer while this copies the string.</p>

<pre><code class="plaintext">SV*	sv_setref_pvn(SV* rv, const char* classname, char* pv, STRLEN n)</code></pre>

</dd>
<dt id="sv_setsv"><a class="permalink" href="#sv_setsv">#</a>sv_setsv</dt>
<dd>

<p>Copies the contents of the source SV <code>ssv</code> into the destination SV <code>dsv</code>. The source SV may be destroyed if it is mortal. Does not handle &#39;set&#39; magic. See the macro forms <code>SvSetSV</code>, <code>SvSetSV_nosteal</code> and <code>sv_setsv_mg</code>.</p>

<pre><code class="plaintext">void	sv_setsv(SV* dsv, SV* ssv)</code></pre>

</dd>
<dt id="sv_setsv_mg"><a class="permalink" href="#sv_setsv_mg">#</a>sv_setsv_mg</dt>
<dd>

<p>Like <code>sv_setsv</code>, but also handles &#39;set&#39; magic.</p>

<pre><code class="plaintext">void	sv_setsv_mg(SV *dstr, SV *sstr)</code></pre>

</dd>
<dt id="sv_setuv"><a class="permalink" href="#sv_setuv">#</a>sv_setuv</dt>
<dd>

<p>Copies an unsigned integer into the given SV. Does not handle &#39;set&#39; magic. See <code>sv_setuv_mg</code>.</p>

<pre><code class="plaintext">void	sv_setuv(SV* sv, UV num)</code></pre>

</dd>
<dt id="sv_setuv_mg"><a class="permalink" href="#sv_setuv_mg">#</a>sv_setuv_mg</dt>
<dd>

<p>Like <code>sv_setuv</code>, but also handles &#39;set&#39; magic.</p>

<pre><code class="plaintext">void	sv_setuv_mg(SV *sv, UV u)</code></pre>

</dd>
<dt id="sv_true"><a class="permalink" href="#sv_true">#</a>sv_true</dt>
<dd>

<p>Returns true if the SV has a true value by Perl&#39;s rules.</p>

<pre><code class="plaintext">I32	sv_true(SV *sv)</code></pre>

</dd>
<dt id="sv_unmagic"><a class="permalink" href="#sv_unmagic">#</a>sv_unmagic</dt>
<dd>

<p>Removes magic from an SV.</p>

<pre><code class="plaintext">int	sv_unmagic(SV* sv, int type)</code></pre>

</dd>
<dt id="sv_unref"><a class="permalink" href="#sv_unref">#</a>sv_unref</dt>
<dd>

<p>Unsets the RV status of the SV, and decrements the reference count of whatever was being referenced by the RV. This can almost be thought of as a reversal of <code>newSVrv</code>. See <code>SvROK_off</code>.</p>

<pre><code class="plaintext">void	sv_unref(SV* sv)</code></pre>

</dd>
<dt id="sv_upgrade"><a class="permalink" href="#sv_upgrade">#</a>sv_upgrade</dt>
<dd>

<p>Upgrade an SV to a more complex form. Use <code>SvUPGRADE</code>. See <code>svtype</code>.</p>

<pre><code class="plaintext">bool	sv_upgrade(SV* sv, U32 mt)</code></pre>

</dd>
<dt id="sv_usepvn"><a class="permalink" href="#sv_usepvn">#</a>sv_usepvn</dt>
<dd>

<p>Tells an SV to use <code>ptr</code> to find its string value. Normally the string is stored inside the SV but sv_usepvn allows the SV to use an outside string. The <code>ptr</code> should point to memory that was allocated by <code>malloc</code>. The string length, <code>len</code>, must be supplied. This function will realloc the memory pointed to by <code>ptr</code>, so that pointer should not be freed or used by the programmer after giving it to sv_usepvn. Does not handle &#39;set&#39; magic. See <code>sv_usepvn_mg</code>.</p>

<pre><code class="plaintext">void	sv_usepvn(SV* sv, char* ptr, STRLEN len)</code></pre>

</dd>
<dt id="sv_usepvn_mg"><a class="permalink" href="#sv_usepvn_mg">#</a>sv_usepvn_mg</dt>
<dd>

<p>Like <code>sv_usepvn</code>, but also handles &#39;set&#39; magic.</p>

<pre><code class="plaintext">void	sv_usepvn_mg(SV *sv, char *ptr, STRLEN len)</code></pre>

</dd>
<dt id="sv_utf8_downgrade"><a class="permalink" href="#sv_utf8_downgrade">#</a>sv_utf8_downgrade</dt>
<dd>

<p>Attempt to convert the PV of an SV from UTF8-encoded to byte encoding. This may not be possible if the PV contains non-byte encoding characters; if this is the case, either returns false or, if <code>fail_ok</code> is not true, croaks.</p>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<pre><code class="plaintext">bool	sv_utf8_downgrade(SV *sv, bool fail_ok)</code></pre>

</dd>
<dt id="sv_utf8_encode"><a class="permalink" href="#sv_utf8_encode">#</a>sv_utf8_encode</dt>
<dd>

<p>Convert the PV of an SV to UTF8-encoded, but then turn off the <code>SvUTF8</code> flag so that it looks like bytes again. Nothing calls this.</p>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<pre><code class="plaintext">void	sv_utf8_encode(SV *sv)</code></pre>

</dd>
<dt id="sv_utf8_upgrade"><a class="permalink" href="#sv_utf8_upgrade">#</a>sv_utf8_upgrade</dt>
<dd>

<p>Convert the PV of an SV to its UTF8-encoded form.</p>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<pre><code class="plaintext">void	sv_utf8_upgrade(SV *sv)</code></pre>

</dd>
<dt id="sv_vcatpvfn"><a class="permalink" href="#sv_vcatpvfn">#</a>sv_vcatpvfn</dt>
<dd>

<p>Processes its arguments like <code>vsprintf</code> and appends the formatted output to an SV. Uses an array of SVs if the C style variable argument list is missing (NULL). When running with taint checks enabled, indicates via <code>maybe_tainted</code> if results are untrustworthy (often due to the use of locales).</p>

<pre><code class="plaintext">void	sv_vcatpvfn(SV* sv, const char* pat, STRLEN patlen, va_list* args, SV** svargs, I32 svmax, bool *maybe_tainted)</code></pre>

</dd>
<dt id="sv_vsetpvfn"><a class="permalink" href="#sv_vsetpvfn">#</a>sv_vsetpvfn</dt>
<dd>

<p>Works like <code>vcatpvfn</code> but copies the text into the SV instead of appending it.</p>

<pre><code class="plaintext">void	sv_vsetpvfn(SV* sv, const char* pat, STRLEN patlen, va_list* args, SV** svargs, I32 svmax, bool *maybe_tainted)</code></pre>

</dd>
<dt id="THIS"><a class="permalink" href="#THIS">#</a>THIS</dt>
<dd>

<p>Variable which is setup by <code>xsubpp</code> to designate the object in a C++ XSUB. This is always the proper type for the C++ object. See <code>CLASS</code> and <a href="perlxs.html#Using-XS-With-C%2B%2B">&quot;Using XS With C++&quot; in perlxs</a>.</p>

<pre><code class="plaintext">(whatever)	THIS</code></pre>

</dd>
<dt id="toLOWER"><a class="permalink" href="#toLOWER">#</a>toLOWER</dt>
<dd>

<p>Converts the specified character to lowercase.</p>

<pre><code class="plaintext">char	toLOWER(char ch)</code></pre>

</dd>
<dt id="toUPPER"><a class="permalink" href="#toUPPER">#</a>toUPPER</dt>
<dd>

<p>Converts the specified character to uppercase.</p>

<pre><code class="plaintext">char	toUPPER(char ch)</code></pre>

</dd>
<dt id="utf8_distance"><a class="permalink" href="#utf8_distance">#</a>utf8_distance</dt>
<dd>

<p>Returns the number of UTF8 characters between the UTF-8 pointers <code>a</code> and <code>b</code>.</p>

<p>WARNING: use only if you *know* that the pointers point inside the same UTF-8 buffer.</p>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<pre><code class="plaintext">IV	utf8_distance(U8 *a, U8 *b)</code></pre>

</dd>
<dt id="utf8_hop"><a class="permalink" href="#utf8_hop">#</a>utf8_hop</dt>
<dd>

<p>Return the UTF-8 pointer <code>s</code> displaced by <code>off</code> characters, either forward or backward.</p>

<p>WARNING: do not use the following unless you *know* <code>off</code> is within the UTF-8 data pointed to by <code>s</code> *and* that on entry <code>s</code> is aligned on the first byte of character or just after the last byte of a character.</p>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<pre><code class="plaintext">U8*	utf8_hop(U8 *s, I32 off)</code></pre>

</dd>
<dt id="utf8_length"><a class="permalink" href="#utf8_length">#</a>utf8_length</dt>
<dd>

<p>Return the length of the UTF-8 char encoded string <code>s</code> in characters. Stops at <code>e</code> (inclusive). If <code>e &lt; s</code> or if the scan would end up past <code>e</code>, croaks.</p>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<pre><code class="plaintext">STRLEN	utf8_length(U8* s, U8 *e)</code></pre>

</dd>
<dt id="utf8_to_bytes"><a class="permalink" href="#utf8_to_bytes">#</a>utf8_to_bytes</dt>
<dd>

<p>Converts a string <code>s</code> of length <code>len</code> from UTF8 into byte encoding. Unlike <code>bytes_to_utf8</code>, this over-writes the original string, and updates len to contain the new length. Returns zero on failure, setting <code>len</code> to -1.</p>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<pre><code class="plaintext">U8*	utf8_to_bytes(U8 *s, STRLEN *len)</code></pre>

</dd>
<dt id="utf8_to_uv"><a class="permalink" href="#utf8_to_uv">#</a>utf8_to_uv</dt>
<dd>

<p>Returns the character value of the first character in the string <code>s</code> which is assumed to be in UTF8 encoding and no longer than <code>curlen</code>; <code>retlen</code> will be set to the length, in bytes, of that character.</p>

<p>If <code>s</code> does not point to a well-formed UTF8 character, the behaviour is dependent on the value of <code>flags</code>: if it contains UTF8_CHECK_ONLY, it is assumed that the caller will raise a warning, and this function will silently just set <code>retlen</code> to <code>-1</code> and return zero. If the <code>flags</code> does not contain UTF8_CHECK_ONLY, warnings about malformations will be given, <code>retlen</code> will be set to the expected length of the UTF-8 character in bytes, and zero will be returned.</p>

<p>The <code>flags</code> can also contain various flags to allow deviations from the strict UTF-8 encoding (see <i>utf8.h</i>).</p>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<pre><code class="plaintext">UV	utf8_to_uv(U8 *s, STRLEN curlen, STRLEN* retlen, U32 flags)</code></pre>

</dd>
<dt id="utf8_to_uv_simple"><a class="permalink" href="#utf8_to_uv_simple">#</a>utf8_to_uv_simple</dt>
<dd>

<p>Returns the character value of the first character in the string <code>s</code> which is assumed to be in UTF8 encoding; <code>retlen</code> will be set to the length, in bytes, of that character.</p>

<p>If <code>s</code> does not point to a well-formed UTF8 character, zero is returned and retlen is set, if possible, to -1.</p>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<pre><code class="plaintext">UV	utf8_to_uv_simple(U8 *s, STRLEN* retlen)</code></pre>

</dd>
<dt id="uv_to_utf8"><a class="permalink" href="#uv_to_utf8">#</a>uv_to_utf8</dt>
<dd>

<p>Adds the UTF8 representation of the Unicode codepoint <code>uv</code> to the end of the string <code>d</code>; <code>d</code> should be have at least <code>UTF8_MAXLEN+1</code> free bytes available. The return value is the pointer to the byte after the end of the new character. In other words,</p>

<pre><code>d = uv_to_utf8(d, uv);</code></pre>

<p>is the recommended Unicode-aware way of saying</p>

<pre><code>*(d++) = uv;</code></pre>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<pre><code class="plaintext">U8*	uv_to_utf8(U8 *d, UV uv)</code></pre>

</dd>
<dt id="warn"><a class="permalink" href="#warn">#</a>warn</dt>
<dd>

<p>This is the XSUB-writer&#39;s interface to Perl&#39;s <code>warn</code> function. Use this function the same way you use the C <code>printf</code> function. See <code>croak</code>.</p>

<pre><code class="plaintext">void	warn(const char* pat, ...)</code></pre>

</dd>
<dt id="XPUSHi"><a class="permalink" href="#XPUSHi">#</a>XPUSHi</dt>
<dd>

<p>Push an integer onto the stack, extending the stack if necessary. Handles &#39;set&#39; magic. See <code>PUSHi</code>.</p>

<pre><code class="plaintext">void	XPUSHi(IV iv)</code></pre>

</dd>
<dt id="XPUSHn"><a class="permalink" href="#XPUSHn">#</a>XPUSHn</dt>
<dd>

<p>Push a double onto the stack, extending the stack if necessary. Handles &#39;set&#39; magic. See <code>PUSHn</code>.</p>

<pre><code class="plaintext">void	XPUSHn(NV nv)</code></pre>

</dd>
<dt id="XPUSHp"><a class="permalink" href="#XPUSHp">#</a>XPUSHp</dt>
<dd>

<p>Push a string onto the stack, extending the stack if necessary. The <code>len</code> indicates the length of the string. Handles &#39;set&#39; magic. See <code>PUSHp</code>.</p>

<pre><code class="plaintext">void	XPUSHp(char* str, STRLEN len)</code></pre>

</dd>
<dt id="XPUSHs"><a class="permalink" href="#XPUSHs">#</a>XPUSHs</dt>
<dd>

<p>Push an SV onto the stack, extending the stack if necessary. Does not handle &#39;set&#39; magic. See <code>PUSHs</code>.</p>

<pre><code class="plaintext">void	XPUSHs(SV* sv)</code></pre>

</dd>
<dt id="XPUSHu"><a class="permalink" href="#XPUSHu">#</a>XPUSHu</dt>
<dd>

<p>Push an unsigned integer onto the stack, extending the stack if necessary. See <code>PUSHu</code>.</p>

<pre><code class="plaintext">void	XPUSHu(UV uv)</code></pre>

</dd>
<dt id="XS"><a class="permalink" href="#XS">#</a>XS</dt>
<dd>

<p>Macro to declare an XSUB and its C parameter list. This is handled by <code>xsubpp</code>.</p>

</dd>
<dt id="XSRETURN"><a class="permalink" href="#XSRETURN">#</a>XSRETURN</dt>
<dd>

<p>Return from XSUB, indicating number of items on the stack. This is usually handled by <code>xsubpp</code>.</p>

<pre><code class="plaintext">void	XSRETURN(int nitems)</code></pre>

</dd>
<dt id="XSRETURN_EMPTY"><a class="permalink" href="#XSRETURN_EMPTY">#</a>XSRETURN_EMPTY</dt>
<dd>

<p>Return an empty list from an XSUB immediately.</p>

<pre><code>XSRETURN_EMPTY;</code></pre>

</dd>
<dt id="XSRETURN_IV"><a class="permalink" href="#XSRETURN_IV">#</a>XSRETURN_IV</dt>
<dd>

<p>Return an integer from an XSUB immediately. Uses <code>XST_mIV</code>.</p>

<pre><code class="plaintext">void	XSRETURN_IV(IV iv)</code></pre>

</dd>
<dt id="XSRETURN_NO"><a class="permalink" href="#XSRETURN_NO">#</a>XSRETURN_NO</dt>
<dd>

<p>Return <code>&amp;PL_sv_no</code> from an XSUB immediately. Uses <code>XST_mNO</code>.</p>

<pre><code>XSRETURN_NO;</code></pre>

</dd>
<dt id="XSRETURN_NV"><a class="permalink" href="#XSRETURN_NV">#</a>XSRETURN_NV</dt>
<dd>

<p>Return an double from an XSUB immediately. Uses <code>XST_mNV</code>.</p>

<pre><code class="plaintext">void	XSRETURN_NV(NV nv)</code></pre>

</dd>
<dt id="XSRETURN_PV"><a class="permalink" href="#XSRETURN_PV">#</a>XSRETURN_PV</dt>
<dd>

<p>Return a copy of a string from an XSUB immediately. Uses <code>XST_mPV</code>.</p>

<pre><code class="plaintext">void	XSRETURN_PV(char* str)</code></pre>

</dd>
<dt id="XSRETURN_UNDEF"><a class="permalink" href="#XSRETURN_UNDEF">#</a>XSRETURN_UNDEF</dt>
<dd>

<p>Return <code>&amp;PL_sv_undef</code> from an XSUB immediately. Uses <code>XST_mUNDEF</code>.</p>

<pre><code>XSRETURN_UNDEF;</code></pre>

</dd>
<dt id="XSRETURN_YES"><a class="permalink" href="#XSRETURN_YES">#</a>XSRETURN_YES</dt>
<dd>

<p>Return <code>&amp;PL_sv_yes</code> from an XSUB immediately. Uses <code>XST_mYES</code>.</p>

<pre><code>XSRETURN_YES;</code></pre>

</dd>
<dt id="XST_mIV"><a class="permalink" href="#XST_mIV">#</a>XST_mIV</dt>
<dd>

<p>Place an integer into the specified position <code>pos</code> on the stack. The value is stored in a new mortal SV.</p>

<pre><code class="plaintext">void	XST_mIV(int pos, IV iv)</code></pre>

</dd>
<dt id="XST_mNO"><a class="permalink" href="#XST_mNO">#</a>XST_mNO</dt>
<dd>

<p>Place <code>&amp;PL_sv_no</code> into the specified position <code>pos</code> on the stack.</p>

<pre><code class="plaintext">void	XST_mNO(int pos)</code></pre>

</dd>
<dt id="XST_mNV"><a class="permalink" href="#XST_mNV">#</a>XST_mNV</dt>
<dd>

<p>Place a double into the specified position <code>pos</code> on the stack. The value is stored in a new mortal SV.</p>

<pre><code class="plaintext">void	XST_mNV(int pos, NV nv)</code></pre>

</dd>
<dt id="XST_mPV"><a class="permalink" href="#XST_mPV">#</a>XST_mPV</dt>
<dd>

<p>Place a copy of a string into the specified position <code>pos</code> on the stack. The value is stored in a new mortal SV.</p>

<pre><code class="plaintext">void	XST_mPV(int pos, char* str)</code></pre>

</dd>
<dt id="XST_mUNDEF"><a class="permalink" href="#XST_mUNDEF">#</a>XST_mUNDEF</dt>
<dd>

<p>Place <code>&amp;PL_sv_undef</code> into the specified position <code>pos</code> on the stack.</p>

<pre><code class="plaintext">void	XST_mUNDEF(int pos)</code></pre>

</dd>
<dt id="XST_mYES"><a class="permalink" href="#XST_mYES">#</a>XST_mYES</dt>
<dd>

<p>Place <code>&amp;PL_sv_yes</code> into the specified position <code>pos</code> on the stack.</p>

<pre><code class="plaintext">void	XST_mYES(int pos)</code></pre>

</dd>
<dt id="XS_VERSION"><a class="permalink" href="#XS_VERSION">#</a>XS_VERSION</dt>
<dd>

<p>The version identifier for an XS module. This is usually handled automatically by <code>ExtUtils::MakeMaker</code>. See <code>XS_VERSION_BOOTCHECK</code>.</p>

</dd>
<dt id="XS_VERSION_BOOTCHECK"><a class="permalink" href="#XS_VERSION_BOOTCHECK">#</a>XS_VERSION_BOOTCHECK</dt>
<dd>

<p>Macro to verify that a PM module&#39;s $VERSION variable matches the XS module&#39;s <code>XS_VERSION</code> variable. This is usually handled automatically by <code>xsubpp</code>. See <a href="perlxs.html#The-VERSIONCHECK%3A-Keyword">&quot;The VERSIONCHECK: Keyword&quot; in perlxs</a>.</p>

<pre><code>XS_VERSION_BOOTCHECK;</code></pre>

</dd>
<dt id="Zero"><a class="permalink" href="#Zero">#</a>Zero</dt>
<dd>

<p>The XSUB-writer&#39;s interface to the C <code>memzero</code> function. The <code>dest</code> is the destination, <code>nitems</code> is the number of items, and <code>type</code> is the type.</p>

<pre><code class="plaintext">void	Zero(void* dest, int nitems, type)</code></pre>

</dd>
</dl>

<h1 id="AUTHORS"><a class="permalink" href="#AUTHORS">#</a>AUTHORS</h1>

<p>Until May 1997, this document was maintained by Jeff Okamoto &lt;okamoto@corp.hp.com&gt;. It is now maintained as part of Perl itself.</p>

<p>With lots of help and suggestions from Dean Roehrich, Malcolm Beattie, Andreas Koenig, Paul Hudson, Ilya Zakharevich, Paul Marquess, Neil Bowers, Matthew Green, Tim Bunce, Spider Boardman, Ulrich Pfeifer, Stephen McCamant, and Gurusamy Sarathy.</p>

<p>API Listing originally by Dean Roehrich &lt;roehrich@cray.com&gt;.</p>

<p>Updated to be autogenerated from comments in the source by Benjamin Stuhl.</p>

<h1 id="SEE-ALSO"><a class="permalink" href="#SEE-ALSO">#</a><a id="SEE"></a>SEE ALSO</h1>

<p>perlguts(1), perlxs(1), perlxstut(1), perlintern(1)</p>


      </div>
      <div id="footer">
        <p>Perldoc Browser is maintained by Dan Book (<a href="https://metacpan.org/author/DBOOK">DBOOK</a>). Please contact him via the <a href="https://github.com/Grinnz/perldoc-browser/issues">GitHub issue tracker</a> or <a href="mailto:dbook@cpan.org">email</a> regarding any issues with the site itself, search, or rendering of documentation.</p>

<p>The Perl documentation is maintained by the Perl 5 Porters in the development of Perl. Please contact them via the <a href="https://github.com/Perl/perl5/issues">Perl issue tracker</a>, the <a href="https://lists.perl.org/list/perl5-porters.html">mailing list</a>, or <a href="https://kiwiirc.com/client/irc.perl.org/p5p">IRC</a> to report any issues with the contents or format of the documentation.</p>


      </div>
    </div>
    <script src="../js/bootstrap.bundle.min.js"></script>
    <script src="../js/highlight.pack.js"></script>
    <script>hljs.highlightAll();</script>
  </body>

<!-- Mirrored from perldoc.perl.org/5.6.1/perlapi by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 06 Aug 2025 16:20:46 GMT -->
</html>
