<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from perldoc.perl.org/5.12.4/perltoot by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 06 Aug 2025 16:20:39 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>perltoot - Tom&#39;s object-oriented tutorial for perl - Perldoc Browser</title>
    <link rel="search" href="../opensearch.xml" type="application/opensearchdescription+xml" title="Perldoc Browser">
    <link rel="canonical" href="../perltoot.html">
    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/stackoverflow-light.min.css" rel="stylesheet">
    <link href="../css/perldoc.css" rel="stylesheet">
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-KVNWBNT5FB"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-KVNWBNT5FB');
      gtag('config', 'UA-50555-3');
    </script>
  </head>
  <body>
    <nav class="navbar navbar-expand-md bg-dark" data-bs-theme="dark"><div class="container-fluid">
  <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <a class="navbar-brand" href="../index.html"><img src="../images/perl_camel_30.png" width="30" height="30" class="d-inline-block align-text-top" alt="Perl Camel Logo"> Perldoc Browser</a>
  <div class="collapse navbar-collapse" id="navbarNav">
    <ul class="navbar-nav me-auto">
      <li class="nav-item dropdown text-nowrap">
        <a class="nav-link dropdown-toggle" href="#" id="dropdownlink-stable" role="button" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">5.12.4</a>
        <div class="dropdown-menu" aria-labelledby="dropdownlink-stable">
          <a class="dropdown-item" href="../perltoot.html">Latest</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.42.0/perltoot">5.42.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.40.3/perltoot">5.40.3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.40.2/perltoot">5.40.2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.40.1/perltoot">5.40.1</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.40.0/perltoot">5.40.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.38.5/perltoot">5.38.5</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.38.4/perltoot">5.38.4</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.38.3/perltoot">5.38.3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.38.2/perltoot">5.38.2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.38.1/perltoot">5.38.1</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.38.0/perltoot">5.38.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.36.3/perltoot">5.36.3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.36.2/perltoot">5.36.2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.36.1/perltoot">5.36.1</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.36.0/perltoot">5.36.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.34.3/perltoot">5.34.3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.34.2/perltoot">5.34.2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.34.1/perltoot">5.34.1</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.34.0/perltoot">5.34.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.32.1/perltoot">5.32.1</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.32.0/perltoot">5.32.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.30.3/perltoot">5.30.3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.30.2/perltoot">5.30.2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.30.1/perltoot">5.30.1</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.30.0/perltoot">5.30.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.28.3/perltoot">5.28.3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.28.2/perltoot">5.28.2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.28.1/perltoot">5.28.1</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.28.0/perltoot">5.28.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.26.3/perltoot">5.26.3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.26.2/perltoot">5.26.2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.26.1/perltoot">5.26.1</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.26.0/perltoot">5.26.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.24.4/perltoot">5.24.4</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.24.3/perltoot">5.24.3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.24.2/perltoot">5.24.2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.24.1/perltoot">5.24.1</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.24.0/perltoot">5.24.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.22.4/perltoot">5.22.4</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.22.3/perltoot">5.22.3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.22.2/perltoot">5.22.2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.22.1/perltoot">5.22.1</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.22.0/perltoot">5.22.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.20.3/perltoot">5.20.3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.20.2/perltoot">5.20.2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.20.1/perltoot">5.20.1</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.20.0/perltoot">5.20.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.18.4/perltoot">5.18.4</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.18.3/perltoot">5.18.3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.18.2/perltoot">5.18.2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.18.1/perltoot">5.18.1</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.18.0/perltoot">5.18.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.16.3/perltoot">5.16.3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.16.2/perltoot">5.16.2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.16.1/perltoot">5.16.1</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.16.0/perltoot">5.16.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="../5.14.4/perltoot.html">5.14.4</a>
          <a class="dropdown-item" href="../5.14.3/perltoot.html">5.14.3</a>
          <a class="dropdown-item" href="../5.14.2/perltoot.html">5.14.2</a>
          <a class="dropdown-item" href="../5.14.1/perltoot.html">5.14.1</a>
          <a class="dropdown-item" href="../5.14.0/perltoot.html">5.14.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="../5.12.5/perltoot.html">5.12.5</a>
          <a class="dropdown-item active" href="perltoot.html">5.12.4</a>
          <a class="dropdown-item" href="../5.12.3/perltoot.html">5.12.3</a>
          <a class="dropdown-item" href="../5.12.2/perltoot.html">5.12.2</a>
          <a class="dropdown-item" href="../5.12.1/perltoot.html">5.12.1</a>
          <a class="dropdown-item" href="../5.12.0/perltoot.html">5.12.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="../5.10.1/perltoot.html">5.10.1</a>
          <a class="dropdown-item" href="../5.10.0/perltoot.html">5.10.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="../5.8.9/perltoot.html">5.8.9</a>
          <a class="dropdown-item" href="../5.8.8/perltoot.html">5.8.8</a>
          <a class="dropdown-item" href="../5.8.7/perltoot.html">5.8.7</a>
          <a class="dropdown-item" href="../5.8.6/perltoot.html">5.8.6</a>
          <a class="dropdown-item" href="../5.8.5/perltoot.html">5.8.5</a>
          <a class="dropdown-item" href="../5.8.4/perltoot.html">5.8.4</a>
          <a class="dropdown-item" href="../5.8.3/perltoot.html">5.8.3</a>
          <a class="dropdown-item" href="../5.8.2/perltoot.html">5.8.2</a>
          <a class="dropdown-item" href="../5.8.1/perltoot.html">5.8.1</a>
          <a class="dropdown-item" href="../5.8.0/perltoot.html">5.8.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="../5.6.2/perltoot.html">5.6.2</a>
          <a class="dropdown-item" href="../5.6.1/perltoot.html">5.6.1</a>
          <a class="dropdown-item" href="../5.6.0/perltoot.html">5.6.0</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="../5.005_04/perltoot.html">5.005_04</a>
          <a class="dropdown-item" href="../5.005_03/perltoot.html">5.005_03</a>
          <a class="dropdown-item" href="../5.005_02/perltoot.html">5.005_02</a>
          <a class="dropdown-item" href="../5.005_01/perltoot.html">5.005_01</a>
          <a class="dropdown-item" href="../5.005/perltoot.html">5.005</a>
        </div>
      </li>
      <li class="nav-item dropdown text-nowrap">
        <a class="nav-link dropdown-toggle" href="#" id="dropdownlink-dev" role="button" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Dev</a>
        <div class="dropdown-menu" aria-labelledby="dropdownlink-dev">
          <a class="dropdown-item" href="https://perldoc.perl.org/blead/perltoot">blead</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.43.1/perltoot">5.43.1</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.42.0-RC3/perltoot">5.42.0-RC3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.42.0-RC2/perltoot">5.42.0-RC2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.42.0-RC1/perltoot">5.42.0-RC1</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.41.13/perltoot">5.41.13</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.41.12/perltoot">5.41.12</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.41.11/perltoot">5.41.11</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.41.10/perltoot">5.41.10</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.41.9/perltoot">5.41.9</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.41.8/perltoot">5.41.8</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.41.7/perltoot">5.41.7</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.41.6/perltoot">5.41.6</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.41.5/perltoot">5.41.5</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.41.4/perltoot">5.41.4</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.41.3/perltoot">5.41.3</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.41.2/perltoot">5.41.2</a>
          <a class="dropdown-item" href="https://perldoc.perl.org/5.41.1/perltoot">5.41.1</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.40.3-RC1/perltoot">5.40.3-RC1</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="https://perldoc.perl.org/5.38.5-RC1/perltoot">5.38.5-RC1</a>
        </div>
      </li>
      <li class="nav-item dropdown text-nowrap">
        <a class="nav-link dropdown-toggle" href="#" id="dropdownlink-nav" role="button" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Documentation</a>
        <div class="dropdown-menu" aria-labelledby="dropdownlink-nav">
          <a class="dropdown-item" href="perl.html">Perl</a>
          <a class="dropdown-item" href="perlintro.html">Intro</a>
          <a class="dropdown-item" href="perl.html#Tutorials">Tutorials</a>
          <a class="dropdown-item" href="perlfaq.html">FAQs</a>
          <a class="dropdown-item" href="perl.html#Reference-Manual">Reference</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="perlop.html">Operators</a>
          <a class="dropdown-item" href="functions.html">Functions</a>
          <a class="dropdown-item" href="variables.html">Variables</a>
          <a class="dropdown-item" href="modules.html">Modules</a>
          <a class="dropdown-item" href="perlutil.html">Utilities</a>
          <hr class="dropdown-divider">
          <a class="dropdown-item" href="perldelta.html">Release Notes</a>
          <a class="dropdown-item" href="perlcommunity.html">Community</a>
          <a class="dropdown-item" href="perlhist.html">History</a>
        </div>
      </li>
    </ul>
    <ul class="navbar-nav">
      <button id="content-expand-button" type="button" class="btn btn-dark d-none d-lg-inline-block me-4">Expand</button>
      <script src="../js/perldoc-expand-page.js"></script>
    </ul>
    <form class="form-inline" method="get" action="https://perldoc.perl.org/5.12.4/search">
      <input id="search-input" class="form-control me-3" type="search" name="q" placeholder="[S]earch" aria-label="Search" value="">
    </form>
    <script src="../js/perldoc-focus-search.js"></script>
  </div>
</div></nav>

    <div id="wrapperlicious" class="container-fluid">
      <div id="perldocdiv">
        <div id="links">
          <a href="perltoot.html">perltoot</a>
          <div id="more">
            (<a href="https://perldoc.perl.org/5.12.4/perltoot.txt">source</a>,
            <a href="https://metacpan.org/pod/perltoot">CPAN</a>)
          </div>
        </div>
        <div class="leading-notice">
          You are viewing the version of this documentation from Perl 5.12.4.
            <a href="../perltoot.html">View the latest version</a>
        </div>
        <h1><a id="toc">CONTENTS</a></h1>
                  <ul>
              <li>
                <a class="text-decoration-none" href="#NAME">NAME</a>
              </li>
              <li>
                <a class="text-decoration-none" href="#DESCRIPTION">DESCRIPTION</a>
              </li>
              <li>
                <a class="text-decoration-none" href="#Creating-a-Class">Creating a Class</a>
                            <ul>
              <li>
                <a class="text-decoration-none" href="#Object-Representation">Object Representation</a>
              </li>
              <li>
                <a class="text-decoration-none" href="#Class-Interface">Class Interface</a>
              </li>
              <li>
                <a class="text-decoration-none" href="#Constructors-and-Instance-Methods">Constructors and Instance Methods</a>
              </li>
              <li>
                <a class="text-decoration-none" href="#Planning-for-the-Future:-Better-Constructors">Planning for the Future: Better Constructors</a>
              </li>
              <li>
                <a class="text-decoration-none" href="#Destructors">Destructors</a>
              </li>
              <li>
                <a class="text-decoration-none" href="#Other-Object-Methods">Other Object Methods</a>
              </li>
          </ul>

              </li>
              <li>
                <a class="text-decoration-none" href="#Class-Data">Class Data</a>
                            <ul>
              <li>
                <a class="text-decoration-none" href="#Accessing-Class-Data">Accessing Class Data</a>
              </li>
              <li>
                <a class="text-decoration-none" href="#Debugging-Methods">Debugging Methods</a>
              </li>
              <li>
                <a class="text-decoration-none" href="#Class-Destructors">Class Destructors</a>
              </li>
              <li>
                <a class="text-decoration-none" href="#Documenting-the-Interface">Documenting the Interface</a>
              </li>
          </ul>

              </li>
              <li>
                <a class="text-decoration-none" href="#Aggregation">Aggregation</a>
              </li>
              <li>
                <a class="text-decoration-none" href="#Inheritance">Inheritance</a>
                            <ul>
              <li>
                <a class="text-decoration-none" href="#Overridden-Methods">Overridden Methods</a>
              </li>
              <li>
                <a class="text-decoration-none" href="#Multiple-Inheritance">Multiple Inheritance</a>
              </li>
              <li>
                <a class="text-decoration-none" href="#UNIVERSAL:-The-Root-of-All-Objects">UNIVERSAL: The Root of All Objects</a>
              </li>
              <li>
                <a class="text-decoration-none" href="#Deeper-UNIVERSAL-details">Deeper UNIVERSAL details</a>
              </li>
          </ul>

              </li>
              <li>
                <a class="text-decoration-none" href="#Alternate-Object-Representations">Alternate Object Representations</a>
                            <ul>
              <li>
                <a class="text-decoration-none" href="#Arrays-as-Objects">Arrays as Objects</a>
              </li>
              <li>
                <a class="text-decoration-none" href="#Closures-as-Objects">Closures as Objects</a>
              </li>
          </ul>

              </li>
              <li>
                <a class="text-decoration-none" href="#AUTOLOAD:-Proxy-Methods">AUTOLOAD: Proxy Methods</a>
                            <ul>
              <li>
                <a class="text-decoration-none" href="#Autoloaded-Data-Methods">Autoloaded Data Methods</a>
              </li>
              <li>
                <a class="text-decoration-none" href="#Inherited-Autoloaded-Data-Methods">Inherited Autoloaded Data Methods</a>
              </li>
          </ul>

              </li>
              <li>
                <a class="text-decoration-none" href="#Metaclassical-Tools">Metaclassical Tools</a>
                            <ul>
              <li>
                <a class="text-decoration-none" href="#Class::Struct">Class::Struct</a>
              </li>
              <li>
                <a class="text-decoration-none" href="#Data-Members-as-Variables">Data Members as Variables</a>
              </li>
          </ul>

              </li>
              <li>
                <a class="text-decoration-none" href="#NOTES">NOTES</a>
                            <ul>
              <li>
                <a class="text-decoration-none" href="#Object-Terminology">Object Terminology</a>
              </li>
          </ul>

              </li>
              <li>
                <a class="text-decoration-none" href="#SEE-ALSO">SEE ALSO</a>
              </li>
              <li>
                <a class="text-decoration-none" href="#AUTHOR-AND-COPYRIGHT">AUTHOR AND COPYRIGHT</a>
              </li>
              <li>
                <a class="text-decoration-none" href="#COPYRIGHT">COPYRIGHT</a>
                            <ul>
              <li>
                <a class="text-decoration-none" href="#Acknowledgments">Acknowledgments</a>
              </li>
          </ul>

              </li>
          </ul>

      <h1 id="NAME"><a class="permalink" href="#NAME">#</a>NAME</h1>

<p>perltoot - Tom&#39;s object-oriented tutorial for perl</p>

<h1 id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">#</a>DESCRIPTION</h1>

<p>Object-oriented programming is a big seller these days. Some managers would rather have objects than sliced bread. Why is that? What&#39;s so special about an object? Just what <i>is</i> an object anyway?</p>

<p>An object is nothing but a way of tucking away complex behaviours into a neat little easy-to-use bundle. (This is what professors call abstraction.) Smart people who have nothing to do but sit around for weeks on end figuring out really hard problems make these nifty objects that even regular people can use. (This is what professors call software reuse.) Users (well, programmers) can play with this little bundle all they want, but they aren&#39;t to open it up and mess with the insides. Just like an expensive piece of hardware, the contract says that you void the warranty if you muck with the cover. So don&#39;t do that.</p>

<p>The heart of objects is the class, a protected little private namespace full of data and functions. A class is a set of related routines that addresses some problem area. You can think of it as a user-defined type. The Perl package mechanism, also used for more traditional modules, is used for class modules as well. Objects &quot;live&quot; in a class, meaning that they belong to some package.</p>

<p>More often than not, the class provides the user with little bundles. These bundles are objects. They know whose class they belong to, and how to behave. Users ask the class to do something, like &quot;give me an object.&quot; Or they can ask one of these objects to do something. Asking a class to do something for you is calling a <i>class method</i>. Asking an object to do something for you is calling an <i>object method</i>. Asking either a class (usually) or an object (sometimes) to give you back an object is calling a <i>constructor</i>, which is just a kind of method.</p>

<p>That&#39;s all well and good, but how is an object different from any other Perl data type? Just what is an object <i>really</i>; that is, what&#39;s its fundamental type? The answer to the first question is easy. An object is different from any other data type in Perl in one and only one way: you may dereference it using not merely string or numeric subscripts as with simple arrays and hashes, but with named subroutine calls. In a word, with <i>methods</i>.</p>

<p>The answer to the second question is that it&#39;s a reference, and not just any reference, mind you, but one whose referent has been <i>bless</i>()ed into a particular class (read: package). What kind of reference? Well, the answer to that one is a bit less concrete. That&#39;s because in Perl the designer of the class can employ any sort of reference they&#39;d like as the underlying intrinsic data type. It could be a scalar, an array, or a hash reference. It could even be a code reference. But because of its inherent flexibility, an object is usually a hash reference.</p>

<h1 id="Creating-a-Class"><a class="permalink" href="#Creating-a-Class">#</a><a id="Creating"></a>Creating a Class</h1>

<p>Before you create a class, you need to decide what to name it. That&#39;s because the class (package) name governs the name of the file used to house it, just as with regular modules. Then, that class (package) should provide one or more ways to generate objects. Finally, it should provide mechanisms to allow users of its objects to indirectly manipulate these objects from a distance.</p>

<p>For example, let&#39;s make a simple Person class module. It gets stored in the file Person.pm. If it were called a Happy::Person class, it would be stored in the file Happy/Person.pm, and its package would become Happy::Person instead of just Person. (On a personal computer not running Unix or Plan 9, but something like Mac OS or VMS, the directory separator may be different, but the principle is the same.) Do not assume any formal relationship between modules based on their directory names. This is merely a grouping convenience, and has no effect on inheritance, variable accessibility, or anything else.</p>

<p>For this module we aren&#39;t going to use Exporter, because we&#39;re a well-behaved class module that doesn&#39;t export anything at all. In order to manufacture objects, a class needs to have a <i>constructor method</i>. A constructor gives you back not just a regular data type, but a brand-new object in that class. This magic is taken care of by the bless() function, whose sole purpose is to enable its referent to be used as an object. Remember: being an object really means nothing more than that methods may now be called against it.</p>

<p>While a constructor may be named anything you&#39;d like, most Perl programmers seem to like to call theirs new(). However, new() is not a reserved word, and a class is under no obligation to supply such. Some programmers have also been known to use a function with the same name as the class as the constructor.</p>

<h2 id="Object-Representation"><a class="permalink" href="#Object-Representation">#</a><a id="Object"></a>Object Representation</h2>

<p>By far the most common mechanism used in Perl to represent a Pascal record, a C struct, or a C++ class is an anonymous hash. That&#39;s because a hash has an arbitrary number of data fields, each conveniently accessed by an arbitrary name of your own devising.</p>

<p>If you were just doing a simple struct-like emulation, you would likely go about it something like this:</p>

<pre><code>$rec = {
    name  =&gt; &quot;Jason&quot;,
    age   =&gt; 23,
    peers =&gt; [ &quot;Norbert&quot;, &quot;Rhys&quot;, &quot;Phineas&quot;],
};</code></pre>

<p>If you felt like it, you could add a bit of visual distinction by up-casing the hash keys:</p>

<pre><code>$rec = {
    NAME  =&gt; &quot;Jason&quot;,
    AGE   =&gt; 23,
    PEERS =&gt; [ &quot;Norbert&quot;, &quot;Rhys&quot;, &quot;Phineas&quot;],
};</code></pre>

<p>And so you could get at <code>$rec-&gt;{NAME}</code> to find &quot;Jason&quot;, or <code>@{ $rec-&gt;{PEERS} }</code> to get at &quot;Norbert&quot;, &quot;Rhys&quot;, and &quot;Phineas&quot;. (Have you ever noticed how many 23-year-old programmers seem to be named &quot;Jason&quot; these days? :-)</p>

<p>This same model is often used for classes, although it is not considered the pinnacle of programming propriety for folks from outside the class to come waltzing into an object, brazenly accessing its data members directly. Generally speaking, an object should be considered an opaque cookie that you use <i>object methods</i> to access. Visually, methods look like you&#39;re dereffing a reference using a function name instead of brackets or braces.</p>

<h2 id="Class-Interface"><a class="permalink" href="#Class-Interface">#</a><a id="Class"></a>Class Interface</h2>

<p>Some languages provide a formal syntactic interface to a class&#39;s methods, but Perl does not. It relies on you to read the documentation of each class. If you try to call an undefined method on an object, Perl won&#39;t complain, but the program will trigger an exception while it&#39;s running. Likewise, if you call a method expecting a prime number as its argument with a non-prime one instead, you can&#39;t expect the compiler to catch this. (Well, you can expect it all you like, but it&#39;s not going to happen.)</p>

<p>Let&#39;s suppose you have a well-educated user of your Person class, someone who has read the docs that explain the prescribed interface. Here&#39;s how they might use the Person class:</p>

<pre><code>use Person;

$him = Person-&gt;new();
$him-&gt;name(&quot;Jason&quot;);
$him-&gt;age(23);
$him-&gt;peers( &quot;Norbert&quot;, &quot;Rhys&quot;, &quot;Phineas&quot; );

push @All_Recs, $him;  # save object in array for later

printf &quot;%s is %d years old.\n&quot;, $him-&gt;name, $him-&gt;age;
print &quot;His peers are: &quot;, join(&quot;, &quot;, $him-&gt;peers), &quot;\n&quot;;

printf &quot;Last rec&#39;s name is %s\n&quot;, $All_Recs[-1]-&gt;name;</code></pre>

<p>As you can see, the user of the class doesn&#39;t know (or at least, has no business paying attention to the fact) that the object has one particular implementation or another. The interface to the class and its objects is exclusively via methods, and that&#39;s all the user of the class should ever play with.</p>

<h2 id="Constructors-and-Instance-Methods"><a class="permalink" href="#Constructors-and-Instance-Methods">#</a><a id="Constructors"></a>Constructors and Instance Methods</h2>

<p>Still, <i>someone</i> has to know what&#39;s in the object. And that someone is the class. It implements methods that the programmer uses to access the object. Here&#39;s how to implement the Person class using the standard hash-ref-as-an-object idiom. We&#39;ll make a class method called new() to act as the constructor, and three object methods called name(), age(), and peers() to get at per-object data hidden away in our anonymous hash.</p>

<pre><code>package Person;
use strict;

##################################################
## the object constructor (simplistic version)  ##
##################################################
sub new {
    my $self  = {};
    $self-&gt;{NAME}   = undef;
    $self-&gt;{AGE}    = undef;
    $self-&gt;{PEERS}  = [];
    bless($self);           # but see below
    return $self;
}

##############################################
## methods to access per-object data        ##
##                                          ##
## With args, they set the value.  Without  ##
## any, they only retrieve it/them.         ##
##############################################

sub name {
    my $self = shift;
    if (@_) { $self-&gt;{NAME} = shift }
    return $self-&gt;{NAME};
}

sub age {
    my $self = shift;
    if (@_) { $self-&gt;{AGE} = shift }
    return $self-&gt;{AGE};
}

sub peers {
    my $self = shift;
    if (@_) { @{ $self-&gt;{PEERS} } = @_ }
    return @{ $self-&gt;{PEERS} };
}

1;  # so the require or use succeeds</code></pre>

<p>We&#39;ve created three methods to access an object&#39;s data, name(), age(), and peers(). These are all substantially similar. If called with an argument, they set the appropriate field; otherwise they return the value held by that field, meaning the value of that hash key.</p>

<h2 id="Planning-for-the-Future:-Better-Constructors"><a class="permalink" href="#Planning-for-the-Future:-Better-Constructors">#</a><a id="Planning"></a>Planning for the Future: Better Constructors</h2>

<p>Even though at this point you may not even know what it means, someday you&#39;re going to worry about inheritance. (You can safely ignore this for now and worry about it later if you&#39;d like.) To ensure that this all works out smoothly, you must use the double-argument form of bless(). The second argument is the class into which the referent will be blessed. By not assuming our own class as the default second argument and instead using the class passed into us, we make our constructor inheritable.</p>

<pre><code>sub new {
    my $class = shift;
    my $self  = {};
    $self-&gt;{NAME}   = undef;
    $self-&gt;{AGE}    = undef;
    $self-&gt;{PEERS}  = [];
    bless ($self, $class);
    return $self;
}</code></pre>

<p>That&#39;s about all there is for constructors. These methods bring objects to life, returning neat little opaque bundles to the user to be used in subsequent method calls.</p>

<h2 id="Destructors"><a class="permalink" href="#Destructors">#</a>Destructors</h2>

<p>Every story has a beginning and an end. The beginning of the object&#39;s story is its constructor, explicitly called when the object comes into existence. But the ending of its story is the <i>destructor</i>, a method implicitly called when an object leaves this life. Any per-object clean-up code is placed in the destructor, which must (in Perl) be called DESTROY.</p>

<p>If constructors can have arbitrary names, then why not destructors? Because while a constructor is explicitly called, a destructor is not. Destruction happens automatically via Perl&#39;s garbage collection (GC) system, which is a quick but somewhat lazy reference-based GC system. To know what to call, Perl insists that the destructor be named DESTROY. Perl&#39;s notion of the right time to call a destructor is not well-defined currently, which is why your destructors should not rely on when they are called.</p>

<p>Why is DESTROY in all caps? Perl on occasion uses purely uppercase function names as a convention to indicate that the function will be automatically called by Perl in some way. Others that are called implicitly include BEGIN, END, AUTOLOAD, plus all methods used by tied objects, described in <a href="perltie.html">perltie</a>.</p>

<p>In really good object-oriented programming languages, the user doesn&#39;t care when the destructor is called. It just happens when it&#39;s supposed to. In low-level languages without any GC at all, there&#39;s no way to depend on this happening at the right time, so the programmer must explicitly call the destructor to clean up memory and state, crossing their fingers that it&#39;s the right time to do so. Unlike C++, an object destructor is nearly never needed in Perl, and even when it is, explicit invocation is uncalled for. In the case of our Person class, we don&#39;t need a destructor because Perl takes care of simple matters like memory deallocation.</p>

<p>The only situation where Perl&#39;s reference-based GC won&#39;t work is when there&#39;s a circularity in the data structure, such as:</p>

<pre><code>$this-&gt;{WHATEVER} = $this;</code></pre>

<p>In that case, you must delete the self-reference manually if you expect your program not to leak memory. While admittedly error-prone, this is the best we can do right now. Nonetheless, rest assured that when your program is finished, its objects&#39; destructors are all duly called. So you are guaranteed that an object <i>eventually</i> gets properly destroyed, except in the unique case of a program that never exits. (If you&#39;re running Perl embedded in another application, this full GC pass happens a bit more frequently--whenever a thread shuts down.)</p>

<h2 id="Other-Object-Methods"><a class="permalink" href="#Other-Object-Methods">#</a><a id="Other"></a>Other Object Methods</h2>

<p>The methods we&#39;ve talked about so far have either been constructors or else simple &quot;data methods&quot;, interfaces to data stored in the object. These are a bit like an object&#39;s data members in the C++ world, except that strangers don&#39;t access them as data. Instead, they should only access the object&#39;s data indirectly via its methods. This is an important rule: in Perl, access to an object&#39;s data should <i>only</i> be made through methods.</p>

<p>Perl doesn&#39;t impose restrictions on who gets to use which methods. The public-versus-private distinction is by convention, not syntax. (Well, unless you use the Alias module described below in <a href="#Data-Members-as-Variables">&quot;Data Members as Variables&quot;</a>.) Occasionally you&#39;ll see method names beginning or ending with an underscore or two. This marking is a convention indicating that the methods are private to that class alone and sometimes to its closest acquaintances, its immediate subclasses. But this distinction is not enforced by Perl itself. It&#39;s up to the programmer to behave.</p>

<p>There&#39;s no reason to limit methods to those that simply access data. Methods can do anything at all. The key point is that they&#39;re invoked against an object or a class. Let&#39;s say we&#39;d like object methods that do more than fetch or set one particular field.</p>

<pre><code>sub exclaim {
    my $self = shift;
    return sprintf &quot;Hi, I&#39;m %s, age %d, working with %s&quot;,
        $self-&gt;{NAME}, $self-&gt;{AGE}, join(&quot;, &quot;, @{$self-&gt;{PEERS}});
}</code></pre>

<p>Or maybe even one like this:</p>

<pre><code>sub happy_birthday {
    my $self = shift;
    return ++$self-&gt;{AGE};
}</code></pre>

<p>Some might argue that one should go at these this way:</p>

<pre><code>sub exclaim {
    my $self = shift;
    return sprintf &quot;Hi, I&#39;m %s, age %d, working with %s&quot;,
        $self-&gt;name, $self-&gt;age, join(&quot;, &quot;, $self-&gt;peers);
}

sub happy_birthday {
    my $self = shift;
    return $self-&gt;age( $self-&gt;age() + 1 );
}</code></pre>

<p>But since these methods are all executing in the class itself, this may not be critical. There are tradeoffs to be made. Using direct hash access is faster (about an order of magnitude faster, in fact), and it&#39;s more convenient when you want to interpolate in strings. But using methods (the external interface) internally shields not just the users of your class but even you yourself from changes in your data representation.</p>

<h1 id="Class-Data"><a class="permalink" href="#Class-Data">#</a><a id="Class1"></a>Class Data</h1>

<p>What about &quot;class data&quot;, data items common to each object in a class? What would you want that for? Well, in your Person class, you might like to keep track of the total people alive. How do you implement that?</p>

<p>You <i>could</i> make it a global variable called $Person::Census. But about only reason you&#39;d do that would be if you <i>wanted</i> people to be able to get at your class data directly. They could just say $Person::Census and play around with it. Maybe this is ok in your design scheme. You might even conceivably want to make it an exported variable. To be exportable, a variable must be a (package) global. If this were a traditional module rather than an object-oriented one, you might do that.</p>

<p>While this approach is expected in most traditional modules, it&#39;s generally considered rather poor form in most object modules. In an object module, you should set up a protective veil to separate interface from implementation. So provide a class method to access class data just as you provide object methods to access object data.</p>

<p>So, you <i>could</i> still keep $Census as a package global and rely upon others to honor the contract of the module and therefore not play around with its implementation. You could even be supertricky and make $Census a tied object as described in <a href="perltie.html">perltie</a>, thereby intercepting all accesses.</p>

<p>But more often than not, you just want to make your class data a file-scoped lexical. To do so, simply put this at the top of the file:</p>

<pre><code>my $Census = 0;</code></pre>

<p>Even though the scope of a my() normally expires when the block in which it was declared is done (in this case the whole file being required or used), Perl&#39;s deep binding of lexical variables guarantees that the variable will not be deallocated, remaining accessible to functions declared within that scope. This doesn&#39;t work with global variables given temporary values via local(), though.</p>

<p>Irrespective of whether you leave $Census a package global or make it instead a file-scoped lexical, you should make these changes to your Person::new() constructor:</p>

<pre><code>sub new {
    my $class = shift;
    my $self  = {};
    $Census++;
    $self-&gt;{NAME}   = undef;
    $self-&gt;{AGE}    = undef;
    $self-&gt;{PEERS}  = [];
    bless ($self, $class);
    return $self;
}

sub population {
    return $Census;
}</code></pre>

<p>Now that we&#39;ve done this, we certainly do need a destructor so that when Person is destroyed, the $Census goes down. Here&#39;s how this could be done:</p>

<pre><code>sub DESTROY { --$Census }</code></pre>

<p>Notice how there&#39;s no memory to deallocate in the destructor? That&#39;s something that Perl takes care of for you all by itself.</p>

<p>Alternatively, you could use the Class::Data::Inheritable module from CPAN.</p>

<h2 id="Accessing-Class-Data"><a class="permalink" href="#Accessing-Class-Data">#</a><a id="Accessing"></a>Accessing Class Data</h2>

<p>It turns out that this is not really a good way to go about handling class data. A good scalable rule is that <i>you must never reference class data directly from an object method</i>. Otherwise you aren&#39;t building a scalable, inheritable class. The object must be the rendezvous point for all operations, especially from an object method. The globals (class data) would in some sense be in the &quot;wrong&quot; package in your derived classes. In Perl, methods execute in the context of the class they were defined in, <i>not</i> that of the object that triggered them. Therefore, namespace visibility of package globals in methods is unrelated to inheritance.</p>

<p>Got that? Maybe not. Ok, let&#39;s say that some other class &quot;borrowed&quot; (well, inherited) the DESTROY method as it was defined above. When those objects are destroyed, the original $Census variable will be altered, not the one in the new class&#39;s package namespace. Perhaps this is what you want, but probably it isn&#39;t.</p>

<p>Here&#39;s how to fix this. We&#39;ll store a reference to the data in the value accessed by the hash key &quot;_CENSUS&quot;. Why the underscore? Well, mostly because an initial underscore already conveys strong feelings of magicalness to a C programmer. It&#39;s really just a mnemonic device to remind ourselves that this field is special and not to be used as a public data member in the same way that NAME, AGE, and PEERS are. (Because we&#39;ve been developing this code under the strict pragma, prior to perl version 5.004 we&#39;ll have to quote the field name.)</p>

<pre><code>sub new {
    my $class = shift;
    my $self  = {};
    $self-&gt;{NAME}     = undef;
    $self-&gt;{AGE}      = undef;
    $self-&gt;{PEERS}    = [];
    # &quot;private&quot; data
    $self-&gt;{&quot;_CENSUS&quot;} = \$Census;
    bless ($self, $class);
    ++ ${ $self-&gt;{&quot;_CENSUS&quot;} };
    return $self;
}

sub population {
    my $self = shift;
    if (ref $self) {
        return ${ $self-&gt;{&quot;_CENSUS&quot;} };
    } else {
        return $Census;
    }
}

sub DESTROY {
    my $self = shift;
    -- ${ $self-&gt;{&quot;_CENSUS&quot;} };
}</code></pre>

<h2 id="Debugging-Methods"><a class="permalink" href="#Debugging-Methods">#</a><a id="Debugging"></a>Debugging Methods</h2>

<p>It&#39;s common for a class to have a debugging mechanism. For example, you might want to see when objects are created or destroyed. To do that, add a debugging variable as a file-scoped lexical. For this, we&#39;ll pull in the standard Carp module to emit our warnings and fatal messages. That way messages will come out with the caller&#39;s filename and line number instead of our own; if we wanted them to be from our own perspective, we&#39;d just use die() and warn() directly instead of croak() and carp() respectively.</p>

<pre><code>use Carp;
my $Debugging = 0;</code></pre>

<p>Now add a new class method to access the variable.</p>

<pre><code>sub debug {
    my $class = shift;
    if (ref $class)  { confess &quot;Class method called as object method&quot; }
    unless (@_ == 1) { confess &quot;usage: CLASSNAME-&gt;debug(level)&quot; }
    $Debugging = shift;
}</code></pre>

<p>Now fix up DESTROY to murmur a bit as the moribund object expires:</p>

<pre><code>sub DESTROY {
    my $self = shift;
    if ($Debugging) { carp &quot;Destroying $self &quot; . $self-&gt;name }
    -- ${ $self-&gt;{&quot;_CENSUS&quot;} };
}</code></pre>

<p>One could conceivably make a per-object debug state. That way you could call both of these:</p>

<pre><code>Person-&gt;debug(1);   # entire class
$him-&gt;debug(1);     # just this object</code></pre>

<p>To do so, we need our debugging method to be a &quot;bimodal&quot; one, one that works on both classes <i>and</i> objects. Therefore, adjust the debug() and DESTROY methods as follows:</p>

<pre><code>sub debug {
    my $self = shift;
    confess &quot;usage: thing-&gt;debug(level)&quot;    unless @_ == 1;
    my $level = shift;
    if (ref($self))  {
        $self-&gt;{&quot;_DEBUG&quot;} = $level;		# just myself
    } else {
        $Debugging        = $level;         # whole class
    }
}

sub DESTROY {
    my $self = shift;
    if ($Debugging || $self-&gt;{&quot;_DEBUG&quot;}) {
        carp &quot;Destroying $self &quot; . $self-&gt;name;
    }
    -- ${ $self-&gt;{&quot;_CENSUS&quot;} };
}</code></pre>

<p>What happens if a derived class (which we&#39;ll call Employee) inherits methods from this Person base class? Then <code>Employee-&gt;debug()</code>, when called as a class method, manipulates $Person::Debugging not $Employee::Debugging.</p>

<h2 id="Class-Destructors"><a class="permalink" href="#Class-Destructors">#</a><a id="Class2"></a>Class Destructors</h2>

<p>The object destructor handles the death of each distinct object. But sometimes you want a bit of cleanup when the entire class is shut down, which currently only happens when the program exits. To make such a <i>class destructor</i>, create a function in that class&#39;s package named END. This works just like the END function in traditional modules, meaning that it gets called whenever your program exits unless it execs or dies of an uncaught signal. For example,</p>

<pre><code>sub END {
    if ($Debugging) {
        print &quot;All persons are going away now.\n&quot;;
    }
}</code></pre>

<p>When the program exits, all the class destructors (END functions) are be called in the opposite order that they were loaded in (LIFO order).</p>

<h2 id="Documenting-the-Interface"><a class="permalink" href="#Documenting-the-Interface">#</a><a id="Documenting"></a>Documenting the Interface</h2>

<p>And there you have it: we&#39;ve just shown you the <i>implementation</i> of this Person class. Its <i>interface</i> would be its documentation. Usually this means putting it in pod (&quot;plain old documentation&quot;) format right there in the same file. In our Person example, we would place the following docs anywhere in the Person.pm file. Even though it looks mostly like code, it&#39;s not. It&#39;s embedded documentation such as would be used by the pod2man, pod2html, or pod2text programs. The Perl compiler ignores pods entirely, just as the translators ignore code. Here&#39;s an example of some pods describing the informal interface:</p>

<pre><code>=head1 NAME

Person - class to implement people

=head1 SYNOPSIS

 use Person;

 #################
 # class methods #
 #################
 $ob    = Person-&gt;new;
 $count = Person-&gt;population;

 #######################
 # object data methods #
 #######################

 ### get versions ###
     $who   = $ob-&gt;name;
     $years = $ob-&gt;age;
     @pals  = $ob-&gt;peers;

 ### set versions ###
     $ob-&gt;name(&quot;Jason&quot;);
     $ob-&gt;age(23);
     $ob-&gt;peers( &quot;Norbert&quot;, &quot;Rhys&quot;, &quot;Phineas&quot; );

 ########################
 # other object methods #
 ########################

 $phrase = $ob-&gt;exclaim;
 $ob-&gt;happy_birthday;

=head1 DESCRIPTION

The Person class implements dah dee dah dee dah....</code></pre>

<p>That&#39;s all there is to the matter of interface versus implementation. A programmer who opens up the module and plays around with all the private little shiny bits that were safely locked up behind the interface contract has voided the warranty, and you shouldn&#39;t worry about their fate.</p>

<h1 id="Aggregation"><a class="permalink" href="#Aggregation">#</a>Aggregation</h1>

<p>Suppose you later want to change the class to implement better names. Perhaps you&#39;d like to support both given names (called Christian names, irrespective of one&#39;s religion) and family names (called surnames), plus nicknames and titles. If users of your Person class have been properly accessing it through its documented interface, then you can easily change the underlying implementation. If they haven&#39;t, then they lose and it&#39;s their fault for breaking the contract and voiding their warranty.</p>

<p>To do this, we&#39;ll make another class, this one called Fullname. What&#39;s the Fullname class look like? To answer that question, you have to first figure out how you want to use it. How about we use it this way:</p>

<pre><code>$him = Person-&gt;new();
$him-&gt;fullname-&gt;title(&quot;St&quot;);
$him-&gt;fullname-&gt;christian(&quot;Thomas&quot;);
$him-&gt;fullname-&gt;surname(&quot;Aquinas&quot;);
$him-&gt;fullname-&gt;nickname(&quot;Tommy&quot;);
printf &quot;His normal name is %s\n&quot;, $him-&gt;name;
printf &quot;But his real name is %s\n&quot;, $him-&gt;fullname-&gt;as_string;</code></pre>

<p>Ok. To do this, we&#39;ll change Person::new() so that it supports a full name field this way:</p>

<pre><code>sub new {
    my $class = shift;
    my $self  = {};
    $self-&gt;{FULLNAME} = Fullname-&gt;new();
    $self-&gt;{AGE}      = undef;
    $self-&gt;{PEERS}    = [];
    $self-&gt;{&quot;_CENSUS&quot;} = \$Census;
    bless ($self, $class);
    ++ ${ $self-&gt;{&quot;_CENSUS&quot;} };
    return $self;
}

sub fullname {
    my $self = shift;
    return $self-&gt;{FULLNAME};
}</code></pre>

<p>Then to support old code, define Person::name() this way:</p>

<pre><code>sub name {
    my $self = shift;
    return $self-&gt;{FULLNAME}-&gt;nickname(@_)
      ||   $self-&gt;{FULLNAME}-&gt;christian(@_);
}</code></pre>

<p>Here&#39;s the Fullname class. We&#39;ll use the same technique of using a hash reference to hold data fields, and methods by the appropriate name to access them:</p>

<pre><code>package Fullname;
use strict;

sub new {
    my $class = shift;
    my $self  = {
        TITLE       =&gt; undef,
        CHRISTIAN   =&gt; undef,
        SURNAME     =&gt; undef,
        NICK        =&gt; undef,
    };
    bless ($self, $class);
    return $self;
}

sub christian {
    my $self = shift;
    if (@_) { $self-&gt;{CHRISTIAN} = shift }
    return $self-&gt;{CHRISTIAN};
}

sub surname {
    my $self = shift;
    if (@_) { $self-&gt;{SURNAME} = shift }
    return $self-&gt;{SURNAME};
}

sub nickname {
    my $self = shift;
    if (@_) { $self-&gt;{NICK} = shift }
    return $self-&gt;{NICK};
}

sub title {
    my $self = shift;
    if (@_) { $self-&gt;{TITLE} = shift }
    return $self-&gt;{TITLE};
}

sub as_string {
    my $self = shift;
    my $name = join(&quot; &quot;, @$self{&#39;CHRISTIAN&#39;, &#39;SURNAME&#39;});
    if ($self-&gt;{TITLE}) {
        $name = $self-&gt;{TITLE} . &quot; &quot; . $name;
    }
    return $name;
}

1;</code></pre>

<p>Finally, here&#39;s the test program:</p>

<pre><code>#!/usr/bin/perl -w
use strict;
use Person;
sub END { show_census() }

sub show_census ()  {
    printf &quot;Current population: %d\n&quot;, Person-&gt;population;
}

Person-&gt;debug(1);

show_census();

my $him = Person-&gt;new();

$him-&gt;fullname-&gt;christian(&quot;Thomas&quot;);
$him-&gt;fullname-&gt;surname(&quot;Aquinas&quot;);
$him-&gt;fullname-&gt;nickname(&quot;Tommy&quot;);
$him-&gt;fullname-&gt;title(&quot;St&quot;);
$him-&gt;age(1);

printf &quot;%s is really %s.\n&quot;, $him-&gt;name, $him-&gt;fullname-&gt;as_string;
printf &quot;%s&#39;s age: %d.\n&quot;, $him-&gt;name, $him-&gt;age;
$him-&gt;happy_birthday;
printf &quot;%s&#39;s age: %d.\n&quot;, $him-&gt;name, $him-&gt;age;

show_census();</code></pre>

<h1 id="Inheritance"><a class="permalink" href="#Inheritance">#</a>Inheritance</h1>

<p>Object-oriented programming systems all support some notion of inheritance. Inheritance means allowing one class to piggy-back on top of another one so you don&#39;t have to write the same code again and again. It&#39;s about software reuse, and therefore related to Laziness, the principal virtue of a programmer. (The import/export mechanisms in traditional modules are also a form of code reuse, but a simpler one than the true inheritance that you find in object modules.)</p>

<p>Sometimes the syntax of inheritance is built into the core of the language, and sometimes it&#39;s not. Perl has no special syntax for specifying the class (or classes) to inherit from. Instead, it&#39;s all strictly in the semantics. Each package can have a variable called @ISA, which governs (method) inheritance. If you try to call a method on an object or class, and that method is not found in that object&#39;s package, Perl then looks to @ISA for other packages to go looking through in search of the missing method.</p>

<p>Like the special per-package variables recognized by Exporter (such as @EXPORT, @EXPORT_OK, @EXPORT_FAIL, %EXPORT_TAGS, and $VERSION), the @ISA array <i>must</i> be a package-scoped global and not a file-scoped lexical created via my(). Most classes have just one item in their @ISA array. In this case, we have what&#39;s called &quot;single inheritance&quot;, or SI for short.</p>

<p>Consider this class:</p>

<pre><code>package Employee;
use Person;
@ISA = (&quot;Person&quot;);
1;</code></pre>

<p>Not a lot to it, eh? All it&#39;s doing so far is loading in another class and stating that this one will inherit methods from that other class if need be. We have given it none of its own methods. We rely upon an Employee to behave just like a Person.</p>

<p>Setting up an empty class like this is called the &quot;empty subclass test&quot;; that is, making a derived class that does nothing but inherit from a base class. If the original base class has been designed properly, then the new derived class can be used as a drop-in replacement for the old one. This means you should be able to write a program like this:</p>

<pre><code>use Employee;
my $empl = Employee-&gt;new();
$empl-&gt;name(&quot;Jason&quot;);
$empl-&gt;age(23);
printf &quot;%s is age %d.\n&quot;, $empl-&gt;name, $empl-&gt;age;</code></pre>

<p>By proper design, we mean always using the two-argument form of bless(), avoiding direct access of global data, and not exporting anything. If you look back at the Person::new() function we defined above, we were careful to do that. There&#39;s a bit of package data used in the constructor, but the reference to this is stored on the object itself and all other methods access package data via that reference, so we should be ok.</p>

<p>What do we mean by the Person::new() function? Isn&#39;t that actually a method? Well, in principle, yes. A method is just a function that expects as its first argument a class name (package) or object (blessed reference). Person::new() is the function that both the <code>Person-&gt;new()</code> method and the <code>Employee-&gt;new()</code> method end up calling. Understand that while a method call looks a lot like a function call, they aren&#39;t really quite the same, and if you treat them as the same, you&#39;ll very soon be left with nothing but broken programs. First, the actual underlying calling conventions are different: method calls get an extra argument. Second, function calls don&#39;t do inheritance, but methods do.</p>

<pre><code>Method Call             Resulting Function Call
-----------             ------------------------
Person-&gt;new()           Person::new(&quot;Person&quot;)
Employee-&gt;new()         Person::new(&quot;Employee&quot;)</code></pre>

<p>So don&#39;t use function calls when you mean to call a method.</p>

<p>If an employee is just a Person, that&#39;s not all too very interesting. So let&#39;s add some other methods. We&#39;ll give our employee data fields to access their salary, their employee ID, and their start date.</p>

<p>If you&#39;re getting a little tired of creating all these nearly identical methods just to get at the object&#39;s data, do not despair. Later, we&#39;ll describe several different convenience mechanisms for shortening this up. Meanwhile, here&#39;s the straight-forward way:</p>

<pre><code>sub salary {
    my $self = shift;
    if (@_) { $self-&gt;{SALARY} = shift }
    return $self-&gt;{SALARY};
}

sub id_number {
    my $self = shift;
    if (@_) { $self-&gt;{ID} = shift }
    return $self-&gt;{ID};
}

sub start_date {
    my $self = shift;
    if (@_) { $self-&gt;{START_DATE} = shift }
    return $self-&gt;{START_DATE};
}</code></pre>

<h2 id="Overridden-Methods"><a class="permalink" href="#Overridden-Methods">#</a><a id="Overridden"></a>Overridden Methods</h2>

<p>What happens when both a derived class and its base class have the same method defined? Well, then you get the derived class&#39;s version of that method. For example, let&#39;s say that we want the peers() method called on an employee to act a bit differently. Instead of just returning the list of peer names, let&#39;s return slightly different strings. So doing this:</p>

<pre><code>$empl-&gt;peers(&quot;Peter&quot;, &quot;Paul&quot;, &quot;Mary&quot;);
printf &quot;His peers are: %s\n&quot;, join(&quot;, &quot;, $empl-&gt;peers);</code></pre>

<p>will produce:</p>

<pre><code class="plaintext">His peers are: PEON=PETER, PEON=PAUL, PEON=MARY</code></pre>

<p>To do this, merely add this definition into the Employee.pm file:</p>

<pre><code>sub peers {
    my $self = shift;
    if (@_) { @{ $self-&gt;{PEERS} } = @_ }
    return map { &quot;PEON=\U$_&quot; } @{ $self-&gt;{PEERS} };
}</code></pre>

<p>There, we&#39;ve just demonstrated the high-falutin&#39; concept known in certain circles as <i>polymorphism</i>. We&#39;ve taken on the form and behaviour of an existing object, and then we&#39;ve altered it to suit our own purposes. This is a form of Laziness. (Getting polymorphed is also what happens when the wizard decides you&#39;d look better as a frog.)</p>

<p>Every now and then you&#39;ll want to have a method call trigger both its derived class (also known as &quot;subclass&quot;) version as well as its base class (also known as &quot;superclass&quot;) version. In practice, constructors and destructors are likely to want to do this, and it probably also makes sense in the debug() method we showed previously.</p>

<p>To do this, add this to Employee.pm:</p>

<pre><code>use Carp;
my $Debugging = 0;

sub debug {
    my $self = shift;
    confess &quot;usage: thing-&gt;debug(level)&quot;    unless @_ == 1;
    my $level = shift;
    if (ref($self))  {
        $self-&gt;{&quot;_DEBUG&quot;} = $level;
    } else {
        $Debugging = $level;            # whole class
    }
    Person::debug($self, $Debugging);   # don&#39;t really do this
}</code></pre>

<p>As you see, we turn around and call the Person package&#39;s debug() function. But this is far too fragile for good design. What if Person doesn&#39;t have a debug() function, but is inheriting <i>its</i> debug() method from elsewhere? It would have been slightly better to say</p>

<pre><code>Person-&gt;debug($Debugging);</code></pre>

<p>But even that&#39;s got too much hard-coded. It&#39;s somewhat better to say</p>

<pre><code>$self-&gt;Person::debug($Debugging);</code></pre>

<p>Which is a funny way to say to start looking for a debug() method up in Person. This strategy is more often seen on overridden object methods than on overridden class methods.</p>

<p>There is still something a bit off here. We&#39;ve hard-coded our superclass&#39;s name. This in particular is bad if you change which classes you inherit from, or add others. Fortunately, the pseudoclass SUPER comes to the rescue here.</p>

<pre><code>$self-&gt;SUPER::debug($Debugging);</code></pre>

<p>This way it starts looking in my class&#39;s @ISA. This only makes sense from <i>within</i> a method call, though. Don&#39;t try to access anything in SUPER:: from anywhere else, because it doesn&#39;t exist outside an overridden method call. Note that <code>SUPER</code> refers to the superclass of the current package, <i>not</i> to the superclass of <code>$self</code>.</p>

<p>Things are getting a bit complicated here. Have we done anything we shouldn&#39;t? As before, one way to test whether we&#39;re designing a decent class is via the empty subclass test. Since we already have an Employee class that we&#39;re trying to check, we&#39;d better get a new empty subclass that can derive from Employee. Here&#39;s one:</p>

<pre><code>package Boss;
use Employee;        # :-)
@ISA = qw(Employee);</code></pre>

<p>And here&#39;s the test program:</p>

<pre><code>#!/usr/bin/perl -w
use strict;
use Boss;
Boss-&gt;debug(1);

my $boss = Boss-&gt;new();

$boss-&gt;fullname-&gt;title(&quot;Don&quot;);
$boss-&gt;fullname-&gt;surname(&quot;Pichon Alvarez&quot;);
$boss-&gt;fullname-&gt;christian(&quot;Federico Jesus&quot;);
$boss-&gt;fullname-&gt;nickname(&quot;Fred&quot;);

$boss-&gt;age(47);
$boss-&gt;peers(&quot;Frank&quot;, &quot;Felipe&quot;, &quot;Faust&quot;);

printf &quot;%s is age %d.\n&quot;, $boss-&gt;fullname-&gt;as_string, $boss-&gt;age;
printf &quot;His peers are: %s\n&quot;, join(&quot;, &quot;, $boss-&gt;peers);</code></pre>

<p>Running it, we see that we&#39;re still ok. If you&#39;d like to dump out your object in a nice format, somewhat like the way the &#39;x&#39; command works in the debugger, you could use the Data::Dumper module from CPAN this way:</p>

<pre><code>use Data::Dumper;
print &quot;Here&#39;s the boss:\n&quot;;
print Dumper($boss);</code></pre>

<p>Which shows us something like this:</p>

<pre><code>    Here&#39;s the boss:
    $VAR1 = bless( {
	 _CENSUS =&gt; \1,
	 FULLNAME =&gt; bless( {
			      TITLE =&gt; &#39;Don&#39;,
			      SURNAME =&gt; &#39;Pichon Alvarez&#39;,
			      NICK =&gt; &#39;Fred&#39;,
			      CHRISTIAN =&gt; &#39;Federico Jesus&#39;
			    }, &#39;Fullname&#39; ),
	 AGE =&gt; 47,
	 PEERS =&gt; [
		    &#39;Frank&#39;,
		    &#39;Felipe&#39;,
		    &#39;Faust&#39;
		  ]
       }, &#39;Boss&#39; );</code></pre>

<p>Hm.... something&#39;s missing there. What about the salary, start date, and ID fields? Well, we never set them to anything, even undef, so they don&#39;t show up in the hash&#39;s keys. The Employee class has no new() method of its own, and the new() method in Person doesn&#39;t know about Employees. (Nor should it: proper OO design dictates that a subclass be allowed to know about its immediate superclass, but never vice-versa.) So let&#39;s fix up Employee::new() this way:</p>

<pre><code>sub new {
    my $class = shift;
    my $self  = $class-&gt;SUPER::new();
    $self-&gt;{SALARY}        = undef;
    $self-&gt;{ID}            = undef;
    $self-&gt;{START_DATE}    = undef;
    bless ($self, $class);          # reconsecrate
    return $self;
}</code></pre>

<p>Now if you dump out an Employee or Boss object, you&#39;ll find that new fields show up there now.</p>

<h2 id="Multiple-Inheritance"><a class="permalink" href="#Multiple-Inheritance">#</a><a id="Multiple"></a>Multiple Inheritance</h2>

<p>Ok, at the risk of confusing beginners and annoying OO gurus, it&#39;s time to confess that Perl&#39;s object system includes that controversial notion known as multiple inheritance, or MI for short. All this means is that rather than having just one parent class who in turn might itself have a parent class, etc., that you can directly inherit from two or more parents. It&#39;s true that some uses of MI can get you into trouble, although hopefully not quite so much trouble with Perl as with dubiously-OO languages like C++.</p>

<p>The way it works is actually pretty simple: just put more than one package name in your @ISA array. When it comes time for Perl to go finding methods for your object, it looks at each of these packages in order. Well, kinda. It&#39;s actually a fully recursive, depth-first order by default (see <a href="https://perldoc.perl.org/5.12.4/mro">mro</a> for alternate method resolution orders). Consider a bunch of @ISA arrays like this:</p>

<pre><code>@First::ISA    = qw( Alpha );
@Second::ISA   = qw( Beta );
@Third::ISA    = qw( First Second );</code></pre>

<p>If you have an object of class Third:</p>

<pre><code>my $ob = Third-&gt;new();
$ob-&gt;spin();</code></pre>

<p>How do we find a spin() method (or a new() method for that matter)? Because the search is depth-first, classes will be looked up in the following order: Third, First, Alpha, Second, and Beta.</p>

<p>In practice, few class modules have been seen that actually make use of MI. One nearly always chooses simple containership of one class within another over MI. That&#39;s why our Person object <i>contained</i> a Fullname object. That doesn&#39;t mean it <i>was</i> one.</p>

<p>However, there is one particular area where MI in Perl is rampant: borrowing another class&#39;s class methods. This is rather common, especially with some bundled &quot;objectless&quot; classes, like Exporter, DynaLoader, AutoLoader, and SelfLoader. These classes do not provide constructors; they exist only so you may inherit their class methods. (It&#39;s not entirely clear why inheritance was done here rather than traditional module importation.)</p>

<p>For example, here is the POSIX module&#39;s @ISA:</p>

<pre><code>package POSIX;
@ISA = qw(Exporter DynaLoader);</code></pre>

<p>The POSIX module isn&#39;t really an object module, but then, neither are Exporter or DynaLoader. They&#39;re just lending their classes&#39; behaviours to POSIX.</p>

<p>Why don&#39;t people use MI for object methods much? One reason is that it can have complicated side-effects. For one thing, your inheritance graph (no longer a tree) might converge back to the same base class. Although Perl guards against recursive inheritance, merely having parents who are related to each other via a common ancestor, incestuous though it sounds, is not forbidden. What if in our Third class shown above we wanted its new() method to also call both overridden constructors in its two parent classes? The SUPER notation would only find the first one. Also, what about if the Alpha and Beta classes both had a common ancestor, like Nought? If you kept climbing up the inheritance tree calling overridden methods, you&#39;d end up calling Nought::new() twice, which might well be a bad idea.</p>

<h2 id="UNIVERSAL:-The-Root-of-All-Objects"><a class="permalink" href="#UNIVERSAL:-The-Root-of-All-Objects">#</a><a id="UNIVERSAL"></a>UNIVERSAL: The Root of All Objects</h2>

<p>Wouldn&#39;t it be convenient if all objects were rooted at some ultimate base class? That way you could give every object common methods without having to go and add it to each and every @ISA. Well, it turns out that you can. You don&#39;t see it, but Perl tacitly and irrevocably assumes that there&#39;s an extra element at the end of @ISA: the class UNIVERSAL. In version 5.003, there were no predefined methods there, but you could put whatever you felt like into it.</p>

<p>However, as of version 5.004 (or some subversive releases, like 5.003_08), UNIVERSAL has some methods in it already. These are builtin to your Perl binary, so they don&#39;t take any extra time to load. Predefined methods include isa(), can(), and VERSION(). isa() tells you whether an object or class &quot;is&quot; another one without having to traverse the hierarchy yourself:</p>

<pre><code>$has_io = $fd-&gt;isa(&quot;IO::Handle&quot;);
$itza_handle = IO::Socket-&gt;isa(&quot;IO::Handle&quot;);</code></pre>

<p>The can() method, called against that object or class, reports back whether its string argument is a callable method name in that class. In fact, it gives you back a function reference to that method:</p>

<pre><code>$his_print_method = $obj-&gt;can(&#39;as_string&#39;);</code></pre>

<p>Finally, the VERSION method checks whether the class (or the object&#39;s class) has a package global called $VERSION that&#39;s high enough, as in:</p>

<pre><code>Some_Module-&gt;VERSION(3.0);
$his_vers = $ob-&gt;VERSION();</code></pre>

<p>However, we don&#39;t usually call VERSION ourselves. (Remember that an all uppercase function name is a Perl convention that indicates that the function will be automatically used by Perl in some way.) In this case, it happens when you say</p>

<pre><code>use Some_Module 3.0;</code></pre>

<p>If you wanted to add version checking to your Person class explained above, just add this to Person.pm:</p>

<pre><code>our $VERSION = &#39;1.1&#39;;</code></pre>

<p>and then in Employee.pm you can say</p>

<pre><code>use Person 1.1;</code></pre>

<p>And it would make sure that you have at least that version number or higher available. This is not the same as loading in that exact version number. No mechanism currently exists for concurrent installation of multiple versions of a module. Lamentably.</p>

<h2 id="Deeper-UNIVERSAL-details"><a class="permalink" href="#Deeper-UNIVERSAL-details">#</a><a id="Deeper"></a>Deeper UNIVERSAL details</h2>

<p>It is also valid (though perhaps unwise in most cases) to put other packages&#39; names in @UNIVERSAL::ISA. These packages will also be implicitly inherited by all classes, just as UNIVERSAL itself is. However, neither UNIVERSAL nor any of its parents from the @ISA tree are explicit base classes of all objects. To clarify, given the following:</p>

<pre><code>@UNIVERSAL::ISA = (&#39;REALLYUNIVERSAL&#39;);

package REALLYUNIVERSAL;
sub special_method { return &quot;123&quot; }

package Foo;
sub normal_method { return &quot;321&quot; }</code></pre>

<p>Calling Foo-&gt;special_method() will return &quot;123&quot;, but calling Foo-&gt;isa(&#39;REALLYUNIVERSAL&#39;) or Foo-&gt;isa(&#39;UNIVERSAL&#39;) will return false.</p>

<p>If your class is using an alternate mro like C3 (see <a href="https://perldoc.perl.org/5.12.4/mro">mro</a>), method resolution within UNIVERSAL / @UNIVERSAL::ISA will still occur in the default depth-first left-to-right manner, after the class&#39;s C3 mro is exhausted.</p>

<p>All of the above is made more intuitive by realizing what really happens during method lookup, which is roughly like this ugly pseudo-code:</p>

<pre><code>get_mro(class) {
    # recurses down the @ISA&#39;s starting at class,
    # builds a single linear array of all
    # classes to search in the appropriate order.
    # The method resolution order (mro) to use
    # for the ordering is whichever mro &quot;class&quot;
    # has set on it (either default (depth first
    # l-to-r) or C3 ordering).
    # The first entry in the list is the class
    # itself.
}

find_method(class, methname) {
    foreach $class (get_mro(class)) {
        if($class-&gt;has_method(methname)) {
            return ref_to($class-&gt;$methname);
        }
    }
    foreach $class (get_mro(UNIVERSAL)) {
        if($class-&gt;has_method(methname)) {
            return ref_to($class-&gt;$methname);
        }
    }
    return undef;
}</code></pre>

<p>However the code that implements UNIVERSAL::isa does not search in UNIVERSAL itself, only in the package&#39;s actual @ISA.</p>

<h1 id="Alternate-Object-Representations"><a class="permalink" href="#Alternate-Object-Representations">#</a><a id="Alternate"></a>Alternate Object Representations</h1>

<p>Nothing requires objects to be implemented as hash references. An object can be any sort of reference so long as its referent has been suitably blessed. That means scalar, array, and code references are also fair game.</p>

<p>A scalar would work if the object has only one datum to hold. An array would work for most cases, but makes inheritance a bit dodgy because you have to invent new indices for the derived classes.</p>

<h2 id="Arrays-as-Objects"><a class="permalink" href="#Arrays-as-Objects">#</a><a id="Arrays"></a>Arrays as Objects</h2>

<p>If the user of your class honors the contract and sticks to the advertised interface, then you can change its underlying interface if you feel like it. Here&#39;s another implementation that conforms to the same interface specification. This time we&#39;ll use an array reference instead of a hash reference to represent the object.</p>

<pre><code>package Person;
use strict;

my($NAME, $AGE, $PEERS) = ( 0 .. 2 );

############################################
## the object constructor (array version) ##
############################################
sub new {
    my $self = [];
    $self-&gt;[$NAME]   = undef;  # this is unnecessary
    $self-&gt;[$AGE]    = undef;  # as is this
    $self-&gt;[$PEERS]  = [];     # but this isn&#39;t, really
    bless($self);
    return $self;
}

sub name {
    my $self = shift;
    if (@_) { $self-&gt;[$NAME] = shift }
    return $self-&gt;[$NAME];
}

sub age {
    my $self = shift;
    if (@_) { $self-&gt;[$AGE] = shift }
    return $self-&gt;[$AGE];
}

sub peers {
    my $self = shift;
    if (@_) { @{ $self-&gt;[$PEERS] } = @_ }
    return @{ $self-&gt;[$PEERS] };
}

1;  # so the require or use succeeds</code></pre>

<p>You might guess that the array access would be a lot faster than the hash access, but they&#39;re actually comparable. The array is a <i>little</i> bit faster, but not more than ten or fifteen percent, even when you replace the variables above like $AGE with literal numbers, like 1. A bigger difference between the two approaches can be found in memory use. A hash representation takes up more memory than an array representation because you have to allocate memory for the keys as well as for the values. However, it really isn&#39;t that bad, especially since as of version 5.004, memory is only allocated once for a given hash key, no matter how many hashes have that key. It&#39;s expected that sometime in the future, even these differences will fade into obscurity as more efficient underlying representations are devised.</p>

<p>Still, the tiny edge in speed (and somewhat larger one in memory) is enough to make some programmers choose an array representation for simple classes. There&#39;s still a little problem with scalability, though, because later in life when you feel like creating subclasses, you&#39;ll find that hashes just work out better.</p>

<h2 id="Closures-as-Objects"><a class="permalink" href="#Closures-as-Objects">#</a><a id="Closures"></a>Closures as Objects</h2>

<p>Using a code reference to represent an object offers some fascinating possibilities. We can create a new anonymous function (closure) who alone in all the world can see the object&#39;s data. This is because we put the data into an anonymous hash that&#39;s lexically visible only to the closure we create, bless, and return as the object. This object&#39;s methods turn around and call the closure as a regular subroutine call, passing it the field we want to affect. (Yes, the double-function call is slow, but if you wanted fast, you wouldn&#39;t be using objects at all, eh? :-)</p>

<p>Use would be similar to before:</p>

<pre><code>use Person;
$him = Person-&gt;new();
$him-&gt;name(&quot;Jason&quot;);
$him-&gt;age(23);
$him-&gt;peers( [ &quot;Norbert&quot;, &quot;Rhys&quot;, &quot;Phineas&quot; ] );
printf &quot;%s is %d years old.\n&quot;, $him-&gt;name, $him-&gt;age;
print &quot;His peers are: &quot;, join(&quot;, &quot;, @{$him-&gt;peers}), &quot;\n&quot;;</code></pre>

<p>but the implementation would be radically, perhaps even sublimely different:</p>

<pre><code>    package Person;

    sub new {
	 my $class  = shift;
	 my $self = {
	    NAME  =&gt; undef,
	    AGE   =&gt; undef,
	    PEERS =&gt; [],
	 };
	 my $closure = sub {
	    my $field = shift;
	    if (@_) { $self-&gt;{$field} = shift }
	    return    $self-&gt;{$field};
	};
	bless($closure, $class);
	return $closure;
    }

    sub name   { &amp;{ $_[0] }(&quot;NAME&quot;,  @_[ 1 .. $#_ ] ) }
    sub age    { &amp;{ $_[0] }(&quot;AGE&quot;,   @_[ 1 .. $#_ ] ) }
    sub peers  { &amp;{ $_[0] }(&quot;PEERS&quot;, @_[ 1 .. $#_ ] ) }

    1;</code></pre>

<p>Because this object is hidden behind a code reference, it&#39;s probably a bit mysterious to those whose background is more firmly rooted in standard procedural or object-based programming languages than in functional programming languages whence closures derive. The object created and returned by the new() method is itself not a data reference as we&#39;ve seen before. It&#39;s an anonymous code reference that has within it access to a specific version (lexical binding and instantiation) of the object&#39;s data, which are stored in the private variable $self. Although this is the same function each time, it contains a different version of $self.</p>

<p>When a method like <code>$him-&gt;name(&quot;Jason&quot;)</code> is called, its implicit zeroth argument is the invoking object--just as it is with all method calls. But in this case, it&#39;s our code reference (something like a function pointer in C++, but with deep binding of lexical variables). There&#39;s not a lot to be done with a code reference beyond calling it, so that&#39;s just what we do when we say <code>&amp;{$_[0]}</code>. This is just a regular function call, not a method call. The initial argument is the string &quot;NAME&quot;, and any remaining arguments are whatever had been passed to the method itself.</p>

<p>Once we&#39;re executing inside the closure that had been created in new(), the $self hash reference suddenly becomes visible. The closure grabs its first argument (&quot;NAME&quot; in this case because that&#39;s what the name() method passed it), and uses that string to subscript into the private hash hidden in its unique version of $self.</p>

<p>Nothing under the sun will allow anyone outside the executing method to be able to get at this hidden data. Well, nearly nothing. You <i>could</i> single step through the program using the debugger and find out the pieces while you&#39;re in the method, but everyone else is out of luck.</p>

<p>There, if that doesn&#39;t excite the Scheme folks, then I just don&#39;t know what will. Translation of this technique into C++, Java, or any other braindead-static language is left as a futile exercise for aficionados of those camps.</p>

<p>You could even add a bit of nosiness via the caller() function and make the closure refuse to operate unless called via its own package. This would no doubt satisfy certain fastidious concerns of programming police and related puritans.</p>

<p>If you were wondering when Hubris, the third principle virtue of a programmer, would come into play, here you have it. (More seriously, Hubris is just the pride in craftsmanship that comes from having written a sound bit of well-designed code.)</p>

<h1 id="AUTOLOAD:-Proxy-Methods"><a class="permalink" href="#AUTOLOAD:-Proxy-Methods">#</a><a id="AUTOLOAD"></a>AUTOLOAD: Proxy Methods</h1>

<p>Autoloading is a way to intercept calls to undefined methods. An autoload routine may choose to create a new function on the fly, either loaded from disk or perhaps just eval()ed right there. This define-on-the-fly strategy is why it&#39;s called autoloading.</p>

<p>But that&#39;s only one possible approach. Another one is to just have the autoloaded method itself directly provide the requested service. When used in this way, you may think of autoloaded methods as &quot;proxy&quot; methods.</p>

<p>When Perl tries to call an undefined function in a particular package and that function is not defined, it looks for a function in that same package called AUTOLOAD. If one exists, it&#39;s called with the same arguments as the original function would have had. The fully-qualified name of the function is stored in that package&#39;s global variable $AUTOLOAD. Once called, the function can do anything it would like, including defining a new function by the right name, and then doing a really fancy kind of <code>goto</code> right to it, erasing itself from the call stack.</p>

<p>What does this have to do with objects? After all, we keep talking about functions, not methods. Well, since a method is just a function with an extra argument and some fancier semantics about where it&#39;s found, we can use autoloading for methods, too. Perl doesn&#39;t start looking for an AUTOLOAD method until it has exhausted the recursive hunt up through @ISA, though. Some programmers have even been known to define a UNIVERSAL::AUTOLOAD method to trap unresolved method calls to any kind of object.</p>

<h2 id="Autoloaded-Data-Methods"><a class="permalink" href="#Autoloaded-Data-Methods">#</a><a id="Autoloaded"></a>Autoloaded Data Methods</h2>

<p>You probably began to get a little suspicious about the duplicated code way back earlier when we first showed you the Person class, and then later the Employee class. Each method used to access the hash fields looked virtually identical. This should have tickled that great programming virtue, Impatience, but for the time, we let Laziness win out, and so did nothing. Proxy methods can cure this.</p>

<p>Instead of writing a new function every time we want a new data field, we&#39;ll use the autoload mechanism to generate (actually, mimic) methods on the fly. To verify that we&#39;re accessing a valid member, we will check against an <code>_permitted</code> (pronounced &quot;under-permitted&quot;) field, which is a reference to a file-scoped lexical (like a C file static) hash of permitted fields in this record called %fields. Why the underscore? For the same reason as the _CENSUS field we once used: as a marker that means &quot;for internal use only&quot;.</p>

<p>Here&#39;s what the module initialization code and class constructor will look like when taking this approach:</p>

<pre><code>    package Person;
    use Carp;
    our $AUTOLOAD;  # it&#39;s a package global

    my %fields = (
	name        =&gt; undef,
	age         =&gt; undef,
	peers       =&gt; undef,
    );

    sub new {
	my $class = shift;
	my $self  = {
	    _permitted =&gt; \%fields,
	    %fields,
	};
	bless $self, $class;
	return $self;
    }</code></pre>

<p>If we wanted our record to have default values, we could fill those in where current we have <code>undef</code> in the %fields hash.</p>

<p>Notice how we saved a reference to our class data on the object itself? Remember that it&#39;s important to access class data through the object itself instead of having any method reference %fields directly, or else you won&#39;t have a decent inheritance.</p>

<p>The real magic, though, is going to reside in our proxy method, which will handle all calls to undefined methods for objects of class Person (or subclasses of Person). It has to be called AUTOLOAD. Again, it&#39;s all caps because it&#39;s called for us implicitly by Perl itself, not by a user directly.</p>

<pre><code>    sub AUTOLOAD {
	my $self = shift;
	my $type = ref($self)
		    or croak &quot;$self is not an object&quot;;

	my $name = $AUTOLOAD;
	$name =~ s/.*://;   # strip fully-qualified portion

	unless (exists $self-&gt;{_permitted}-&gt;{$name} ) {
	    croak &quot;Can&#39;t access `$name&#39; field in class $type&quot;;
	}

	if (@_) {
	    return $self-&gt;{$name} = shift;
	} else {
	    return $self-&gt;{$name};
	}
    }</code></pre>

<p>Pretty nifty, eh? All we have to do to add new data fields is modify %fields. No new functions need be written.</p>

<p>I could have avoided the <code>_permitted</code> field entirely, but I wanted to demonstrate how to store a reference to class data on the object so you wouldn&#39;t have to access that class data directly from an object method.</p>

<h2 id="Inherited-Autoloaded-Data-Methods"><a class="permalink" href="#Inherited-Autoloaded-Data-Methods">#</a><a id="Inherited"></a>Inherited Autoloaded Data Methods</h2>

<p>But what about inheritance? Can we define our Employee class similarly? Yes, so long as we&#39;re careful enough.</p>

<p>Here&#39;s how to be careful:</p>

<pre><code>    package Employee;
    use Person;
    use strict;
    our @ISA = qw(Person);

    my %fields = (
	id          =&gt; undef,
	salary      =&gt; undef,
    );

    sub new {
	my $class = shift;
	my $self  = $class-&gt;SUPER::new();
	my($element);
	foreach $element (keys %fields) {
	    $self-&gt;{_permitted}-&gt;{$element} = $fields{$element};
	}
	@{$self}{keys %fields} = values %fields;
	return $self;
    }</code></pre>

<p>Once we&#39;ve done this, we don&#39;t even need to have an AUTOLOAD function in the Employee package, because we&#39;ll grab Person&#39;s version of that via inheritance, and it will all work out just fine.</p>

<h1 id="Metaclassical-Tools"><a class="permalink" href="#Metaclassical-Tools">#</a><a id="Metaclassical"></a>Metaclassical Tools</h1>

<p>Even though proxy methods can provide a more convenient approach to making more struct-like classes than tediously coding up data methods as functions, it still leaves a bit to be desired. For one thing, it means you have to handle bogus calls that you don&#39;t mean to trap via your proxy. It also means you have to be quite careful when dealing with inheritance, as detailed above.</p>

<p>Perl programmers have responded to this by creating several different class construction classes. These metaclasses are classes that create other classes. A couple worth looking at are Class::Struct and Alias. These and other related metaclasses can be found in the modules directory on CPAN.</p>

<h2 id="Class::Struct"><a class="permalink" href="#Class::Struct">#</a><a id="Class3"></a>Class::Struct</h2>

<p>One of the older ones is Class::Struct. In fact, its syntax and interface were sketched out long before perl5 even solidified into a real thing. What it does is provide you a way to &quot;declare&quot; a class as having objects whose fields are of a specific type. The function that does this is called, not surprisingly enough, struct(). Because structures or records are not base types in Perl, each time you want to create a class to provide a record-like data object, you yourself have to define a new() method, plus separate data-access methods for each of that record&#39;s fields. You&#39;ll quickly become bored with this process. The Class::Struct::struct() function alleviates this tedium.</p>

<p>Here&#39;s a simple example of using it:</p>

<pre><code>use Class::Struct qw(struct);
use Jobbie;  # user-defined; see below

struct &#39;Fred&#39; =&gt; {
    one        =&gt; &#39;$&#39;,
    many       =&gt; &#39;@&#39;,
    profession =&gt; &#39;Jobbie&#39;,  # does not call Jobbie-&gt;new()
};

$ob = Fred-&gt;new(profession =&gt; Jobbie-&gt;new());
$ob-&gt;one(&quot;hmmmm&quot;);

$ob-&gt;many(0, &quot;here&quot;);
$ob-&gt;many(1, &quot;you&quot;);
$ob-&gt;many(2, &quot;go&quot;);
print &quot;Just set: &quot;, $ob-&gt;many(2), &quot;\n&quot;;

$ob-&gt;profession-&gt;salary(10_000);</code></pre>

<p>You can declare types in the struct to be basic Perl types, or user-defined types (classes). User types will be initialized by calling that class&#39;s new() method.</p>

<p>Take care that the <code>Jobbie</code> object is not created automatically by the <code>Fred</code> class&#39;s new() method, so you should specify a <code>Jobbie</code> object when you create an instance of <code>Fred</code>.</p>

<p>Here&#39;s a real-world example of using struct generation. Let&#39;s say you wanted to override Perl&#39;s idea of gethostbyname() and gethostbyaddr() so that they would return objects that acted like C structures. We don&#39;t care about high-falutin&#39; OO gunk. All we want is for these objects to act like structs in the C sense.</p>

<pre><code>    use Socket;
    use Net::hostent;
    $h = gethostbyname(&quot;perl.com&quot;);  # object return
    printf &quot;perl.com&#39;s real name is %s, address %s\n&quot;,
	$h-&gt;name, inet_ntoa($h-&gt;addr);</code></pre>

<p>Here&#39;s how to do this using the Class::Struct module. The crux is going to be this call:</p>

<pre><code>    struct &#39;Net::hostent&#39; =&gt; [  	# note bracket
	name       =&gt; &#39;$&#39;,
	aliases    =&gt; &#39;@&#39;,
	addrtype   =&gt; &#39;$&#39;,
	&#39;length&#39;   =&gt; &#39;$&#39;,
	addr_list  =&gt; &#39;@&#39;,
     ];</code></pre>

<p>Which creates object methods of those names and types. It even creates a new() method for us.</p>

<p>We could also have implemented our object this way:</p>

<pre><code>    struct &#39;Net::hostent&#39; =&gt; {  	# note brace
	name       =&gt; &#39;$&#39;,
	aliases    =&gt; &#39;@&#39;,
	addrtype   =&gt; &#39;$&#39;,
	&#39;length&#39;   =&gt; &#39;$&#39;,
	addr_list  =&gt; &#39;@&#39;,
     };</code></pre>

<p>and then Class::Struct would have used an anonymous hash as the object type, instead of an anonymous array. The array is faster and smaller, but the hash works out better if you eventually want to do inheritance. Since for this struct-like object we aren&#39;t planning on inheritance, this time we&#39;ll opt for better speed and size over better flexibility.</p>

<p>Here&#39;s the whole implementation:</p>

<pre><code>    package Net::hostent;
    use strict;

    BEGIN {
	use Exporter   ();
	our @EXPORT      = qw(gethostbyname gethostbyaddr gethost);
	our @EXPORT_OK   = qw(
			       $h_name         @h_aliases
			       $h_addrtype     $h_length
			       @h_addr_list    $h_addr
			   );
	our %EXPORT_TAGS = ( FIELDS =&gt; [ @EXPORT_OK, @EXPORT ] );
    }
    our @EXPORT_OK;

    # Class::Struct forbids use of @ISA
    sub import { goto &amp;Exporter::import }

    use Class::Struct qw(struct);
    struct &#39;Net::hostent&#39; =&gt; [
       name        =&gt; &#39;$&#39;,
       aliases     =&gt; &#39;@&#39;,
       addrtype    =&gt; &#39;$&#39;,
       &#39;length&#39;    =&gt; &#39;$&#39;,
       addr_list   =&gt; &#39;@&#39;,
    ];

    sub addr { shift-&gt;addr_list-&gt;[0] }

    sub populate (@) {
	return unless @_;
	my $hob = new();  # Class::Struct made this!
	$h_name     =    $hob-&gt;[0]              = $_[0];
	@h_aliases  = @{ $hob-&gt;[1] } = split &#39; &#39;, $_[1];
	$h_addrtype =    $hob-&gt;[2]              = $_[2];
	$h_length   =    $hob-&gt;[3]              = $_[3];
	$h_addr     =                             $_[4];
	@h_addr_list = @{ $hob-&gt;[4] } =         @_[ (4 .. $#_) ];
	return $hob;
    }

    sub gethostbyname ($)  { populate(CORE::gethostbyname(shift)) }

    sub gethostbyaddr ($;$) {
	my ($addr, $addrtype);
	$addr = shift;
	require Socket unless @_;
	$addrtype = @_ ? shift : Socket::AF_INET();
	populate(CORE::gethostbyaddr($addr, $addrtype))
    }

    sub gethost($) {
	if ($_[0] =~ /^\d+(?:\.\d+(?:\.\d+(?:\.\d+)?)?)?$/) {
	   require Socket;
	   &amp;gethostbyaddr(Socket::inet_aton(shift));
	} else {
	   &amp;gethostbyname;
	}
    }

    1;</code></pre>

<p>We&#39;ve snuck in quite a fair bit of other concepts besides just dynamic class creation, like overriding core functions, import/export bits, function prototyping, short-cut function call via <code>&amp;whatever</code>, and function replacement with <code>goto &amp;whatever</code>. These all mostly make sense from the perspective of a traditional module, but as you can see, we can also use them in an object module.</p>

<p>You can look at other object-based, struct-like overrides of core functions in the 5.004 release of Perl in File::stat, Net::hostent, Net::netent, Net::protoent, Net::servent, Time::gmtime, Time::localtime, User::grent, and User::pwent. These modules have a final component that&#39;s all lowercase, by convention reserved for compiler pragmas, because they affect the compilation and change a builtin function. They also have the type names that a C programmer would most expect.</p>

<h2 id="Data-Members-as-Variables"><a class="permalink" href="#Data-Members-as-Variables">#</a><a id="Data"></a>Data Members as Variables</h2>

<p>If you&#39;re used to C++ objects, then you&#39;re accustomed to being able to get at an object&#39;s data members as simple variables from within a method. The Alias module provides for this, as well as a good bit more, such as the possibility of private methods that the object can call but folks outside the class cannot.</p>

<p>Here&#39;s an example of creating a Person using the Alias module. When you update these magical instance variables, you automatically update value fields in the hash. Convenient, eh?</p>

<pre><code>    package Person;

    # this is the same as before...
    sub new {
	 my $class = shift;
	 my $self = {
	    NAME  =&gt; undef,
	    AGE   =&gt; undef,
	    PEERS =&gt; [],
	};
	bless($self, $class);
	return $self;
    }

    use Alias qw(attr);
    our ($NAME, $AGE, $PEERS);

    sub name {
	my $self = attr shift;
	if (@_) { $NAME = shift; }
	return    $NAME;
    }

    sub age {
	my $self = attr shift;
	if (@_) { $AGE = shift; }
	return    $AGE;
    }

    sub peers {
	my $self = attr shift;
	if (@_) { @PEERS = @_; }
	return    @PEERS;
    }

    sub exclaim {
        my $self = attr shift;
        return sprintf &quot;Hi, I&#39;m %s, age %d, working with %s&quot;,
            $NAME, $AGE, join(&quot;, &quot;, @PEERS);
    }

    sub happy_birthday {
        my $self = attr shift;
        return ++$AGE;
    }</code></pre>

<p>The need for the <code>our</code> declaration is because what Alias does is play with package globals with the same name as the fields. To use globals while <code>use strict</code> is in effect, you have to predeclare them. These package variables are localized to the block enclosing the attr() call just as if you&#39;d used a local() on them. However, that means that they&#39;re still considered global variables with temporary values, just as with any other local().</p>

<p>It would be nice to combine Alias with something like Class::Struct or Class::MethodMaker.</p>

<h1 id="NOTES"><a class="permalink" href="#NOTES">#</a>NOTES</h1>

<h2 id="Object-Terminology"><a class="permalink" href="#Object-Terminology">#</a><a id="Object1"></a>Object Terminology</h2>

<p>In the various OO literature, it seems that a lot of different words are used to describe only a few different concepts. If you&#39;re not already an object programmer, then you don&#39;t need to worry about all these fancy words. But if you are, then you might like to know how to get at the same concepts in Perl.</p>

<p>For example, it&#39;s common to call an object an <i>instance</i> of a class and to call those objects&#39; methods <i>instance methods</i>. Data fields peculiar to each object are often called <i>instance data</i> or <i>object attributes</i>, and data fields common to all members of that class are <i>class data</i>, <i>class attributes</i>, or <i>static data members</i>.</p>

<p>Also, <i>base class</i>, <i>generic class</i>, and <i>superclass</i> all describe the same notion, whereas <i>derived class</i>, <i>specific class</i>, and <i>subclass</i> describe the other related one.</p>

<p>C++ programmers have <i>static methods</i> and <i>virtual methods</i>, but Perl only has <i>class methods</i> and <i>object methods</i>. Actually, Perl only has methods. Whether a method gets used as a class or object method is by usage only. You could accidentally call a class method (one expecting a string argument) on an object (one expecting a reference), or vice versa.</p>

<p>From the C++ perspective, all methods in Perl are virtual. This, by the way, is why they are never checked for function prototypes in the argument list as regular builtin and user-defined functions can be.</p>

<p>Because a class is itself something of an object, Perl&#39;s classes can be taken as describing both a &quot;class as meta-object&quot; (also called <i>object factory</i>) philosophy and the &quot;class as type definition&quot; (<i>declaring</i> behaviour, not <i>defining</i> mechanism) idea. C++ supports the latter notion, but not the former.</p>

<h1 id="SEE-ALSO"><a class="permalink" href="#SEE-ALSO">#</a><a id="SEE"></a>SEE ALSO</h1>

<p>The following manpages will doubtless provide more background for this one: <a href="perlmod.html">perlmod</a>, <a href="perlref.html">perlref</a>, <a href="perlobj.html">perlobj</a>, <a href="perlbot.html">perlbot</a>, <a href="perltie.html">perltie</a>, and <a href="https://perldoc.perl.org/5.12.4/overload">overload</a>.</p>

<p><a href="perlboot.html">perlboot</a> is a kinder, gentler introduction to object-oriented programming.</p>

<p><a href="perltooc.html">perltooc</a> provides more detail on class data.</p>

<p>Some modules which might prove interesting are Class::Accessor, Class::Class, Class::Contract, Class::Data::Inheritable, Class::MethodMaker and Tie::SecureHash</p>

<h1 id="AUTHOR-AND-COPYRIGHT"><a class="permalink" href="#AUTHOR-AND-COPYRIGHT">#</a><a id="AUTHOR"></a>AUTHOR AND COPYRIGHT</h1>

<p>Copyright (c) 1997, 1998 Tom Christiansen All rights reserved.</p>

<p>This documentation is free; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

<p>Irrespective of its distribution, all code examples in this file are hereby placed into the public domain. You are permitted and encouraged to use this code in your own programs for fun or for profit as you see fit. A simple comment in the code giving credit would be courteous but is not required.</p>

<h1 id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">#</a>COPYRIGHT</h1>

<h2 id="Acknowledgments"><a class="permalink" href="#Acknowledgments">#</a>Acknowledgments</h2>

<p>Thanks to Larry Wall, Roderick Schertler, Gurusamy Sarathy, Dean Roehrich, Raphael Manfredi, Brent Halsey, Greg Bacon, Brad Appleton, and many others for their helpful comments.</p>


      </div>
      <div id="footer">
        <p>Perldoc Browser is maintained by Dan Book (<a href="https://metacpan.org/author/DBOOK">DBOOK</a>). Please contact him via the <a href="https://github.com/Grinnz/perldoc-browser/issues">GitHub issue tracker</a> or <a href="mailto:dbook@cpan.org">email</a> regarding any issues with the site itself, search, or rendering of documentation.</p>

<p>The Perl documentation is maintained by the Perl 5 Porters in the development of Perl. Please contact them via the <a href="https://github.com/Perl/perl5/issues">Perl issue tracker</a>, the <a href="https://lists.perl.org/list/perl5-porters.html">mailing list</a>, or <a href="https://kiwiirc.com/client/irc.perl.org/p5p">IRC</a> to report any issues with the contents or format of the documentation.</p>


      </div>
    </div>
    <script src="../js/bootstrap.bundle.min.js"></script>
    <script src="../js/highlight.pack.js"></script>
    <script>hljs.highlightAll();</script>
  </body>

<!-- Mirrored from perldoc.perl.org/5.12.4/perltoot by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 06 Aug 2025 16:20:39 GMT -->
</html>
